<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从运营事故中成长</title>
    <url>/2020/01/16/2020-01-16-accident_learn/</url>
    <content><![CDATA[<h3 id="发布环节"><a href="#发布环节" class="headerlink" title="发布环节"></a>发布环节</h3><p>在经过一段时间的积累后, 会形成一套完善的发布流程, 此时, 在发布前能让自己提高的空间会越来越有限</p>
<h3 id="发生运营事故后要怎么做"><a href="#发生运营事故后要怎么做" class="headerlink" title="发生运营事故后要怎么做"></a>发生运营事故后要怎么做</h3><ol>
<li>不是单纯地处理完问题就完事, 然后就阿弥托福以后不会再发生.</li>
<li>将每次运营事故都当成一次宝贵的学习机会, 仔细检讨为什么会发生该事故, 是什么问题导致的, 从根本上找出原因, 并找到解决方案, 不要再次发生类似的错误.</li>
<li>事故报告的改进措施, 不能简单的从思想层面去检讨, 下一顿决心就完事了, 事故报告也不是写完发给大家看一眼, 就完事了. 改进措施是必须要能够转化为工作量的实在的事情, 可以是1个周, 一个月, 一个季度, 但是一定要能够量化, 要能够实施, 并且认真地执行完成</li>
<li>要经常翻看以往的运营事故报告, 从前人的事故中成长, 这样才能避免不同的人去犯类似的错误.</li>
</ol>
]]></content>
      <categories>
        <category>意识</category>
      </categories>
      <tags>
        <tag>运营事故</tag>
        <tag>通识</tag>
      </tags>
  </entry>
  <entry>
    <title>awk怎么写?</title>
    <url>/2020/01/16/2020-01-16-awk/</url>
    <content><![CDATA[<p>本篇文章主要是参考左耳朵耗子前辈的博文整理而来, 作为自己学习备忘之用.</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>awk是一个强大的文本分析工具, 相对于grep的查找, sed的编辑, awk在其对数据分析并生成报告时, 显得尤为强大. 简单来说awk就是把文件逐行的读入, 以空格为默认分隔符将每行切片, 切开的部分再进行各种分析处理.</p>
<p>awk有3个不同版本: awk, nawk和gawk, 未作特别说明, 一般指gawk, gawk是AWK的GNU版本.</p>
<p>awk其名称得自于它的创始人Alfred Aho, Peter Weinberger和Brian Kernighan姓氏的首个字母. 实际上 AWK 的确拥有自己的语言: AWK 程序设计语言, 三位创建者已将它正式定义为”样式扫描和处理语言”. 它允许您创建简短的程序, 这些程序读取输入文件, 为数据排序, 处理数据, 对输入执行计算以及生成报表, 还有无数其他的功能.</p>
<span id="more"></span>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;pattern + &#123;action&#125;&#x27;</span> &#123;filenames&#125;</span><br></pre></td></tr></table></figure>

<p>尽管操作可能会很复杂, 但语法总是这样, 其中 pattern 表示 AWK 在数据中查找的内容, 而 action 是在找到匹配内容时所执行的一系列命令.花括号（{}）不需要在程序中始终出现, 但它们用于根据特定的模式对一系列指令进行分组. pattern就是要表示的正则表达式, 用斜杠括起来.</p>
<p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息, awk抽取信息后, 才能进行其他文本操作.完整的awk脚本通常用来格式化文本文件中的信息.<br>通常, awk是以文件的一行为处理单位的.awk每接收文件的一行, 然后执行相应的命令, 来处理文本.</p>
<h3 id="调用awk有三种方式调用awk"><a href="#调用awk有三种方式调用awk" class="headerlink" title="调用awk有三种方式调用awk"></a>调用awk有三种方式调用awk</h3><ol>
<li>命令行方式awk [-F  field-separator]  ‘commands’  input-file(s)其中, commands 是真正awk命令, [-F域分隔符]是可选的. input-file(s) 是待处理的文件.在awk中, 文件的每一行中, 由域分隔符分开的每一项称为一个域.通常, 在不指名-F域分隔符的情况下, 默认的域分隔符是空格.</li>
<li>shell脚本方式将所有的awk命令插入一个文件, 并使awk程序可执行, 然后awk命令解释器作为脚本的首行, 以便通过键入脚本名称来调用.相当于shell脚本首行的：#!&#x2F;bin&#x2F;sh可以换成：#!&#x2F;bin&#x2F;awk</li>
<li>将所有的awk命令插入一个单独文件, 然后调用：awk -f awk-script-file input-file(s)其中, -f选项加载awk-script-file中的awk脚本, input-file(s)跟上面的是一样的.</li>
</ol>
<h4 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h4><p>假设last -n 5的输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ last -n 5 &lt;==仅取出前五行</span><br><span class="line">root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged <span class="keyword">in</span></span><br><span class="line">root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</span><br><span class="line">root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</span><br><span class="line">dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</span><br><span class="line">root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</span><br></pre></td></tr></table></figure>

<p>如果只是显示最近登录的5个帐号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ last -n 5 | awk  <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>  -- 必须是单引号<span class="string">&#x27; &#x27;</span>,<span class="string">&quot; &quot;</span>不生效的</span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">dmtsai</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录, 然后将记录按指定的域分隔符划分域, 填充域, $0则表示所有域, $1表示第一个域, $n表示第n个域. 默认域分隔符是”空白键” 或 “[tab]键”, 所以$1表示登录用户, $3表示登录用户ip,以此类推.<br>字符串匹配的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;$6 ~ /FIN/ || NR==1 &#123;print NR,$4,$5,$6&#125;&#x27;</span> OFS=<span class="string">&quot;\t&quot;</span> netstat.txt</span><br><span class="line">1       Local-Address   Foreign-Address State</span><br><span class="line">6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2</span><br><span class="line">9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2</span><br><span class="line">13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1</span><br><span class="line">18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;$6 ~ /WAIT/ || NR==1 &#123;print NR,$4,$5,$6&#125;&#x27;</span> OFS=<span class="string">&quot;\t&quot;</span> netstat.txt</span><br><span class="line">1       Local-Address   Foreign-Address State</span><br><span class="line">5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT</span><br><span class="line">6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2</span><br><span class="line">9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2</span><br><span class="line">11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT</span><br><span class="line">13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1</span><br><span class="line">15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT</span><br><span class="line">18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2</span><br></pre></td></tr></table></figure>

<p>上面的第一个示例匹配FIN状态,  第二个示例匹配WAIT字样的状态.其实 ~ 表示模式开始.&#x2F; &#x2F;中是模式.其实就是一个正则表达式的匹配.<br>可以使用 “&#x2F;FIN|TIME&#x2F;“ 来匹配 FIN 或者 TIME :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;$6 ~ /FIN|TIME/ || NR==1 &#123;print NR,$4,$5,$6&#125;&#x27;</span> OFS=<span class="string">&quot;\t&quot;</span> netstat.txt</span><br><span class="line">1       Local-Address   Foreign-Address State</span><br><span class="line">5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT</span><br><span class="line">6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2</span><br><span class="line">9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2</span><br><span class="line">11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT</span><br><span class="line">13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1</span><br><span class="line">15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT</span><br><span class="line">18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2</span><br></pre></td></tr></table></figure>

<p>再来看看模式取反的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;$6 !~ /WAIT/ || NR==1 &#123;print NR,$4,$5,$6&#125;&#x27;</span> OFS=<span class="string">&quot;\t&quot;</span> netstat.txt</span><br><span class="line">1       Local-Address   Foreign-Address State</span><br><span class="line">2       0.0.0.0:3306    0.0.0.0:*       LISTEN</span><br><span class="line">3       0.0.0.0:80      0.0.0.0:*       LISTEN</span><br><span class="line">4       127.0.0.1:9000  0.0.0.0:*       LISTEN</span><br><span class="line">7       coolshell.cn:80 110.194.134.189:1032    ESTABLISHED</span><br><span class="line">8       coolshell.cn:80 123.169.124.111:49809   ESTABLISHED</span><br><span class="line">10      coolshell.cn:80 123.169.124.111:49829   ESTABLISHED</span><br><span class="line">12      coolshell.cn:80 61.148.242.38:30901     ESTABLISHED</span><br><span class="line">14      coolshell.cn:80 110.194.134.189:4796    ESTABLISHED</span><br><span class="line">16      coolshell.cn:80 208.115.113.92:50601    LAST_ACK</span><br><span class="line">17      coolshell.cn:80 123.169.124.111:49840   ESTABLISHED</span><br><span class="line">19      :::22   :::*    LISTEN</span><br></pre></td></tr></table></figure>

<p>或是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;!/WAIT/&#x27;</span> netstat.txt</span><br></pre></td></tr></table></figure>

<p>如果只是显示&#x2F;etc&#x2F;passwd的账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">rootdaemonbinsys</span><br></pre></td></tr></table></figure>

<p>这种是awk+action的示例, 每行都会执行action {print $1}.</p>
<p>-F指定域分隔符为’:’.<br>如果只是显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell,而账户与shell之间以tab键分割</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;&#123;print $1&quot;\t&quot;$7&#125;&#x27;</span></span><br><span class="line">root    /bin/bash</span><br><span class="line">daemon  /bin/sh</span><br><span class="line">bin     /bin/sh</span><br><span class="line">sys     /bin/sh</span><br></pre></td></tr></table></figure>

<p>如果只是显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell, 而账户与shell之间以逗号分割, 而且在所有行添加列名name, shell, 在最后一行添加”blue,&#x2F;bin&#x2F;nosh”.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/passwd |awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&#x27;</span></span><br><span class="line">name,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/bin/sh</span><br><span class="line">bin,/bin/sh</span><br><span class="line">sys,/bin/sh</span><br><span class="line">....</span><br><span class="line">blue,/bin/nosh</span><br></pre></td></tr></table></figure>

<p>awk工作流程是这样的：先执行BEGIN, 然后读取文件, 读入有&#x2F;n换行符分割的一条记录, 然后将记录按指定的域分隔符划分域, 填充域, $0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action.接着开始读入第二条记录······直到所有的记录都读完, 最后执行END操作.<br>搜索&#x2F;etc&#x2F;passwd有root关键字的所有行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk -F: <span class="string">&#x27;/root/&#x27;</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<p>这种是pattern的使用示例, 匹配了pattern(这里是root)的行才会执行action(没有指定action, 默认输出每行的内容).<br>搜索支持正则, 例如找root开头的: awk -F: ‘&#x2F;^root&#x2F;‘ &#x2F;etc&#x2F;passwd<br>搜索&#x2F;etc&#x2F;passwd有root关键字的所有行, 并显示对应的shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk -F: <span class="string">&#x27;/root/ &#123;print $7&#125;&#x27;</span> /etc/passwd</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>这里指定了action{print $7}<br>awk内置变量awk有许多内置变量用来设置环境信息, 这些变量可以被改变, 下面给出了最常用的一些变量.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ARGC               命令行参数个数</span><br><span class="line">ARGV               命令行参数排列</span><br><span class="line">ENVIRON            支持队列中系统环境变量的使用</span><br><span class="line">FILENAME           awk浏览的文件名</span><br><span class="line">FNR                浏览文件的记录数</span><br><span class="line">FS                 设置输入域分隔符, 等价于命令行 -F选项</span><br><span class="line">NF                 浏览记录的域的个数</span><br><span class="line">NR                 已读的记录数</span><br><span class="line">OFS                输出域分隔符   默认空格</span><br><span class="line">ORS                输出记录分隔符 默认换行符</span><br><span class="line">RS                 控制记录分隔符 默认换行符</span><br><span class="line">此外,<span class="variable">$0</span>变量是指整条记录.<span class="variable">$1</span>表示当前行的第一个域,<span class="variable">$2</span>表示当前行的第二个域,......以此类推.</span><br></pre></td></tr></table></figure>

<p>统计&#x2F;etc&#x2F;passwd:文件名, 每行的行号, 每行的列数, 对应的完整行内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&#x27;</span> /etc/passwd</span><br><span class="line">filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bash</span><br><span class="line">filename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh</span><br></pre></td></tr></table></figure>

<p>使用printf替代print,可以让代码更加简洁, 易读</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk  -F <span class="string">&#x27;:&#x27;</span>  <span class="string">&#x27;&#123;printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h4 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a>print和printf</h4><p>awk中同时提供了print和printf两种打印输出的函数.</p>
<p>其中print函数的参数可以是变量, 数值或者字符串. 字符串必须用双引号引用, 参数用逗号分隔. 如果没有逗号, 参数就串联在一起而无法区分. 这里, 逗号的作用与输出文件的分隔符的作用是一样的, 只是后者是空格而已.<br>printf函数, 其用法和c语言中printf基本相似, 可以格式化字符串, 输出复杂时, printf更加好用, 代码更易懂.</p>
<h3 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h3><h4 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h4><p>除了awk的内置变量, awk还可以自定义变量.</p>
<p>下面统计&#x2F;etc&#x2F;passwd的账户人数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;, count&#125;&#x27;</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">......</span><br><span class="line">user count is  40</span><br></pre></td></tr></table></figure>

<p>count是自定义变量. 之前的action{}里都是只有一个print, 其实print只是一个语句, 而action{}可以有多个语句, 以;号隔开.<br>这里没有初始化count, 虽然默认是0, 但是妥当的做法还是初始化为0:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;count=0;print &quot;[start]user count is &quot;, count&#125; &#123;count=count+1;print $0;&#125; END&#123;print &quot;[end]user count is &quot;, count&#125;&#x27;</span> /etc/passwd</span><br><span class="line">[start]user count is  0</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">[end]user count is  40</span><br></pre></td></tr></table></figure>

<p>统计某个文件夹下的文件占用的字节数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l |awk <span class="string">&#x27;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size&#125;&#x27;</span></span><br><span class="line">[end]size is  8657198</span><br></pre></td></tr></table></figure>

<p>如果以M为单位显示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l |awk <span class="string">&#x27;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&#x27;</span></span><br><span class="line">[end]size is  8.25889 M</span><br></pre></td></tr></table></figure>

<p>注意, 统计不包括文件夹的子目录.</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>awk中的条件语句是从C语言中借鉴来的, 见如下声明方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">    statement;</span><br><span class="line">    statement;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (expression1)</span><br><span class="line">&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    statement3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l |awk <span class="string">&#x27;BEGIN &#123;size=0;print &quot;[start]size is &quot;, size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&#x27;</span></span><br><span class="line">[end]size is  8.22339 M</span><br></pre></td></tr></table></figure>

<p>统计下面的命令计算所有的C文件, CPP文件和H文件的文件大小总和.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l  *.cpp *.c *.h | awk <span class="string">&#x27;&#123;sum+=$5&#125; END &#123;print sum&#125;&#x27;</span></span><br><span class="line">2511401</span><br></pre></td></tr></table></figure>

<p>我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了, 大家都是程序员我就不解释了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;NR!=1&#123;a[$6]++;&#125; END &#123;for (i in a) print i &quot;, &quot; a[i];&#125;&#x27;</span> netstat.txt</span><br><span class="line">TIME_WAIT, 3</span><br><span class="line">FIN_WAIT1, 1</span><br><span class="line">ESTABLISHED, 6</span><br><span class="line">FIN_WAIT2, 3</span><br><span class="line">LAST_ACK, 1</span><br><span class="line">LISTEN, 4</span><br></pre></td></tr></table></figure>

<p>再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | awk <span class="string">&#x27;NR!=1&#123;a[$1]+=$6;&#125; END &#123; for(i in a) print i &quot;, &quot; a[i]&quot;KB&quot;;&#125;&#x27;</span></span><br><span class="line">dbus, 540KB</span><br><span class="line">mysql, 99928KB</span><br><span class="line">www, 3264924KB</span><br><span class="line">root, 63644KB</span><br><span class="line">hchen, 6020KB</span><br></pre></td></tr></table></figure>

<p>环境变量即然说到了脚本, 我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON, 使用ENVIRON的环境变量需要export）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; x=5</span><br><span class="line"></span><br><span class="line">&gt; y=10</span><br><span class="line">&gt; <span class="built_in">export</span> y</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$x</span> <span class="variable">$y</span></span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line">$ awk -v val=<span class="variable">$x</span> <span class="string">&#x27;&#123;print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]&#125;&#x27;</span> OFS=<span class="string">&quot;\t&quot;</span> score.txt</span><br><span class="line">Marry   2143    78      89      87</span><br><span class="line">Jack    2321    66      83      55</span><br><span class="line">Tom     2122    48      82      81</span><br><span class="line">Mike    2537    87      102     105</span><br><span class="line">Bob     2415    40      62      72</span><br></pre></td></tr></table></figure>

<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>awk中的循环语句同样借鉴于C语言, 支持while, do&#x2F;while, for, break, continue, 这些关键字的语义和C语言中的语义完全相同.</p>
<p>数组</p>
<p>  因为awk中数组的下标可以是数字和字母, 数组的下标通常被称为关键字(key). 值和关键字都存储在内部的一张针对key&#x2F;value应用hash的表格里.由于hash不是顺序存储, 因此在显示数组内容时会发现, 它们并不是按照你预料的顺序显示出来的. 数组和变量一样, 都是在使用时自动创建的, awk也同样会自动判断其存储的是数字还是字符串.一般而言, awk中的数组用来从记录中收集信息, 可以用于计算总和, 统计单词以及跟踪模板被匹配的次数等等.</p>
<p>显示&#x2F;etc&#x2F;passwd的账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里使用for循环遍历数组</span></span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;&#x27;</span> /etc/passwd</span><br><span class="line">0 root</span><br><span class="line">1 daemon</span><br><span class="line">2 bin</span><br><span class="line">3 sys</span><br><span class="line">4 <span class="built_in">sync</span></span><br><span class="line">5 games</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>awk</tag>
        <tag>通用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake怎么写?</title>
    <url>/2020/01/16/2020-01-16-cmake/</url>
    <content><![CDATA[<h3 id="cmake中一些预定义变量"><a href="#cmake中一些预定义变量" class="headerlink" title="cmake中一些预定义变量"></a>cmake中一些预定义变量</h3><ul>
<li>PROJECT_SOURCE_DIR 工程的根目录</li>
<li>PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}&#x2F;build</li>
<li>CMAKE_INCLUDE_PATH 环境变量,非cmake变量</li>
<li>CMAKE_LIBRARY_PATH 环境变量</li>
<li>CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径</li>
<li>CMAKE_CURRENT_BINARY_DIR target编译目录<br>使用ADD_SURDIRECTORY(src bin)可以更改此变量的值<br>SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对此变量有影响,只是改变了最终目标文件的存储路径</li>
<li>CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径</li>
<li>CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行</li>
<li>CMAKE_MODULE_PATH 定义自己的cmake模块所在的路径<br>SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}&#x2F;cmake),然后可以用INCLUDE命令来调用自己的模块</li>
<li>EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置</li>
<li>LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置</li>
<li>PROJECT_NAME 返回通过PROJECT指令定义的项目名称</li>
<li>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 用来控制IF ELSE语句的书写方式</li>
</ul>
<span id="more"></span>

<p>系统信息</p>
<ul>
<li>CMAKE_MAJOR_VERSION  cmake主版本号,如2.8.6中的2</li>
<li>CMAKE_MINOR_VERSION  cmake次版本号,如2.8.6中的8</li>
<li>CMAKE_PATCH_VERSION  cmake补丁等级,如2.8.6中的6</li>
<li>CMAKE_SYSTEM  系统名称,例如Linux-2.6.22</li>
<li>CAMKE_SYSTEM_NAME 不包含版本的系统名,如Linux</li>
<li>CMAKE_SYSTEM_VERSION 系统版本,如2.6.22</li>
<li>CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686</li>
<li>UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin</li>
<li>WIN32 在所有的win32平台为TRUE,包括cygwin<br>开关选项</li>
<li>BUILD_SHARED_LIBS 控制默认的库编译方式。如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库 （可在t3中稍加修改进行验证）</li>
<li>CMAKE_C_FLAGS 设置C编译选项</li>
<li>CMAKE_CXX_FLAGS 设置C++编译选项</li>
</ul>
<h3 id="cmake常用命令"><a href="#cmake常用命令" class="headerlink" title="cmake常用命令"></a>cmake常用命令</h3><h4 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h4><ul>
<li><p>cmake变量使用${}方式取值,但是在IF控制语句中是直接使用变量名</p>
</li>
<li><p>环境变量使用$ENV{}方式取值,使用SET(ENV{VAR} VALUE)赋值</p>
</li>
<li><p>指令(参数1 参数2…)<br>参数使用括弧括起,参数之间使用空格或分号分开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以ADD_EXECUTABLE指令为例：</span><br><span class="line">ADD_EXECUTABLE(hello main.c func.c)或者</span><br><span class="line">ADD_EXECUTABLE(hello main.c;func.c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>指令是大小写无关的,参数和变量是大小写相关的。推荐你全部使用大写指令。</p>
</li>
</ul>
<h4 id="部分常用命令列表"><a href="#部分常用命令列表" class="headerlink" title="部分常用命令列表"></a>部分常用命令列表</h4><ul>
<li><p>PROJECT<br>PROJECT(projectname [CXX] [C] [Java])<br>指定工程名称,并可指定工程支持的语言。支持语言列表可忽略,默认支持所有语言</p>
</li>
<li><p>SET<br>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br>定义变量(可以定义多个VALUE,如SET(SRC_LIST main.c util.c reactor.c))</p>
</li>
<li><p>MESSAGE<br>ESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …)<br>向终端输出用户定义的信息或变量的值<br>END_ERROR, 产生错误,生成过程被跳过<br>TATUS, 输出前缀为–的信息<br>ATAL_ERROR, 立即终止所有cmake过程</p>
</li>
<li><p>ADD_EXECUTABLE<br>ADD_EXECUTABLE(bin_file_name ${SRC_LIST})<br>生成可执行文件</p>
</li>
<li><p>ADD_LIBRARY<br>ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] SRC_LIST)<br>生成动态库或静态库<br>SHARED 动态库<br>STATIC 静态库<br>MODULE 在使用dyld的系统有效,若不支持dyld,等同于SHARED<br>EXCLUDE_FROM_ALL 表示该库不会被默认构建</p>
</li>
<li><p>SET_TARGET_PROPERTIES<br>设置输出的名称,设置动态库的版本和API版本</p>
</li>
<li><p>CMAKE_MINIMUM_REQUIRED<br>AKE_MINIMUM_REQUIRED(VERSION version_number [FATAL_ERROR])<br>明CMake的版本要求</p>
</li>
<li><p>ADD_SUBDIRECTORY<br>ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL])<br>向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制的存放位置<br>EXCLUDE_FROM_ALL含义：将这个目录从编译过程中排除</p>
</li>
<li><p>SUBDIRS<br>deprecated,不再推荐使用<br>(hello sample)相当于分别写ADD_SUBDIRECTORY(hello),ADD_SUBDIRECTORY(sample)</p>
</li>
<li><p>INCLUDE_DIRECTORIES<br>CLUDE_DIRECTORIES([AFTER | BEFORE] [SYSTEM] dir1 dir2 … )<br>工程添加多个特定的头文件搜索路径,路径之间用空格分隔,如果路径包含空格,可以使用双引号将它括起来,默认的行为为追加到当前头文件搜索路径后面。有如下两种方式可以控制搜索路径添加的位置：</p>
<ul>
<li>CMAKE_INCLUDE_DIRECTORIES_BEFORE,通过SET这个cmake变量为on,可以将添加的头文件搜索路径放在已有路径的前面</li>
<li>通过AFTER或BEFORE参数,也可以控制是追加还是置前</li>
</ul>
</li>
<li><p>LINK_DIRECTORIES<br>LINK_DIRECTORIES(dir1 dir2 …)<br>添加非标准的共享库搜索路径</p>
</li>
<li><p>TARGET_LINK_LIBRARIES<br>TARGET_LINK_LIBRARIES(target lib1 lib2 …)<br>为target添加需要链接的共享库</p>
</li>
<li><p>ADD_DEFINITIONS<br>向C&#x2F;C++编译器添加-D定义<br>ADD_DEFINITIONS(-DENABLE_DEBUG -DABC),参数之间用空格分隔</p>
</li>
<li><p>ADD_DEPENDENCIES<br>ADD_DEPENDENCIES(target-name depend-target1 depend-target2 …)<br>定义target依赖的其他target,确保target在构建之前,其依赖的target已经构建完毕</p>
</li>
<li><p>AUX_SOURCE_DIRECTORY<br>AUX_SOURCE_DIRECTORY(dir VAR)<br>发现一个目录下所有的源代码文件并将列表存储在一个变量中<br>把当前目录下的所有源码文件名赋给变量DIR_HELLO_SRCS</p>
</li>
<li><p>EXEC_PROGRAM<br><code>EXEC_PROGRAM(Executable [dir where to run] [ARGS &lt;args&gt;][OUTPUT_VARIABLE &lt;var&gt;] [RETURN_VALUE &lt;value&gt;])</code><br>用于在指定目录运行某个程序（默认为当前CMakeLists.txt所在目录）,通过ARGS添加参数,通过OUTPUT_VARIABLE和RETURN_VALUE获取输出和返回值,如下示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在src中运行ls命令,在src/CMakeLists.txt添加</span></span><br><span class="line">EXEC_PROGRAM(<span class="built_in">ls</span> ARGS <span class="string">&quot;*.c&quot;</span> OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)</span><br><span class="line">IF (not LS_RVALUE)</span><br><span class="line">    MESSAGE(STATUS <span class="string">&quot;ls result: &quot;</span> <span class="variable">$&#123;LS_OUTPUT&#125;</span>) <span class="comment"># 缩进仅为美观,语法无要求</span></span><br><span class="line">ENDIF(not LS_RVALUE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>INCLUDE<br>INCLUDE(file [OPTIONAL])  用来载入CMakeLists.txt文件<br>INCLUDE(module [OPTIONAL])用来载入预定义的cmake模块<br>OPTIONAL参数的左右是文件不存在也不会产生错误<br>可以载入一个文件,也可以载入预定义模块（模块会在CMAKE_MODULE_PATH指定的路径进行搜索）<br>载入的内容将在处理到INCLUDE语句时直接执行</p>
</li>
<li><p>FIND_</p>
<ul>
<li><p>FIND_FILE(<VAR> name path1 path2 …)<br>VAR变量代表找到的文件全路径,包含文件名</p>
</li>
<li><p>FIND_LIBRARY(<VAR> name path1 path2 …)<br>VAR变量代表找到的库全路径,包含库文件名</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FIND_LIBRARY(libX X11 /usr/lib)</span><br><span class="line">IF (NOT libx)</span><br><span class="line">    MESSAGE(FATAL_ERROR <span class="string">&quot;libX not found&quot;</span>)</span><br><span class="line">ENDIF(NOT libX)</span><br></pre></td></tr></table></figure>
</li>
<li><p>FIND_PATH(<VAR> name path1 path2 …)<br>VAR变量代表包含这个文件的路径</p>
</li>
<li><p>FIND_PROGRAM(<VAR> name path1 path2 …)<br>VAR变量代表包含这个程序的全路径</p>
</li>
<li><p>FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED | COMPONENTS] [componets …]])<br>用来调用预定义在CMAKE_MODULE_PATH下的Find<name>.cmake模块,你也可以自己定义Find<name>模块, 通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录供工程使用</p>
</li>
</ul>
</li>
<li><p>IF<br>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IF (expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line">ELSE (expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line">ENDIF (expression) <span class="comment"># 一定要有ENDIF与IF对应</span></span><br></pre></td></tr></table></figure>

<p>IF (expression), expression不为：空,0,N,NO,OFF,FALSE,NOTFOUND或<var>_NOTFOUND,为真<br>IF (not exp), 与上面相反<br>IF (var1 AND var2)<br>IF (var1 OR var2)<br>IF (COMMAND cmd) 如果cmd确实是命令并可调用,为真<br>IF (EXISTS dir) IF (EXISTS file) 如果目录或文件存在,为真<br>IF (file1 IS_NEWER_THAN file2),当file1比file2新,或file1&#x2F;file2中有一个不存在时为真,文件名需使用全路径<br>IF (IS_DIRECTORY dir) 当dir是目录时,为真<br>IF (DEFINED var) 如果变量被定义,为真<br>IF (var MATCHES regex) 此处var可以用var名,也可以用${var}<br>IF (string MATCHES regex)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当给定的变量或者字符串能够匹配正则表达式regex时为真。比如：</span><br><span class="line">IF (<span class="string">&quot;hello&quot;</span> MATCHES <span class="string">&quot;ell&quot;</span>)</span><br><span class="line">    MESSAGE(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ENDIF (<span class="string">&quot;hello&quot;</span> MATCHES <span class="string">&quot;ell&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>数字比较表达式</strong></p>
<p>IF (variable LESS number)<br>IF (string LESS number)<br>IF (variable GREATER number)<br>IF (string GREATER number)<br>IF (variable EQUAL number)<br>IF (string EQUAL number)</p>
<p><strong>按照字母表顺序进行比较</strong></p>
<p>IF (variable STRLESS string)<br>IF (string STRLESS string)<br>IF (variable STRGREATER string)<br>IF (string STRGREATER string)<br>IF (variable STREQUAL string)<br>IF (string STREQUAL string)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一个小例子,用来判断平台差异：</span><br><span class="line">IF (WIN32)</span><br><span class="line">    MESSAGE(STATUS “This is windows.”)</span><br><span class="line">ELSE (WIN32)</span><br><span class="line">    MESSAGE(STATUS “This is not windows”)</span><br><span class="line">ENDIF (WIN32)</span><br><span class="line">上述代码用来控制在不同的平台进行不同的控制,但是,阅读起来却并不是那么舒服,ELSE(WIN32)之类的语句很容易引起歧义。</span><br><span class="line">可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)</span><br><span class="line">这时候就可以写成:</span><br><span class="line">IF (WIN32)</span><br><span class="line">ELSE ()</span><br><span class="line">ENDIF ()</span><br><span class="line">配合ELSEIF使用,可能的写法是这样:</span><br><span class="line">IF (WIN32)</span><br><span class="line">    <span class="comment">#do something related to WIN32</span></span><br><span class="line">ELSEIF (UNIX)</span><br><span class="line">    <span class="comment">#do something related to UNIX</span></span><br><span class="line">ELSEIF(APPLE)</span><br><span class="line">    <span class="comment">#do something related to APPLE</span></span><br><span class="line">ENDIF (WIN32)</span><br></pre></td></tr></table></figure>
</li>
<li><p>WHILE<br>语法：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WHILE(condition)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line">ENDWHILE(condition)</span><br></pre></td></tr></table></figure>

<p>其真假判断条件可以参考IF指令</p>
<ul>
<li>FOREACH<br>FOREACH指令的使用方法有三种形式：<ul>
<li><p>列表<br>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FOREACH(loop_var arg1 arg2 ...)</span><br><span class="line">      COMMAND1(ARGS ...)</span><br><span class="line">      COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line">ENDFOREACH(loop_var)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AUX_SOURCE_DIRECTORY(. SRC_LIST)</span><br><span class="line">FOREACH(F <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line">      MESSAGE(<span class="variable">$&#123;F&#125;</span>)</span><br><span class="line">ENDFOREACH(F)</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围<br>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FOREACH(loop_var RANGE total)</span><br><span class="line">       COMMAND1(ARGS ...)</span><br><span class="line">       COMMAND2(ARGS ...)</span><br><span class="line">       ...</span><br><span class="line">ENDFOREACH(loop_var)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">从0到total以１为步进</span><br><span class="line">FOREACH(VAR RANGE 10)</span><br><span class="line">      MESSAGE(<span class="variable">$&#123;VAR&#125;</span>)</span><br><span class="line">ENDFOREACH(VAR)</span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li>
<li><p>范围和步进<br>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FOREACH(loop_var RANGE start stop [step])</span><br><span class="line">       COMMAND1(ARGS ...)</span><br><span class="line">       COMMAND2(ARGS ...)</span><br><span class="line">       ...</span><br><span class="line">ENDFOREACH(loop_var)</span><br></pre></td></tr></table></figure>

<p>从start开始到stop结束,以step为步进,<br>注意：直到遇到ENDFOREACH指令,整个语句块才会得到真正的执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FOREACH(A RANGE 5 15 3)</span><br><span class="line">       MESSAGE(<span class="variable">$&#123;A&#125;</span>)</span><br><span class="line">ENDFOREACH(A)</span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">11</span><br><span class="line">14</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="cmake中如何生成动态库和静态库"><a href="#cmake中如何生成动态库和静态库" class="headerlink" title="cmake中如何生成动态库和静态库"></a>cmake中如何生成动态库和静态库</h3><p>参考ADD_LIBRARY和SET_TARGET_PROPERTIES用法<br>t3示例</p>
<h3 id="cmake中如何使用动态库和静态库（查找库的路径）"><a href="#cmake中如何使用动态库和静态库（查找库的路径）" class="headerlink" title="cmake中如何使用动态库和静态库（查找库的路径）"></a>cmake中如何使用动态库和静态库（查找库的路径）</h3><p>参考INCLUDE_DIRECTORIES, LINK_DIRECTORIES, TARGET_LINK_LIBRARIES用法<br>t4示例使用动态库或静态库<br>t5示例如何使用cmake预定义的cmake模块(以FindCURL.cmake为例演示)<br>t6示例如何使用自定义的cmake模块(编写了自定义的FindHELLO.cmake)<br>注意读t5和t6的CMakeLists.txt和FindHELLO.cmake中的注释部分</p>
<h3 id="cmake中如何指定生成文件的输出路径"><a href="#cmake中如何指定生成文件的输出路径" class="headerlink" title="cmake中如何指定生成文件的输出路径"></a>cmake中如何指定生成文件的输出路径</h3><ul>
<li><p>如上ADD_SUBDIRECTORY的时候指定目标二进制文件输出路径（推荐使用下面这种）</p>
</li>
<li><p>使用SET命令重新定义EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量来指定最终的二进制文件的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line">SET(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>

<p>上面的两条命令通常紧跟ADD_EXECUTABLE和ADD_LIBRARY,与其写在同一个CMakeLists.txt即可</p>
</li>
</ul>
<h3 id="cmake中如何增加编译选项"><a href="#cmake中如何增加编译选项" class="headerlink" title="cmake中如何增加编译选项"></a>cmake中如何增加编译选项</h3><p>使用变量CMAKE_C_FLAGS添加C编译选项<br>使用变量CMAKE_CXX_FLAGS添加C++编译选项<br>使用ADD_DEFINITION添加</p>
<h3 id="cmake中如何增加头文件路径"><a href="#cmake中如何增加头文件路径" class="headerlink" title="cmake中如何增加头文件路径"></a>cmake中如何增加头文件路径</h3><p>参考INCLUDE_DIRECTORIES命令用法</p>
<h3 id="cmake中如何在屏幕上打印信息"><a href="#cmake中如何在屏幕上打印信息" class="headerlink" title="cmake中如何在屏幕上打印信息"></a>cmake中如何在屏幕上打印信息</h3><p>参考MESSAGE用法</p>
<h3 id="cmake中如何给变量赋值"><a href="#cmake中如何给变量赋值" class="headerlink" title="cmake中如何给变量赋值"></a>cmake中如何给变量赋值</h3><p>参考SET和AUX_SOURCE_DIRECTORY用法<br>建议：在Project根目录先建立build,然后在build文件夹内运行cmake ..，这样就不会污染源代码, 如果不想要这些自动生成的文件了，只要简单的删除build文件夹就可以</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>find命令使用技巧</title>
    <url>/2020/01/16/2020-01-16-find/</url>
    <content><![CDATA[<p><code>find &lt; path &gt; &lt; expression &gt; &lt; cmd &gt;</code></p>
<ul>
<li>path： 所要搜索的目录及其所有子目录。默认为当前目录。</li>
<li>expression： 所要搜索的文件的特征。</li>
<li>cmd： 对搜索结果进行特定的处理。</li>
</ul>
<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>
<h4 id="find命令常用选项及实例"><a href="#find命令常用选项及实例" class="headerlink" title="find命令常用选项及实例"></a>find命令常用选项及实例</h4><ul>
<li><p>-name 按照文件名查找文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /dir -name filename  在/dir目录及其子目录下面查找名字为filename的文件</span><br><span class="line">find . -name <span class="string">&quot;*.c&quot;</span> 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<ul>
<li><p>-perm 按照文件权限来查找文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -perm 755 –<span class="built_in">print</span> 在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>-prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /apps -path <span class="string">&quot;/apps/bin&quot;</span> -prune -o –<span class="built_in">print</span> 在/apps目录下查找文件，但不希望在/apps/bin目录下查找</span><br><span class="line">find /usr/sam -path <span class="string">&quot;/usr/sam/dir1&quot;</span> -prune -o –<span class="built_in">print</span> 在/usr/sam目录下查找不在dir1子目录之内的所有文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">&quot;CON.FILE&quot;</span> -depth –<span class="built_in">print</span> 它将首先匹配所有的文件然后再进入子目录中查找</span><br></pre></td></tr></table></figure>
</li>
<li><p>-user 按照文件属主来查找文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ~ -user sam –<span class="built_in">print</span> 在<span class="variable">$HOME</span>目录中查找文件属主为sam的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>-group 按照文件所属的组来查找文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /apps -group gem –<span class="built_in">print</span> 在/apps目录下查找属于gem用户组的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>-mtime -n +n 按照文件的更改时间来查找文件， -n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -mtime -5 –<span class="built_in">print</span> 在系统根目录下查找更改时间在5日以内的文件</span><br><span class="line">find /var/adm -mtime +3 –<span class="built_in">print</span> 在/var/adm目录下查找更改时间在3日以前的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>-nogroup 查找无有效所属组的文件，即该文件所属的组在&#x2F;etc&#x2F;groups中不存在。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / –nogroup -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-nouser 查找无有效属主的文件，即该文件的属主在&#x2F;etc&#x2F;passwd中不存在。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /home -nouser –<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。</p>
</li>
<li><p>-type 查找某一类型的文件，<br>诸如：<br>b - 块设备文件。<br>d - 目录。<br>c - 字符设备文件。<br>p - 管道文件。<br>l - 符号链接文件。<br>f - 普通文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /etc -<span class="built_in">type</span> d –<span class="built_in">print</span> 在/etc目录下查找所有的目录</span><br><span class="line">find . ! -<span class="built_in">type</span> d –<span class="built_in">print</span> 在当前目录下查找除目录以外的所有类型的文件</span><br><span class="line">find /etc -<span class="built_in">type</span> l –<span class="built_in">print</span> 在/etc目录下查找所有的符号链接文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>-size n[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -size +1000000c –<span class="built_in">print</span> 在当前目录下查找文件长度大于1 M字节的文件</span><br><span class="line">find /home/apache -size 100c –<span class="built_in">print</span> 在/home/apache目录下查找文件长度恰好为100字节的文件</span><br><span class="line">find . -size +10 –<span class="built_in">print</span> 在当前目录下查找长度超过10块的文件（一块等于512字节）</span><br></pre></td></tr></table></figure>
</li>
<li><p>-mount：在查找文件时不跨越文件系统mount点。<br><code>find . -name “*.XC” -mount –print 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件（不进入其他文件系统）</code></p>
</li>
<li><p>-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件</p>
</li>
<li><p>-exec，find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和;之间的空格</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; find ./ -size 0 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \; 删除文件大小为零的文件</span><br><span class="line">&gt; <span class="built_in">rm</span> -i `find ./ -size 0`</span><br><span class="line">&gt; find ./ -size 0 | xargs <span class="built_in">rm</span> -f &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中：<br><code>$ find . -type f -exec ls -l &#123;&#125; \;</code><br>在&#x2F;logs目录中查找更改时间在5日以前的文件并删除它们：<br><code>find /logs -type f -mtime +5 -exec rm &#123;&#125; \;</code></p>
<ul>
<li><p>-ok，和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.conf&quot;</span>  -mtime +5 -ok <span class="built_in">rm</span> &#123;  &#125; \; 在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不  过在删除之前先给出提示</span><br></pre></td></tr></table></figure></li>
</ul>
<p>说明： 如果你要寻找一个档案的话，那么使用 find 会是一个不错的主意。不过，由于 find 在寻找数据的时候相当的耗硬盘，所以没事情不要使用 find 啦！有更棒的指令可以取代呦，那就是 whereis 与 locate 咯~</p>
<h4 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;</span><br><span class="line">查找当前路径下的所有普通文件，并把它们列出来。</span><br><span class="line">2. find logs -<span class="built_in">type</span> f -mtime +5 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line">删除logs目录下更新时间为5日以上的文件。</span><br><span class="line">3.find . -name <span class="string">&quot;*.log&quot;</span> -mtime +5 -ok <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line">删除当前路径下以。<span class="built_in">log</span>结尾的五日以上的文件，删除之前要确认。</span><br><span class="line">4. find ~ -<span class="built_in">type</span> f -perm 4755 -<span class="built_in">print</span></span><br><span class="line">查找<span class="variable">$HOME</span>目录下suid位被设置，文件属性为755的文件打印出来。</span><br><span class="line">说明： find在有点系统中会一次性得到将匹配到的文件都传给<span class="built_in">exec</span>，但是有的系统对<span class="built_in">exec</span>的命令长度做限制，就会报：”参数列太长“，这就需要使用xargs。xargs是部分取传来的文件。</span><br><span class="line">5. find / -<span class="built_in">type</span> f -<span class="built_in">print</span> |xargs file</span><br><span class="line">xargs测试文件分类</span><br><span class="line">6. find . -name <span class="string">&quot;core*&quot;</span> -<span class="built_in">print</span>|xargs <span class="built_in">echo</span> <span class="string">&quot; &quot;</span>&gt;/tmp/core.log</span><br><span class="line">将core文件信息查询结果报存到core。<span class="built_in">log</span>日志。</span><br><span class="line">7. find / -<span class="built_in">type</span> f -<span class="built_in">print</span> | xargs <span class="built_in">chmod</span> o -w</span><br><span class="line">8. find . -name * -<span class="built_in">print</span> |xargs grep <span class="string">&quot;DBO&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>通用技巧</tag>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>grep命令使用技巧</title>
    <url>/2020/01/16/2020-01-16-grep/</url>
    <content><![CDATA[<p>grep [选项] pattern [文件名]</p>
<p>命令中的选项为：</p>
<ul>
<li>-? 同时显示匹配行上下的？行，如：<code>grep -2 pattern filename</code> 同时显示匹配行的上下2行。</li>
<li>-A ? 显示匹配行和后面的?行, 如: <code>grep -A 2 pattern filename</code></li>
<li>-B ? 显示匹配行和前面的?行</li>
<li>-b，–byte-offset 打印匹配行前面打印该行所在的块号码。</li>
<li>-c,–count 只打印匹配的行数，不显示匹配的内容。</li>
<li>-f File，–file&#x3D;File 从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</li>
<li>-h，–no-filename 当搜索多个文件时，不显示匹配文件名前缀。</li>
<li>-i，–ignore-case 忽略大小写差别。</li>
<li>-q，–quiet 取消显示，只返回退出状态。0则表示找到了匹配的行。</li>
<li>-l，–files-with-matches 打印匹配模板的文件清单。</li>
<li>-L，–files-without-match 打印不匹配模板的文件清单。</li>
<li>-n，–line-number 在匹配的行前面打印行号。</li>
<li>-s，–silent 不显示关于不存在或者无法读取文件的错误信息。</li>
<li>-v，–revert-match 反检索，只显示不匹配的行。</li>
<li>-w，–word-regexp 如果被&lt;和&gt;引用，就把表达式做为一个单词搜索。</li>
<li>-V，–version 显示软件版本信息。</li>
</ul>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l | grep <span class="string">&#x27;^a&#x27;</span> 通过管道过滤<span class="built_in">ls</span> -l输出的内容，只显示以a开头的行。</span><br><span class="line">grep <span class="string">&#x27;test&#x27;</span> d* 显示所有以d开头的文件中包含<span class="built_in">test</span>的行。</span><br><span class="line">grep <span class="string">&#x27;test&#x27;</span> aa bb cc 显示在aa，bb，cc文件中匹配<span class="built_in">test</span>的行。</span><br><span class="line">grep <span class="string">&#x27;[a-z]&#x27;</span> aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span><br><span class="line">grep <span class="string">&#x27;w(es)t.*&#x27;</span> aa 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着另外一个es()，找到就显示该行。如果用egrep或grep -E，就不用<span class="string">&quot;&quot;</span>号进行转义，直接写成<span class="string">&#x27;w(es)t.*&#x27;</span>就可以了。</span><br><span class="line">grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写</span><br><span class="line">grep -l pattern files ：只列出匹配的文件名，</span><br><span class="line">grep -L pattern files ：列出不匹配的文件名，</span><br><span class="line">grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配‘magic’，而不是‘magical’)，</span><br><span class="line">grep -C number pattern files ：匹配的上下文分别显示[number]行，</span><br><span class="line">grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，</span><br><span class="line">grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。</span><br></pre></td></tr></table></figure>

<p>pattern为所要匹配的字符串，可使用下列模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. 匹配任意一个字符</span><br><span class="line">* 匹配0 个或多个*前的字符</span><br><span class="line">^ 匹配行开头</span><br><span class="line">$ 匹配行结尾</span><br><span class="line">[] 匹配[ ]中的任意一个字符，[]中可用 - 表示范围，</span><br><span class="line">例如[a-z]表示字母a 至z 中的任意一个</span><br><span class="line">\ 转意字符</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>通用技巧</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本必知必会</title>
    <url>/2020/01/16/2020-01-16-shell/</url>
    <content><![CDATA[<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>首字符必须为字母</li>
<li>中间不能有空格, 可以有下划线_</li>
<li>不能使用标点符号</li>
<li>不能使用bash里的关键字</li>
</ol>
<h4 id="代码风格建议"><a href="#代码风格建议" class="headerlink" title="代码风格建议"></a>代码风格建议</h4><ul>
<li>全部用大写</li>
<li>下划线分隔</li>
<li>定义在文件的顶部</li>
</ul>
<span id="more"></span>

<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>变量名&#x3D;值,  （注意, &#x3D; 两边不能有空格）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=1</span><br><span class="line">var=<span class="variable">$var</span>+1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span>+1</span><br><span class="line"><span class="comment"># 输出为1+1, 而不是2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用如下方法使其输出为2</span></span><br><span class="line"><span class="built_in">let</span> <span class="string">&quot;var+=1&quot;</span></span><br><span class="line"><span class="comment">#var=$[$var+1]</span></span><br><span class="line"><span class="comment">#var=$(($var+1))</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">或者</span><br><span class="line">var=1</span><br><span class="line">var= <span class="built_in">expr</span> <span class="variable">$var</span> + 1 <span class="comment">#（注意, + 两边的空格, 一定要有）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span>表示数学运算, <span class="built_in">expr</span>用于整数值运算, 每一项用空格隔开, $[]将中括号内的表达式作为数学运算先计算结果再输出.</span><br><span class="line">在bash中, 将数学运算结果赋给某个变量,  var=$[ operation ]</span><br><span class="line"></span><br><span class="line">变量自增, 自减</span><br><span class="line"><span class="built_in">let</span> var++  <span class="built_in">let</span> var--</span><br><span class="line"><span class="built_in">let</span> var+=2</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;10.2-2&quot;</span> | bc   -- 小数运算要用bc  $[]不支持小数</span><br></pre></td></tr></table></figure>

<h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><p>$var ${var}<br>双引号“ “ 中可以用$var<br>单引号‘ ‘ 中不可以用$var</p>
<p>$(cmd) 与 `cmd` 等效, 推荐用前者</p>
<ul>
<li>支持内嵌</li>
<li>不用转义</li>
<li>有些字体, 反引号和单引号很像, 让人看着很难受</li>
</ul>
<h4 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- <span class="variable">$RANDOM</span>  随机数</span><br><span class="line">- 字段分隔符, IFS=$<span class="string">&#x27;n&#x27;</span></span><br><span class="line">- <span class="variable">$0</span> 程序名, <span class="variable">$1</span> … <span class="variable">$9</span> 是命令行参数, 多于9个命令行参数的话, 后面的需要<span class="variable">$&#123;10&#125;</span> <span class="variable">$&#123;11&#125;</span>这种格式</span><br><span class="line">- <span class="variable">$#</span> 表示传入的命令行参数的个数. 在&#123;&#125;中使用<span class="variable">$#</span>时, 要改用<span class="variable">$&#123;!#&#125;</span>.</span><br><span class="line">- $* 所有命令行参数当成一个单词存储</span><br><span class="line">- <span class="variable">$@</span> 所有命令行参数当成一个字符串中的多个单词</span><br><span class="line">- $$ 脚本的PID</span><br></pre></td></tr></table></figure>

<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><h4 id="文件比较运算符"><a href="#文件比较运算符" class="headerlink" title="文件比较运算符"></a>文件比较运算符</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-e filename                如果 filename 存在, 则为真               [ -e /var/log/syslog ]</span><br><span class="line">-d filename                如果 filename 为目录, 则为真             [ -d /tmp/mydir ]</span><br><span class="line">-f filename                如果 filename 为常规文件, 则为真          [ -f /usr/bin/grep ]</span><br><span class="line">-L filename                如果 filename 为符号链接, 则为真          [ -L /usr/bin/grep ]</span><br><span class="line">-r filename                如果 filename 可读, 则为真               [ -r /var/log/syslog ]</span><br><span class="line">-w filename                如果 filename 可写, 则为真               [ -w /var/mytmp.txt ]</span><br><span class="line">-x filename                如果 filename 可执行, 则为真             [ -L /usr/bin/grep ]</span><br><span class="line">! -e filename              如果 filename 不存在, 则为真               [ ! -e /var/log/syslog ]</span><br><span class="line">filename1 -nt filename2    如果 filename1 比 filename2 新, 则为真   [ /tmp/install/etc/services -nt /etc/services ]</span><br><span class="line">filename1 -ot filename2    如果 filename1 比 filename2 旧, 则为真   [ /boot/bzImage -ot <span class="built_in">arch</span>/i386/boot/bzImage ]</span><br></pre></td></tr></table></figure>

<h4 id="字符串比较运算符-（请注意引号的使用-这是防止空格扰乱代码的好方法）"><a href="#字符串比较运算符-（请注意引号的使用-这是防止空格扰乱代码的好方法）" class="headerlink" title="字符串比较运算符 （请注意引号的使用, 这是防止空格扰乱代码的好方法）"></a>字符串比较运算符 （请注意引号的使用, 这是防止空格扰乱代码的好方法）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z string               如果 string 长度为零, 则为真            [ -z <span class="string">&quot;<span class="variable">$myvar</span>&quot;</span> ]</span><br><span class="line">-n string               如果 string 长度非零, 则为真            [ -n <span class="string">&quot;<span class="variable">$myvar</span>&quot;</span> ]</span><br><span class="line">string1 = string2       如果 string1 与 string2 相同, 则为真    [ <span class="string">&quot;<span class="variable">$myvar</span>&quot;</span> = <span class="string">&quot;one two three&quot;</span> ]</span><br><span class="line">string1 != string2      如果 string1 与 string2 不同, 则为真    [ <span class="string">&quot;<span class="variable">$myvar</span>&quot;</span> != <span class="string">&quot;one two three&quot;</span> ]</span><br></pre></td></tr></table></figure>

<h4 id="算术比较运算符"><a href="#算术比较运算符" class="headerlink" title="算术比较运算符"></a>算术比较运算符</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num1 -eq num2       等于            [ 3 -eq <span class="variable">$mynum</span> ]</span><br><span class="line">num1 -ne num2       不等于          [ 3 -ne <span class="variable">$mynum</span> ]</span><br><span class="line">num1 -lt num2       小于            [ 3 -lt <span class="variable">$mynum</span> ]</span><br><span class="line">num1 -le num2       小于或等于      [ 3 -le <span class="variable">$mynum</span> ]</span><br><span class="line">num1 -gt num2       大于            [ 3 -gt <span class="variable">$mynum</span> ]</span><br><span class="line">num1 -ge num2       大于或等于      [ 3 -ge <span class="variable">$mynum</span> ]</span><br></pre></td></tr></table></figure>

<h3 id="结构语句"><a href="#结构语句" class="headerlink" title="结构语句"></a>结构语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> command1 &amp;&amp; command2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>; <span class="keyword">then</span>  <span class="comment">#如果then与if在同一行, if command后要加&#x27;;&#x27;</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> command1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">elif</span> command2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> condition</span><br><span class="line"><span class="keyword">if</span> [ condition ] 注意[]与condition之间的空格, &gt; &lt; 需要转义</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> ((expression)) &gt; &lt; 不需要转义</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐用 [[ ]] 的形式</span></span><br><span class="line"><span class="comment"># 1. 避免转义问题</span></span><br><span class="line"><span class="comment"># 2. 有新功能, 包括但不限于以下</span></span><br><span class="line"><span class="comment">#    - ||: 逻辑or</span></span><br><span class="line"><span class="comment">#    - &amp;&amp;: 逻辑and</span></span><br><span class="line"><span class="comment">#    - &lt;: 字符串比较(不需要转义)</span></span><br><span class="line"><span class="comment">#    - ==: 通配符字符串比较</span></span><br><span class="line"><span class="comment">#    - =~: 正则表达式字符串比较</span></span><br><span class="line"><span class="keyword">if</span> [[ condition ]]  可以用正则表达式</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">t=<span class="string">&quot;abc123&quot;</span></span><br><span class="line"></span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$t</span>&quot;</span> == abc* ]]         <span class="comment">#true</span></span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$t</span>&quot;</span> == <span class="string">&quot;abc*&quot;</span> ]]       <span class="comment"># false</span></span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$t</span>&quot;</span> =~ [abc]+[123]+ ]] <span class="comment"># true</span></span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$t</span>&quot;</span> =~ <span class="string">&quot;abc*&quot;</span> ]]       <span class="comment"># false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">pattern1 | pattern2)</span><br><span class="line">    commands1</span><br><span class="line">    ;;</span><br><span class="line">pattern3)</span><br><span class="line">    commands2::</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    default commands</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">     commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">test</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">     other commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> <span class="built_in">test</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">     other commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span> n (default 1) 跳出n层循环</span><br><span class="line"><span class="built_in">continue</span> n (default 1) 继续n级循环</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> var <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>可以带function fun()  定义, 也可以直接fun() 定义, 不带任何参数.</li>
<li>参数返回, 可以显式return返回, return后跟数值n(0-255)；如果不加, 将以最后一条命令运行结果, 作为返回值.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将所有的错误信息导向STDERR</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">err</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[<span class="subst">$(date +&#x27;%Y-%m-%dT%H:%M:%S%z&#x27;)</span>]: <span class="variable">$@</span>&quot;</span> &gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! do_something; <span class="keyword">then</span></span><br><span class="line">    err <span class="string">&quot;Unable to do_something&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="string">&quot;<span class="variable">$&#123;E_DID_NOTHING&#125;</span>”</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>必须在调用函数地方之前, 声明函数, shell脚本是逐行运行. 不会像其它语言一样先预编译. 一次必须在使用函数前先声明函数.</li>
<li>total&#x3D;$(func 3 2);  </li>
<li>函数返回值, 只能通过$? 系统变量获得, 直接通过&#x3D;获得是空值</li>
<li>如果需要传出其它类型函数值, 可以在函数调用之前, 定义变量（这个就是全局变量）. 在函数内部就可以直接修改, 然后在执行函数就可以读出修改过的值</li>
<li>如果需要定义自己变量, 可以在函数中定义, local 变量&#x3D;值, 这时变量就是内部变量, 它的修改, 不会影响函数外部相同变量的值.</li>
</ol>
<h3 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在默认情况下，遇到不存在的变量，会忽略并继续执行，而这往往不符合预期，加入该选项，可以避免恶果扩大，终止脚本的执行。</span></span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在默认情况下，遇到执行出错，会跳过并继续执行，而这往往不符合预期，加入该选项，可以避免恶果扩大，终止脚本的执行</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> prefix=<span class="string">&quot;[<span class="subst">$(date +%Y/%m/%d\ %H:%M:%S)</span>]:&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$_DEBUG</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;prefix&#125;</span> <span class="variable">$@</span>&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span> <span class="string">&quot;INFO&quot;</span> <span class="string">&quot;a message&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>通用技巧</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>xargs命令使用技巧</title>
    <url>/2020/01/16/2020-01-16-xargs/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>管道符 | + xargs, 用于把上游输出转换为下游参数输入。</p>
<p>例如 <code>ls *.bak | xargs rm -f</code></p>
<p>问题：<br>xargs默认把输入作为参数放到命令的最后，但是很多命令需要自己定位参数的位置，比如拷贝命令cp {上游结果} destFolder<br>解决方法：<br>xargs -I &lt;参数指示符&gt;， 然后用这个参数指示符定位参数插入的位置, </p>
<p><code>ls *.bak | xargs -I % cp % /tmp/test</code></p>
<p>注释：这里使用%作为指示符，第一个%可以理解为声明，第二个%可以理解为调用。你也可以用其他字符，比如 <code>ls *.bak | xargs -I &#123;&#125; cp &#123;&#125; /tmp/test</code></p>
<span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>之所以要用到xargs这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中又有这个需要，所以就有了xargs命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /sbin -perm +700 | <span class="built_in">ls</span> -l       这个命令是错误的</span><br><span class="line">find /sbin -perm +700 | xargs <span class="built_in">ls</span> -l   这样才是正确的</span><br></pre></td></tr></table></figure>

<p>xargs 可以读入 stdin 的资料，并且以空白字符或断行字符作为分隔，将 stdin 的资料分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了～</p>
<h4 id="选项解释"><a href="#选项解释" class="headerlink" title="选项解释"></a>选项解释</h4><ul>
<li><p>-0 当sdtin含有特殊字符时候，将其当成一般字符，像&#x2F; ‘ 空格等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">echo</span> <span class="string">&quot;//&quot;</span>|xargs  <span class="built_in">echo</span></span><br><span class="line">root@localhost:~/test#<span class="built_in">echo</span> <span class="string">&quot;//&quot;</span>|xargs -0 <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-a file 从文件中读入作为sdtin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world/n&quot;</span></span><br><span class="line">root@localhost:~/test#xargs -a <span class="built_in">test</span> <span class="built_in">echo</span></span><br><span class="line"><span class="comment">#!/bin/sh echo hello world/n</span></span><br><span class="line">root@localhost:~/test#</span><br></pre></td></tr></table></figure>
</li>
<li><p>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt</span><br><span class="line">/bin tao shou kun</span><br><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt|xargs -E <span class="string">&#x27;shou&#x27;</span> <span class="built_in">echo</span></span><br><span class="line">/bin tao</span><br></pre></td></tr></table></figure>
</li>
<li><p>-p 当每次执行一个argument的时候询问一次用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt|xargs -p <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> /bin tao shou kun ff ?...y</span><br><span class="line">/bin tao shou kun ff</span><br></pre></td></tr></table></figure>
</li>
<li><p>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt|xargs -n 1 <span class="built_in">echo</span></span><br><span class="line">/bin</span><br><span class="line">tao</span><br><span class="line">shou</span><br><span class="line">kun</span><br><span class="line">root@localhost:~/test3#<span class="built_in">cat</span> txt|xargs  <span class="built_in">echo</span></span><br><span class="line">/bin tao shou kun</span><br></pre></td></tr></table></figure>
</li>
<li><p>-t 表示先打印命令，然后再执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt|xargs -t <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> /bin tao shou kun</span><br><span class="line">/bin tao shou kun</span><br></pre></td></tr></table></figure>
</li>
<li><p>-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">ls</span> | xargs -t -i <span class="built_in">mv</span> &#123;&#125; &#123;&#125;.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">echo</span> <span class="string">&quot;&quot;</span>|xargs -t -r  <span class="built_in">mv</span></span><br><span class="line">root@localhost:~/test#</span><br></pre></td></tr></table></figure>
</li>
<li><p>-s num 命令行的最大字符数，指的是xargs后面那个命令的最大命令行字符数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> <span class="built_in">test</span> |xargs -i -x  -s 14 <span class="built_in">echo</span> <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">exp1</span><br><span class="line">exp5</span><br><span class="line">file</span><br><span class="line">xargs: argument line too long</span><br><span class="line">linux-2</span><br><span class="line">root@localhost:~/test#</span><br></pre></td></tr></table></figure>
</li>
<li><p>-L num Use at most max-lines nonblank input lines per command line.-s是含有空格的。</p>
</li>
<li><p>-l  同-L</p>
</li>
<li><p>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt |xargs -i -p <span class="built_in">echo</span> &#123;&#125;</span><br><span class="line"><span class="built_in">echo</span> /bin tao shou kun ?...y</span><br><span class="line">root@localhost:~/test#<span class="built_in">cat</span> txt |xargs -i -p -d <span class="string">&quot; &quot;</span> <span class="built_in">echo</span> &#123;&#125;</span><br><span class="line"><span class="built_in">echo</span> /bin ?...y</span><br><span class="line"><span class="built_in">echo</span> tao ?.../bin</span><br><span class="line">y</span><br><span class="line"><span class="built_in">echo</span> shou ?...tao</span><br><span class="line">再如：</span><br><span class="line">root@localhost:~/test#<span class="built_in">cat</span> <span class="built_in">test</span> |xargs -i -p -d <span class="string">&quot; &quot;</span> <span class="built_in">echo</span> &#123;&#125;</span><br><span class="line"><span class="built_in">echo</span> exp1</span><br><span class="line">exp5</span><br><span class="line">file</span><br><span class="line">linux-2</span><br><span class="line">ngis_post</span><br><span class="line">tao</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">txt</span><br><span class="line">xen-3</span><br><span class="line">?...y</span><br><span class="line">root@localhost:~/test#<span class="built_in">cat</span> <span class="built_in">test</span> |xargs -i -p <span class="built_in">echo</span> &#123;&#125;</span><br><span class="line"><span class="built_in">echo</span> exp1 ?...y</span><br><span class="line"><span class="built_in">echo</span> exp5 ?...exp1</span><br><span class="line">y</span><br><span class="line"><span class="built_in">echo</span> file ?...exp5</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
</li>
<li><p>-x exit的意思，主要是配合-s使用。</p>
</li>
<li><p>-P 修改最大的进程数，默认是1，为0时候为as many as it can</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>通用技巧</tag>
        <tag>xargs</tag>
      </tags>
  </entry>
  <entry>
    <title>理想的开发框架</title>
    <url>/2020/01/27/2020-01-27-best-dev-framework/</url>
    <content><![CDATA[<p>以下内容, 由富途CTO ppchen总结</p>
<ol>
<li>【同步编码异步执行】兼顾运行效率和编码效率，希望代码写起来是同步和顺序的，而执行的时候是异步的</li>
<li>【IDL&#x2F;RPC】支持IDL（接口描述语言）和RPC，减少网络协议相关的重复工作，协议有比较好的扩展性；远程调用友好且高效。要开发语言无关，因为你用c开发，不表示其他团队也用c调用你的接口，所以IDL要能生成常见语言的RPC。</li>
</ol>
<span id="more"></span>

<ol start="3">
<li>【LB】对服务间的调用选路进行统一的管理，对单机故障和网络波动等常见情况有自动容错，我们就简称load balance(LB)吧</li>
<li>存储组件化服务化，这个其实和开发框架关系不太紧密，这里提一下，强调存储应该有统一的组件且由专业的团队运维，就像公有云一样</li>
<li>【过载保护】框架必须有成熟自带的过载保护机制，不需要业务开发人员关注或者关注很少</li>
<li>【基础的监控和告警】RPC调用、机器的cpu&#x2F;网络活动、任务并发度、时延、进程监控和秒起等基础信息，要有上报、统计和告警，不需要业务开发人员关注。在团队分工上，应该有专门的团队对框架进行运维，关注基础的监控和告警，业务开发人员将业务逻辑以.so等动态库形式提交到框架云端，业务开发人员关注业务逻辑告警</li>
<li>【完整的业务流转呈现】统一日志，在一个地方能够清晰的呈现某次业务处理过程的流转详细情况：经过了哪些模块间调用，调用参数是怎样的，每个模块处理的重要分支和结果是怎样的，最好图形化呈现。支持染色和不同的日志详细级别</li>
<li>【中央总控】整个系统的配置和文档，例如每个模块有哪些机器，分布在哪些机房、容量冗余情况、模块间调用关系、访问控制的配置动态管理甚至电子流，都希望能统一在一个地方web化的管理起来，并且与运营的系统是直接联系直接生效的，即避免文档记录是怎样怎样，而运营的系统实际情况是不一样。随便点开一个模块，就知道它的设备列表、分布、进程工作情况、调用了哪些模块、需要进行哪些接口权限申请，一目了然，人员更替无需交接，因为所有信息都在中央总控网站可见，且不会是过时的。</li>
<li>【云调度】容量的自动调度。例如要进行某个运营活动需要大量的扩容，只需要把设备放进去，就能自动的扩缩容。当某个城市机房故障，能够自动调度容量到其他城市</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>code review应该如何做?</title>
    <url>/2020/01/29/2020-01-28-code-review/</url>
    <content><![CDATA[<h1 id="做-Code-Review-的正反方观点"><a href="#做-Code-Review-的正反方观点" class="headerlink" title="做 Code Review 的正反方观点"></a>做 Code Review 的正反方观点</h1><p>首先，我们先来看看正方的观点：</p>
<ol>
<li>Code review 中，可以通过大家的建议增进代码的质量。</li>
<li>Code review 是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。</li>
<li>Code review 鼓励程序员们相互学习对方的长处和优点。</li>
<li>Code review 可以被用来确认自己的设计和实现是清楚和简单的。</li>
</ol>
<span id="more"></span>

<p>我们再来听下反方的声音:</p>
<p>很多开发Team抱怨Code Review就是一个形式，费时费力不说，发现的问题还不如测试，而评审者们除了在代码风格上有些见术，别的也就没什么用了，长而久之，大家都会开始厌烦这个事了。</p>
<p>那么为了这篇文章能够写下去, 笔者显然是属于正方了, 此处不再做争辩.</p>
<hr>
<h1 id="Review时-什么该关注-什么不该关注"><a href="#Review时-什么该关注-什么不该关注" class="headerlink" title="Review时, 什么该关注, 什么不该关注"></a>Review时, 什么该关注, 什么不该关注</h1><p>在上面的Code Reivew中的正方观点中，我们没有提到可以帮助找到程序的bug和保证代码风格和编码标准, 那么是说Code Review不能帮助改善这几方面吗? 不是的, 这里确切地说, Code Review不是万能的, 在执行的时候, 应该专注于它应该关注的部分, 那么问题来了, Code Review时, 哪些是该关注的, 哪些又是不该关注的呢?</p>
<h2 id="Code-Review-时不该关注的"><a href="#Code-Review-时不该关注的" class="headerlink" title="Code Review 时不该关注的"></a>Code Review 时不该关注的</h2><p>首先, 先列几个不该在Code Review时关注的</p>
<ol>
<li>Code review <strong>不应该</strong>承担发现代码错误的职责。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的（其中主要是单元测试，因为那是最接近Bug，也是Bug没有扩散的地方）</li>
<li>Code review <strong>不应该</strong>成为保证代码风格和编码标准的手段。编码风格和代码规范都属于死的东西，每个程序员在把自己的代码提交团队Review的时候，代码就应该是符合规范的，这是默认值，属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。</li>
</ol>
<p><strong>注意: 这里说在Code Review时不该关注, 并不是说不重要, 而是说, 这些部分应该有其他方式(例如自动化工具)去保障, 因为人的成本是最高的, 机器和程序才是便宜的.</strong></p>
<h2 id="Code-Review-时该关注的"><a href="#Code-Review-时该关注的" class="headerlink" title="Code Review 时该关注的"></a>Code Review 时该关注的</h2><p>代码审查者在审查代码时有非常多的东西需要关注。一个团队需要明确对于自己的项目哪些点是重要的，并不断在审查中就这些点进行检查。</p>
<h3 id="1-体系结构和代码设计"><a href="#1-体系结构和代码设计" class="headerlink" title="1. 体系结构和代码设计"></a>1. 体系结构和代码设计</h3><ul>
<li><p>代码复用: 根据“三振法”, 如果代码被复制一次，虽然不喜欢这种方式，但通常没什么问题。但如果再一次被复制，就应该通过提取公共的部分来重构它。</p>
</li>
<li><p>用更好的代码: 如果在一块混乱的代码做修改，添加几行代码也许更容易，但建议更进一步，用比原来更好的代码。</p>
</li>
<li><p>潜在的bugs: 是否会引起的其他错误？循环是否以我们期望的方式终止？</p>
</li>
<li><p>错误处理: 错误确定被优雅的修改？会导致其他错误？如果这样，修改是否有用？</p>
</li>
<li><p>效率: 如果代码中包含算法，这种算法是否是高效？ 例如，在字典中使用迭代，遍历一个期望的值，这是一种低效的方式。</p>
</li>
<li><p>新代码与全局的架构是否保持一致？</p>
</li>
<li><p>基础代码是否有结合使用了一些标准或设计样式，新的代码是否遵循当前的规范？代码是否正确迁移，或参照了因不规范而淘汰的旧代码？</p>
</li>
<li><p>代码的位置是否正确？比如涉及订单的新代码是否在订单服务相关的位置？</p>
</li>
<li><p>新代码是否重用了现存的代码？新代码是否可以被现有代码重用？新代码是否有重复代码？如果是的话，是否应该重构成一个更可被重用的模式，还是当前还可以接受？</p>
</li>
<li><p>新代码是否被过度设计了？是否引入现在还不需要的重用设计？</p>
</li>
</ul>
<h3 id="2-可读性和可维护性"><a href="#2-可读性和可维护性" class="headerlink" title="2. 可读性和可维护性"></a>2. 可读性和可维护性</h3><ul>
<li><p>字段、变量、参数、方法、类的命名是否真实反映它们所代表的事物, 是否能够望文生义?</p>
</li>
<li><p>是否可以通过读代码理解它做了什么？</p>
</li>
<li><p>是否理解测试用例测了什么？</p>
</li>
<li><p>测试是否很好地覆盖了用例的各种情况？它们是否覆盖了正常和异常用例？是否有忽略的情况？</p>
</li>
<li><p>错误信息是否可被理解？ log打的是否正确和足够?</p>
</li>
<li><p>不清晰的代码是否被文档、注释或容易理解的测试用例所覆盖？具体可以根据团队自身的喜好决定使用哪种方式。</p>
</li>
</ul>
<h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3. 功能"></a>3. 功能</h3><ul>
<li><p>代码是否真的达到了预期的目标？如果有自动化测试来确保代码的正确性，测试的代码是否真的可以验证代码达到了协定的需求？</p>
</li>
<li><p>代码看上去是否包含不明显的bug，比如使用错误的变量进行检查，或误把and写成or？</p>
</li>
<li><p>作者是否需要创建公共文档或修改现存的帮助文档？</p>
</li>
<li><p>是否检查了面向用户的信息的正确性？</p>
</li>
<li><p>是否有会在生产环境中导致应用停止运行的明显错误？代码是否会错误地指向测试数据库，是否存在应在真实服务中移除的硬编码的stub代码？</p>
</li>
<li><p>你对性能的需求是什么，你是否考虑了安全问题？</p>
<ol>
<li>这个新增或修复的功能是否会反向影响到现存的性能测试结果</li>
<li>外部调用很昂贵(a. 数据库调用. b. 不必要的远程调用. c. 移动或穿戴设备过频繁地调用后端程序)</li>
</ol>
</li>
</ul>
<h3 id="4-安全"><a href="#4-安全" class="headerlink" title="4. 安全"></a>4. 安全</h3><ul>
<li><p>检查是否新的路径和服务需要认证</p>
</li>
<li><p>数据是否需要加密</p>
</li>
<li><p>密码是否被很好地控制？</p>
<blockquote>
<p>这里的密码包含密码（如用户密码、数据库密码或其他系统的密码）、秘钥、令牌等等。这些永远不应该存放在会提交到源码控制系统的代码或配置文件中，有其他方式管理这些密码，例如通过密码服务器（secret server）。当审查代码时，要确保这些密码不会悄悄进入你的版本控制系统中</p>
</blockquote>
</li>
<li><p>代码的运行是否应该被日志记录或监控？是否正确地使用？</p>
<blockquote>
<p>日志和监控需求因各个项目而不同，一些需要合规，一些拥有比别人严格的行为、事件日志规范。如果你有规章规定哪些需要记录日志，何时、如何记录，那么作为代码审查者你应该检查提交的代码是否满足要求。如果你没有固定的规章，那么就考虑：</p>
<ul>
<li>代码是否改变了数据（如增删改操作）？是否应该记录由谁何时改变了什么？</li>
<li>代码是否涉及关键性能的部分？是否应该在性能监控系统中记录开始时间和结束时间？</li>
<li>每条日志的日志等级是否恰当？一个好的经验法则是“ERROR”触发一个提示发送到某处，如果你不想这些消息在凌晨3点叫醒谁，那么就将之降级为“INFO”或“DEBUG”。当在循环中或一条数据可能产生多条输出的情况下，一般不需要将它们记录到生产日志文件中，它们更应该被放在“DEBUG”级别。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="5-其他方面"><a href="#5-其他方面" class="headerlink" title="5. 其他方面"></a>5. 其他方面</h3><ul>
<li><p>是否合理地释放了资源</p>
<ol>
<li>是否存在内存泄漏?</li>
<li>是否存在内存无限增长? 例如, 如果审查者看到不断有变量被追加到list或map中, 那么就要考虑下这个list或map什么时候失效, 或清除无用数据</li>
<li>代码是否及时关闭了连接或数据流?</li>
<li>资源池配置是否是否正确? 有没有过大或者过小?</li>
</ol>
</li>
<li><p>异常情况是否能够正确处理?</p>
<ol>
<li>超时是否能够正确处理?</li>
<li>调用接口出错的时候, 是否有出错处理逻辑, 并且处理正确?</li>
<li>进程意外重启后, 是否能够恢复到崩溃前的环境?</li>
</ol>
</li>
<li><p>正确性(主要与多线程环境关系密切)</p>
<ol>
<li>代码是否使用了正确的适合多线程的数据结构</li>
<li>代码是否存在竞态条件（race conditions）？多线程环境中代码非常容易造成不明显的竞态条件。作为审查者，可以查看不是原子操作的get和set</li>
<li>代码是否正确使用锁？和竞态条件相关，作为审查者你应该检查被审代码是否允许多个线程修改变量导致程序崩溃。代码可能需要同步、锁、原子变量来对代码块进行控制</li>
<li>代码的性能测试是否有价值？很容易将小型的性能测试代码写得很糟糕，或者使用不能代表生产环境数据的测试数据，这样只会得到错误的结果</li>
<li>缓存：虽然缓存是一种能防止过多高消耗请求的方式，但其本身也存在一些挑战。如果审查的代码使用了缓存，你应该关注一些常见的问题，如，不正确的缓存失效方式</li>
</ol>
</li>
<li><p>代码级优化, 对大部分并不是要构建低延时应用的机构来说，代码级优化往往是过早优化，所以首先要知道代码级优化是否必要</p>
<ol>
<li>代码是否在不需要的地方使用同步或锁操作？如果代码始终运行在单线程中，锁往往是不必要的</li>
<li>代码是否可以使用原子变量替代锁或同步操作？</li>
<li>代码是否使用了不必要的线程安全的数据结构？比如是否可以使用ArrayList替代Vector？</li>
<li>代码是否在通用的操作中使用了低性能的数据结构？如在经常需要查找某个特定元素的地方使用链表</li>
<li>代码是否可以使用懒加载并从中获得性能提升？</li>
<li>条件判断语句或其他逻辑是否可以将最高效的求值语句放在前面来使其他语句短路？</li>
<li>代码是否存在许多字符串格式化？是否有方法可以使之更高效？</li>
<li>日志语句是否使用了字符串格式化？是否先使用条件判断语句校验了日志等级，或使用延迟求值？</li>
</ol>
</li>
</ul>
<hr>
<h1 id="Code-Review-的实际操作建议"><a href="#Code-Review-的实际操作建议" class="headerlink" title="Code Review 的实际操作建议"></a>Code Review 的实际操作建议</h1><ol>
<li><p>代码审查是应该在互相沟通中进行讨论的，而不是相互对抗。预先确定哪些是要点哪些不是，可以减少冲突并拟定预期。</p>
</li>
<li><p>经常进行Code Review, 不要攒了1w行才让同事帮你review, 这是坑队友.</p>
<blockquote>
<ul>
<li>要Review的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多。</li>
<li>程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西。 程序员最大的问题就是“自负”，无论什么时候，什么情况下，有太多的机会会让这种“自负”澎涨开来，并开始影响团队影响整个项目，以至于听不见别人的建议，从而让Code Review变成了口水战。</li>
<li>越接近软件发布的最终期限，代码也就不能改得太多。</li>
</ul>
</blockquote>
</li>
<li><p>Code Review不要太正式，而且要短</p>
</li>
<li><p>尽可能的让不同的人Reivew你的代码(不要超过3个人)</p>
<blockquote>
<ul>
<li>从不同的方向评审代码总是好的。</li>
<li>会有更多的人帮你在日后维护你的代码。</li>
<li>这也是一个增加团队凝聚力的方法。</li>
</ul>
</blockquote>
</li>
<li><p>保持积极的正面的态度</p>
<blockquote>
<p>无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！</p>
</blockquote>
</li>
<li><p>学会享受Code Reivew</p>
</li>
</ol>
<hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol>
<li><a href="https://my.oschina.net/wolx/blog/508549">Code Review最佳实践</a></li>
<li><a href="http://coolshell.cn/articles/1302.html">Code Review中的几个提示</a></li>
<li><a href="http://www.infoq.com/cn/articles/effective-code-reviews">如何使代码审查更高效</a></li>
<li><a href="https://book.douban.com/subject/1951158/">&lt;&lt;代码大全&gt;&gt;</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>code-review</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb常用技巧</title>
    <url>/2020/01/29/2020-01-28-gdb-use/</url>
    <content><![CDATA[<h4 id="3种启用gdb的方法"><a href="#3种启用gdb的方法" class="headerlink" title="3种启用gdb的方法"></a>3种启用gdb的方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.gdb &lt;program&gt;</span><br><span class="line">2.gdb &lt;program&gt; core</span><br><span class="line">3.gdb &lt;program&gt; &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><ul>
<li>gdb命令行的 -args 参数</li>
<li>gdb环境中 set args 命令</li>
</ul>
<h4 id="gdb中变量"><a href="#gdb中变量" class="headerlink" title="gdb中变量"></a>gdb中变量</h4><p>可以查看运行时的变量，也可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，或是switch的分支语句。使用set命令可以修改程序中的变量。</p>
<p>另外gdb也有变量，gdb的变量以$开头，比如打印数组中的每个元素，可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$i</span> = 0</span><br><span class="line">(gdb) p a[<span class="variable">$i</span>++]</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>然后一路回车下去了。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r                        ============&gt;运行程序， run 命令简写</span><br><span class="line">c                        ============&gt;继续运行程序，<span class="built_in">continue</span>命令缩写</span><br><span class="line">l                        ============&gt;列出源码， list 命令简写</span><br><span class="line">b                        ============&gt;设置断点，具体请看下面一节</span><br><span class="line">info <span class="built_in">break</span>               ============&gt;查看断点信息</span><br><span class="line">n                        ============&gt;单条语句执行，不进入函数，next 命令缩写</span><br><span class="line">s                        ============&gt;单条语句执行，进入函数，step命令缩写</span><br><span class="line">p i                      ============&gt;打印变量值，<span class="built_in">print</span>命令缩写</span><br><span class="line">display i                ============&gt;显示变量值，后面每行都会显示</span><br><span class="line">bt                       ============&gt;查看函数堆栈，backtrace命令缩写</span><br><span class="line">shell &lt;<span class="built_in">command</span> string&gt;   ============&gt;在gdb中运行shell脚本</span><br><span class="line">finish                   ============&gt;退出函数</span><br><span class="line">q                        ============&gt;退出gdb</span><br><span class="line">&lt;enter&gt;                  ============&gt;重复上一条命令</span><br><span class="line">ptype                    ============&gt;显示变量的数据类型</span><br><span class="line">jump line                ============&gt;跳到指定行开始调试</span><br><span class="line"><span class="built_in">set</span> var=exp              ============&gt;设置变量var的值为exp</span><br><span class="line"><span class="built_in">kill</span>                     ============&gt;结束当前程序的调试</span><br><span class="line">x/[n][format][size]  address    ============&gt;查看内存</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">断点相关</span><br><span class="line"><span class="built_in">break</span> func                      ===============&gt;在函数func入口处设置断点</span><br><span class="line"><span class="built_in">break</span> file.c:100                ===============&gt;在file.c第100行设置断点</span><br><span class="line"><span class="built_in">break</span> [<span class="built_in">where</span>] <span class="keyword">if</span> [condition]    ===============&gt;设置条件断点</span><br><span class="line"><span class="built_in">break</span> file.c:100 thread all     ===============&gt;在file.c文件第100行处，为所有经过这里的线程设置断点</span><br><span class="line">info <span class="built_in">break</span>                      ===============&gt;查看断点列表，会显示<span class="built_in">id</span>号</span><br><span class="line">delete <span class="built_in">id</span>                       ===============&gt;删除断点</span><br><span class="line">clear func                      ===============&gt;删除断点，不需要<span class="built_in">id</span>，格式同<span class="built_in">break</span></span><br><span class="line"><span class="built_in">break</span> xxxxx <span class="keyword">if</span> a==1             ===============&gt;条件断点</span><br><span class="line">condition N COND                ===============&gt;条件断点，N为断点号码，COND为条件</span><br><span class="line">info thread                     ===============&gt;查看thread信息</span><br><span class="line">t &lt;thread <span class="built_in">id</span>&gt;                   ===============&gt;切换到<span class="built_in">id</span>进程，thread命令缩写</span><br><span class="line"></span><br><span class="line">在gdb中，有几种暂停方式： 断点（breakpoint），观察点（watchpoint），捕捉点（catchpoint），信号（signals），线程停止（Thread Stops）</span><br><span class="line">在gdb停住时，可以用info program来查看程序是否在运行，进程号，被暂停的原因。可以用<span class="built_in">continue</span>来恢复程序运行</span><br><span class="line"></span><br><span class="line">watch *(<span class="built_in">type</span> *) addr             ================&gt;watch地址addr的改变， <span class="built_in">type</span>为addr实际指向的数据类型</span><br><span class="line">watch  var                       ================&gt;watch变量var的改变</span><br></pre></td></tr></table></figure>

<h4 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h4><p>1.调试已运行的程序<br>     1）ps查看PID，然后<code>gdb &lt;program PID&gt;</code>挂接正在运行的程序<br>     2）<code>gdb &lt;program&gt;</code>关联上源代码，并进行gdb，在gdb中用<code>attach</code>命令来挂接进程的PID, 用<code>detach</code>来取消挂接的进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info thread 查看当前进程的线程</span><br><span class="line">thread &lt;<span class="built_in">id</span>&gt; 切换调试的线程为指定<span class="built_in">id</span>的线程，t &lt;<span class="built_in">id</span>&gt;</span><br><span class="line"><span class="built_in">break</span> file.c:100 thread all     ===============&gt;在file.c文件第100行处，为所有经过这里的线程设置断点</span><br><span class="line"><span class="built_in">set</span> scheduler-locking off|on|step，在使用step或者<span class="built_in">continue</span>命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试线程执行呢？通过这个命令就可以实现这个需求。</span><br><span class="line">     off  不锁定任何线程，也就是所有线程都执行，这是默认值。</span><br><span class="line">     on   只有当前被调试程序会执行。</span><br><span class="line">     step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后<span class="built_in">continue</span>的行为)以外，只有当前线程会执行。</span><br></pre></td></tr></table></figure>


<h4 id="调试宏"><a href="#调试宏" class="headerlink" title="调试宏"></a>调试宏</h4><p>在gcc编译的时候，加上-ggdb3参数，就可以调试宏了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info macro - 查看这个宏在那些文件被引用了，以及宏定义是什么样子的。</span><br><span class="line">macro -      查看宏展开的样子</span><br></pre></td></tr></table></figure>

<h4 id="自动化调试"><a href="#自动化调试" class="headerlink" title="自动化调试"></a>自动化调试</h4><p>使用command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) <span class="built_in">break</span> func</span><br><span class="line">Breakpoint 1 at 0x3475678: file test.c, line 12.</span><br><span class="line">(gdb) commands 1  // 1 是断点号</span><br><span class="line">Type commands <span class="keyword">for</span> when breakpoint 1 is hit, one per line.</span><br><span class="line">End with a line saying just <span class="string">&quot;end&quot;</span>.</span><br><span class="line">&gt;<span class="built_in">print</span> arg1</span><br><span class="line">&gt;<span class="built_in">print</span> arg2</span><br><span class="line">&gt;<span class="built_in">print</span> arg3</span><br><span class="line">&gt;end</span><br><span class="line">(gdb)</span><br><span class="line">当我们的断点到达时，自动执行<span class="built_in">command</span>中的三个命令，把func的三个参数值打出来。</span><br></pre></td></tr></table></figure>


<h4 id="gdb-server"><a href="#gdb-server" class="headerlink" title="gdb server"></a>gdb server</h4><p>这个主要是针对一些没有安装gdb的嵌入式设备</p>
<p>1）在目标target host上开启gdbserver</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gdbserver &lt;target host ip&gt;:2345[这个端口可以自己根据需要设置] <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>2）到host端，也就是安装有gdb的主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gdb <span class="built_in">test</span></span><br><span class="line">[&gt; <span class="built_in">set</span> solib-absolute-prefix &lt;gdb directory&gt;]</span><br><span class="line">[&gt; <span class="built_in">set</span> solib-search-path &lt;gdb directory/lib或者其他库文件的路径&gt;]</span><br><span class="line">&gt; target remote &lt;target host ip&gt;:2345</span><br></pre></td></tr></table></figure>

<p>然后在host端来调试target上的程序</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>linux</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写好一封Email</title>
    <url>/2020/01/29/2020-01-29-write-good-email/</url>
    <content><![CDATA[<h3 id="接收人"><a href="#接收人" class="headerlink" title="接收人"></a>接收人</h3><ol>
<li><p>收件人</p>
<blockquote>
<p>事件接棒人, 是需要对事件做出响应及跟进的人, 如果需要老板处理, 那么收件人就加上老板, 而不是抄送</p>
</blockquote>
</li>
<li><p>抄送人</p>
<blockquote>
<p>事件知会人, 只需要知道邮件的内容就可以了, 不必要一定做出响应或去跟进</p>
</blockquote>
</li>
</ol>
<span id="more"></span>

<h3 id="称呼及问候语"><a href="#称呼及问候语" class="headerlink" title="称呼及问候语"></a>称呼及问候语</h3><p>写上称呼是一种礼貌的象征, 尤其写对外邮件的时候, 是必要项.</p>
<blockquote>
<ul>
<li>Dear LastName, 比较正式的场合</li>
<li>Hi FirstName, 朋友之间比较随意的场合</li>
<li>Dear FirstName, 如果你不知道用什么, 就用这个</li>
</ul>
</blockquote>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><ul>
<li><strong>直奔主题, 言简意赅</strong>, 以下给几个例子来展示如何直奔主题</li>
</ul>
<blockquote>
<ol>
<li>I’m working on an article about xxx for yyy publication, and wondered if you had a few minutes to answer the following 3 questions.<br>我正在写一篇要交给yyy出版社的文章, 不知道您是否有时间回答下下面3个问题呢?</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>Could you supply me with a quote for the following project?<br>可否对下面的设计项目进行引证?</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>I’d like to discuss the revisions with you. Would Tuesday at 2pm be a good time?<br>我想和你谈谈修订的事情, 这周二下午2点您有空吗?</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>I’ve attached the documents you requested at our meeting yesterday.<br>昨天会议上您要求的文件已附上, 请查收.</li>
</ol>
</blockquote>
<ul>
<li><p>如果有问题需要提出, 或者需要重点突出的内容, 那么将其放到 <strong>开头</strong>. 如果问题放到最后, 收信人可能都不会留意到, 或者不会意识到你在等他的回复.</p>
</li>
<li><p>如果是咨询邮件, 或者说明什么产品, 那么将问题(或特性)一点点的 <strong>编号</strong> 列出来.</p>
</li>
</ul>
<h3 id="常用英文邮件术语"><a href="#常用英文邮件术语" class="headerlink" title="常用英文邮件术语"></a>常用英文邮件术语</h3><ol>
<li><p>To inform 提供信息</p>
<blockquote>
<p>The sender of the email wants to tell the receiver about something such as a new show coming to London. It might contain a link to the theatre. Generally speaking no reply is necessary. It can be a group email sent to a circle of friends, <strong>for example.</strong></p>
<p>Dear all,</p>
<p>Hope you are all well. Just to let you know that The China National Peking Opera is coming to London at the end of November to perform classical Peking Opera and the show will only be on for 3 days, so grab your tickets soon. Here is the link xxx</p>
</blockquote>
</li>
<li><p>To inquire 询问</p>
<blockquote>
<p>The sender needs some information and is expecting a reply.</p>
<p>Dear Sir&#x2F;Madam,</p>
<p>I am writing to inquire about the rules regarding children travelling alone. For instance, can a 15 year old child travel on Air China alone? What should we do if there is not an adult to accompany the child?</p>
<p>I look forward to your advice.</p>
</blockquote>
</li>
<li><p>To request 请求</p>
<blockquote>
<p>The sender is asking for permission to do something, such as an permission to leave 5 days for a trip.<br>I’m writing to see whether it is possible for me to leave 5 days from next Monday for a trip with my family.</p>
<p>Dear xxx</p>
<p>I would be very grateful if you could consider my request.<br>Thanks.</p>
<p>Carl</p>
</blockquote>
</li>
<li><p>Stay in touch 保持联系</p>
<blockquote>
<p>I’m writing to say hello for the purpose to maintain social connections, friendship, and perhaps future collaboration.</p>
<p>Hi xxx,</p>
<p>How are you doing in your new job? It should be perfect, for you are a superman.<br>I’m also busy these two months and have not played any sports these days.</p>
<p>Let me know when you will be free, so we can have a game and a drink.</p>
<p>Best<br>Carl</p>
</blockquote>
</li>
</ol>
<h3 id="校对拼写错误"><a href="#校对拼写错误" class="headerlink" title="校对拼写错误"></a>校对拼写错误</h3><p>很重要, 一定不能有错别字</p>
<h3 id="邮件签名"><a href="#邮件签名" class="headerlink" title="邮件签名"></a>邮件签名</h3><p>写清楚</p>
<ul>
<li>你是谁</li>
<li>你来自哪里</li>
<li>你是做什么的</li>
<li>你的联系方式(电话, 工作地址)</li>
<li>其他(例如你的社交网络账号, 最新宣传博客等), 此条不适用与公司对公邮件</li>
</ul>
]]></content>
      <categories>
        <category>职业素养</category>
      </categories>
      <tags>
        <tag>Email</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信-fcntl记录上锁</title>
    <url>/2020/02/01/2020-02-01-ipc-fcntl/</url>
    <content><![CDATA[<p>这是读写锁的一种扩展类型，可用于有亲缘关系或<strong>无亲缘关系</strong>的<strong>进程</strong>之间共享某个文件的读写。这些锁用于不同进程间的上锁，而不是用于同一进程中不同线程间的上锁。</p>
<p>fcntl记录上锁，可以指定文件中待上锁和解锁部分的字节范围。<br>Posix记录上锁定义了一个特殊的字节范围来指定整个文件，它的起始偏移为0，长度也为0.</p>
<span id="more"></span>

<h2 id="术语-粒度"><a href="#术语-粒度" class="headerlink" title="术语-粒度"></a>术语-粒度</h2><p>用于标记能被锁住的对象的大小。对于Posix记录上锁来说，粒度就是单个字节。通常情况下粒度越小，允许同时使用的用户数就越多。</p>
<p>记录上锁的Posix接口是fcntl函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/*struct flock *arg */</span>)</span></span>;</span><br><span class="line"><span class="comment">// 用于记录上锁的cmd参数有3个值。这3个cmd要求第3个参数arg是指向struct flock的指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> l_type; <span class="comment">// F_RDLCK, F_WRLCK, F_UNLCK</span></span><br><span class="line">    <span class="type">short</span> l_whence; <span class="comment">// SEEK_SET, SEEK_CUR, SEEK_END</span></span><br><span class="line">    <span class="type">off_t</span> l_start; <span class="comment">// relative starting offset in bytes</span></span><br><span class="line">    <span class="type">off_t</span> l_len; <span class="comment">// #bytes; 0 means until end-of-file</span></span><br><span class="line">    <span class="type">pid_t</span> l_pid; <span class="comment">// PID returned by F_GETLK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>F_SETLK 获取（l_type为F_RDLCK或F_WRLCK）或释放（l_type为F_UNLCK）由arg指向的flock结构所描述的锁，如果无法将该锁授予调用进程，该函数就立即返回一个EACCESS或EAGAIN错误，并<strong>不阻塞</strong></li>
<li>F_SETLKW 该命令与上一个命令类似，不过在无法获取锁请求的锁时，调用线程将<strong>阻塞</strong></li>
<li>F_GETLK 检查由arg指向的锁以确定是否有某个已存在的锁会妨碍将新锁授予调用线程。如果当前没有这样的锁存在，由arg指向的struct flock的l_type成员就被置为F_UNLCK。否则，关于这个已存在锁的信息将在由arg指向的struct flock中返回，中包含持有该锁的进程ID</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>F_GETLK完了接着F_SETLK<strong>不是一个原子操作</strong>，并不能保证F_SETLK会成功，因为在两个函数执行期间，很可能有另一个进程已经获取了我们想要的锁。<br>提供F_GETLK的原因在于：当执行F_SETLK的fcntl返回一个错误时，导致该错误的某个锁的信息可由F_GETLK来返回，从而允许我们确定是哪个进程锁住了所请求的文件区，以及上锁方式。<br>但同样有上面的原因，这两个操作<strong>不是原子操作</strong>，在F_GETLK调用之前，很可能原来持有锁的进程已经释放了锁。</li>
<li>对于一个文件的任意字节，<strong>同一时刻，最多只能存在一种类型的锁</strong>（读出锁或写入锁），而且，一个给定字节可以有多个读出锁，但只能有一个写入锁。</li>
<li>当一个描述符不是打开用来读时，如果对它请求一个读出锁，错误就会发生；同样，当一个描述符不是打开用来写时，如果对它请求一个写入锁，错误也会发生</li>
<li>对于一个打开着某个文件的给定进程来说，当它关闭该文件的所有描述符或它本身终止时，与该文件关联的所有锁都被删除。锁不能通过fork由子进程继承</li>
<li>记录上锁不应该同标准I&#x2F;O函数库一起使用，因为该函数库会执行内部缓冲。当某个文件需要上锁时，为避免问题，应对它使用read和write。<br>在进程终止时由内核完成已有锁清理工作的特性，只有fcntl记录上锁完全提供了，System V信号量把它作为一个选项提供。互斥锁、条件变量、读写锁、Posix信号量，并不在进程终止时执行清理工作。</li>
<li>锁住整个文件的两种方式<ul>
<li>l_whence&#x3D;SEEK_SET, l_start&#x3D;0, l_len&#x3D;0（常用，只需一个函数调用）</li>
<li>使用lseek把读写指针定位到文件头，然后指定l_whence&#x3D;SEEK_CUR, l_start&#x3D;0, l_len&#x3D;0</li>
</ul>
</li>
</ol>
<h2 id="劝告性上锁"><a href="#劝告性上锁" class="headerlink" title="劝告性上锁"></a>劝告性上锁</h2><p>Posix记录上锁称为劝告性上锁。其含义是内核维护着已由各个进程上锁的所有文件的正确信息，但是它不能防止一个进程写已由另一个进程读锁定的某个文件；类似的，它也不能防止一个进程读已由另一个进程写锁定的某个文件。当然，前提是该进程有读或写该文件的足够权限。</p>
<h2 id="强制性上锁"><a href="#强制性上锁" class="headerlink" title="强制性上锁"></a>强制性上锁</h2><p>可以用chmod +l filename来对某个文件启用强制性上锁<br>强制性上锁虽然能够阻止非协作进程读一个已被锁住的文件，但是也不能保证万无一失。<br><strong>建议：</strong>如果有多个进程在更新同一个文件，那么所有进程必须使用某种上锁形式协作。</p>
<h3 id="读出者和写入者的优先级"><a href="#读出者和写入者的优先级" class="headerlink" title="读出者和写入者的优先级"></a>读出者和写入者的优先级</h3><p>不同的系统可能有不同的实现，有的是以FIFO顺序处理上锁请求的，而不管上锁请求的类型；有的则会优先考虑读出请求</p>
<h3 id="启动一个守护进程的唯一副本"><a href="#启动一个守护进程的唯一副本" class="headerlink" title="启动一个守护进程的唯一副本"></a>启动一个守护进程的唯一副本</h3><p>记录上锁的一个常见用途是确保某个程序（如守护程序）在任何时刻只有一个副本在运行。<br>守护进程维护一个只有1行文本的文件，其中包含它的进程ID。它打开这个文件，必要的时候创建它，然后请求整个文件的一个写入锁。如果没有取得该锁，我们就知道该程序有另一个副本在运行，于是输出一个出错信息并终止。<br>如果某个守护进程提前崩溃了，内核会<strong>自动释放</strong>它的记录锁。</p>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>免密登录远程linux机器</title>
    <url>/2020/02/01/2020-02-01-ssh-remote-linux/</url>
    <content><![CDATA[<h3 id="为什么选择证书登陆？"><a href="#为什么选择证书登陆？" class="headerlink" title="为什么选择证书登陆？"></a>为什么选择证书登陆？</h3><p>Mac下原生及主流的ssh终端工具大多不具备保存ssh登陆密码的功能, 通过证书登陆的方式，就可以实现原生终端工具Terminal或第三方明星终端iTerm免密码登录远程系统，并且比单纯的密码验证登陆方式提高了安全性。</p>
<span id="more"></span>

<h3 id="配置过程（以下操作都在终端命令行下运行）"><a href="#配置过程（以下操作都在终端命令行下运行）" class="headerlink" title="配置过程（以下操作都在终端命令行下运行）"></a>配置过程（以下操作都在终端命令行下运行）</h3><ol>
<li>进入系统的ssh证书目录 cd ~&#x2F;.ssh&#x2F;</li>
<li>建立证书文件 ssh-keygen -t rsa 提示输入，直接回车即可。</li>
<li>输入 ls 命令查看当前目录会发现新生成的一对秘钥文件分别是：<br>公钥：id_rsa.pub<br>私钥：id_rsa</li>
<li>登陆到远程服务器，进入.ssh目录 cd ~&#x2F;.ssh<br>将上面生成的公钥文件的内容copy进 authorized_keys 文件中</li>
<li>在Mac终端下执行登陆命令 ssh username@server<br>即可免密码登录到远程服务器</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信-Posix信号量</title>
    <url>/2020/02/04/2020-02-04-ipc-posix-sem/</url>
    <content><![CDATA[<h5 id="信号量是一种用于提供不同进程间或一个给定进程的不同线程间同步手段的原语。"><a href="#信号量是一种用于提供不同进程间或一个给定进程的不同线程间同步手段的原语。" class="headerlink" title="信号量是一种用于提供不同进程间或一个给定进程的不同线程间同步手段的原语。"></a>信号量是一种用于提供不同进程间或一个给定进程的不同线程间同步手段的原语。</h5><ul>
<li>Posix有名信号量： 使用Posix IPC名字标识，可用于进程或线程间的同步。</li>
<li>Posix基于内存的信号量： 存放在共享内存中，可用于进程或线程间的同步。</li>
<li>System V信号量： 在内核中维护，可用于进程或线程间的同步。</li>
</ul>
<p><strong>信号量的值是随内核持续的</strong></p>
<span id="more"></span>

<hr>
<h5 id="一个进程可以在某个某个信号量上执行的三种操作"><a href="#一个进程可以在某个某个信号量上执行的三种操作" class="headerlink" title="一个进程可以在某个某个信号量上执行的三种操作"></a>一个进程可以在某个某个信号量上执行的三种操作</h5><ol>
<li>create一个信号量。这还要求调用者指定初始值，对于二值信号量来说，它通常是1，但也可以是0.</li>
<li>wait一个信号量。该操作会测试这个信号量的值，如果其值&lt;&#x3D;0，那就等待（阻塞），一旦其值变为&gt;0，就将它减1.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (semaphore_value &lt;= <span class="number">0</span>)</span><br><span class="line">    ; <span class="comment">// wait; block the thread or process</span></span><br><span class="line">semaphore--;</span><br><span class="line"><span class="comment">// now we have the semaphore</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>while语句中测试该信号量的值和其后将它减1（如果该值大于0），这两个步骤必须是原子的</p>
<ol>
<li>post一个信号量。该操作将信号量的值加1，<code>semaphore_value++</code></li>
</ol>
<h5 id="信号量、互斥锁、条件变量的差异"><a href="#信号量、互斥锁、条件变量的差异" class="headerlink" title="信号量、互斥锁、条件变量的差异"></a>信号量、互斥锁、条件变量的差异</h5><ol>
<li>互斥锁必须总是由给它上锁的线程解锁，信号量的post却不必由执行过它的wait操作的同一线程执行。</li>
<li>互斥锁要么被锁住，要么被解开（二值状态，类似于二值信号量）。</li>
<li>既然信号量有一个与之关联的状态（它的计数值），那么信号量的post操作总是被记住。然而当向一个条件变量发送信号时，如果没有线程等待在该条件变量上，那么该信号将丢失。</li>
<li>当持有某个<strong>信号量</strong>的进程没有释放它就终止时，<strong>内核并不给该信号量解锁</strong>。而当持有某个<strong>记录锁</strong>的进程没有释放它就终止时，<strong>内核自动地释放它</strong></li>
<li>在各种各样的同步技巧（互斥锁、条件变量、读写锁、信号量）中，能够从信号处理程序中安全调用的唯一函数是<code>sem_post</code></li>
</ol>
<p><strong>每种同步方式都有各自的适用场景。互斥锁是为上锁而优化的，条件变量是为等待而优化的，信号量既可用于上锁，也可用于等待，因而可能导致更多的开销和更高的复杂性</strong></p>
<hr>
<h5 id="Posix信号量API"><a href="#Posix信号量API" class="headerlink" title="Posix信号量API"></a>Posix信号量API</h5><p><code>sem_open</code>创建一个新的有名信号量或打开一个已存在的有名信号量。有名信号量总是既可用于线程间的同步，又可用于进程间的同步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, ... <span class="comment">/*mode_t mode, usigned int value*/</span>)</span></span></span><br><span class="line"><span class="function">                    返回：成功返回指向信号量的指针，出错返回SEM_FAILED</span></span><br></pre></td></tr></table></figure>

<ul>
<li>oflag可以为0、O_CREAT或O_CREAT|O_EXCL。如果指定了O_CREAT标志，那么后面两个参数是需要的：<ul>
<li>mode指定权限位，</li>
<li>value指定信号量初始值。二值信号量为1，计数信号量则往往 &gt;1</li>
</ul>
</li>
<li>oflag为O_CREAT时，如果信号量尚未存在，就创建，如果已存在，就打开</li>
<li>oflag为O_CREAT|O_EXCL时，如果信号量已存在，出错</li>
</ul>
<hr>
<p>使用<code>sem_open</code>打开的有名信号量，使用<code>sem_close</code>将其关闭</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_close</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">                    返回：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个进程终止时，内核还对其上仍然打开着的所有有名信号量自动执行这样的信号量关闭操作（不论是自愿终止还是非自愿终止）</li>
<li>关闭一个信号量并没有将它从系统中删除。Posix有名信号量至少是随内核持续的：即使当前没有进程打开着某个信号量，它的值仍然保持。</li>
</ul>
<hr>
<p>有名信号量使用<code>sem_unlink</code>从系统中删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line">                    返回：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个信号量有几个引用计数器记录当前的打开次数，sem_unlink类似于文件I&#x2F;O的unlink函数：当引用计数还是大于0时，name就能从文件系统删除，然而其信号量的析构却要等到最后一个sem_close发生时为止。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">                    返回：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sem_wait测试所指定信号量的值，如果大于0，将它减1并返回。如果等于0，调用线程就被sleep，直到该值变为大于0，这时再将它减1，函数随后返回。 <strong>测试并减1必须是原子</strong>的</li>
<li>sem_trywait与sem_wait类似，不同之处在于，如果所指定的信号量值已经是0，调用线程不会被sleep，函数立即返回，返回EAGAIN错误</li>
<li>如果调用被某个信号中断，sem_wait可能过早地返回，返回错误为EINTR。</li>
</ul>
<hr>
<p>当一个线程使用完某个信号量时，应该调用<code>sem_post</code>，把所指定的信号量的值加1，然后唤醒正在等待该信号量值变为正数的任意线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *valp)</span></span>;</span><br><span class="line">                    返回：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>sem_getvalue</code>在由<code>valp</code>指向的整数中返回所指定信号量的当前值。如果该信号量当前已上锁，那么返回0或某个负数（该负数的绝对值表示等待该信号量解锁的线程数）</li>
</ul>
<hr>
<p>#####示例程序</p>
<p>优于Posix有名信号量至少具有随内核的持续性，因此我们可以<strong>跨多个程序</strong>操纵它们。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── makefile</span><br><span class="line">├── producer_consumer</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   ├── producer_consumer01.c</span><br><span class="line">│   └── producer_consumer02.c</span><br><span class="line">├── README.md</span><br><span class="line">├── semcreate.c</span><br><span class="line">├── semgetvalue.c</span><br><span class="line">├── sempost.c</span><br><span class="line">├── semunlink.c</span><br><span class="line">└── semwait.c</span><br></pre></td></tr></table></figure>

<p>以上semxxx.c是几个用来操纵信号量的小程序，我们的演示过程如下，演示环境为ubuntu 14.04lts 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semcreate <span class="built_in">test</span></span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semgetvalue <span class="built_in">test</span></span><br><span class="line">value = 1</span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semwait <span class="built_in">test</span></span><br><span class="line">pid 2952 has semaphore, value = 0</span><br><span class="line">^C</span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semgetvalue <span class="built_in">test</span></span><br><span class="line">value = 0     <span class="comment"># 仍然为0</span></span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semwait <span class="built_in">test</span> &amp;</span><br><span class="line">[1] 2955</span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semgetvalue <span class="built_in">test</span></span><br><span class="line">value = 0     <span class="comment"># 本实现不使用负值来表示当前等待该信号量的进程/线程数</span></span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semwait <span class="built_in">test</span> &amp;</span><br><span class="line">[2] 2957</span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./semgetvalue <span class="built_in">test</span></span><br><span class="line">value = 0</span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./sempost <span class="built_in">test</span></span><br><span class="line">pid 2955 has semaphore, value = 0</span><br><span class="line">value = 0      <span class="comment"># 看起来等待着的进程优于挂出信号量的进程运行</span></span><br><span class="line">carl@localhost:~/demo/ipc/posix_semaphore$ ./sempost <span class="built_in">test</span></span><br><span class="line">pid 2957 has semaphore, value = 0</span><br><span class="line">value = 0</span><br></pre></td></tr></table></figure>

<p>producer_consumer01.c使用Posix有名信号量，演示了生产者-消费者问题。</p>
<hr>
<p><strong>基于内存的信号量</strong></p>
<p>以上讲述的都是Posix有名信号量，这些信号量由一个name参数标识，它通常指代文件系统中的某个文件。彼此无亲缘关系的不同进程需使用信号量时，通常使用有名信号量。<br>Posix也提供基于内存的信号量，由应用程序分配信号量的内存空间，然后由系统初始化它们的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> shared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">            <span class="keyword">return</span>: <span class="number">0</span> on success, <span class="number">-1</span> on error</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">sem_destroy</span>(<span class="type">sem_t</span> *sem);</span><br><span class="line">            <span class="keyword">return</span>: <span class="number">0</span> on success, <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>

<p>基于内存的信号量是由<code>sem_init</code>初始化的。</p>
<ul>
<li>sem参数指向应用<strong>应用程序必须分配</strong>的sem_t变量。</li>
<li>shared&#x3D;&#x3D;0，待初始化的信号量是在统一进程的各个线程间共享<br>shared!&#x3D;0，待初始化的信号量是在不同进程间共享。该信号量必须存放在某种类型的共享内存区中，而即将使用它的所有进程都要能访问该共享内存区。</li>
<li>value参数，是该信号量的初始值</li>
</ul>
<p><strong>attention</strong></p>
<p>对于一个给定的信号量，必须小心保证只调用<code>semm_init</code>一次。对一个已初始化过的信号量调用<code>sem_init</code>，结果是未定义的。</p>
<p>基于内存的信号量至少具有随进程的持续性，然而它们真正的持续性却取决于存放信号量的内存区的类型。只要含有某个内存信号量的内存区保持有效，该信号量就一直存在。</p>
<ul>
<li>如果某个基于内存的信号量是由单个进程内的各个线程共享的，那么该信号量具有随进程的持续性，当该进程终止时它也消失。</li>
<li>如果某个基于内存的信号量是在不同进程间共享的，那么该信号量必须存放在共享内存区中，因而只要该共享内存区仍然存在，该信号量也就继续存在</li>
</ul>
<blockquote>
<p>服务器可以创建一个共享内存区，在该共享内存区中初始化一个Posix基于内存的信号量，然后终止。一段时间后，一个或多个客户可打开该共享内存区，访问存放在其中的基于内存的信号量。</p>
</blockquote>
<p>producer_consumer02.c使用Posix基于内存的信号量，演示了生产者-消费者问题。</p>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信-读写锁</title>
    <url>/2020/02/04/2020-02-04-ipc-read-write-lock/</url>
    <content><![CDATA[<p>读写锁是作为pthread_rwlock_t数据类型的变量在内存中分配的。当读写锁是在单个进程内的各个线程间共享时，这些变量可以在那个进程内；<br>当读写锁是在共享某个内存区的进程间共享时，这些变量应该在该共享内存区中。</p>
<span id="more"></span>

<h3 id="读写锁的分配原则"><a href="#读写锁的分配原则" class="headerlink" title="读写锁的分配原则"></a>读写锁的分配原则</h3><ol>
<li>只有没有线程持有某个给定的读写锁用于写，那么任意数目的线程可以持有该读写锁用于读</li>
<li>仅当没有线程持有某个给定的读写锁用于读或写时，才能分配该读写锁用于写。</li>
</ol>
<p>某些应用中读数据比修改数据频繁，这些应用可以从改用读写锁代替互斥锁中获益。任意给定时刻允许多个读出者存在提供了更高的并发度，同时在某个写入者修改数据期间保护该数据，以免任何其他读出者或写入者的干扰。<br>读写锁的一个日常类比是访问银行账户。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr)</span></span>; <span class="comment">//获取一个读出锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr)</span></span>; <span class="comment">//获取一个写入锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><ol>
<li>静态分配的读写锁，可以用常值PTHREAD_\RWLOCK_INITIALIZER来初始化</li>
<li>调用pthread_rwlock_init来动态初始化</li>
<li>当一个线程不再需要某个读写锁时，可以调用pthread_rwlock_destroy来销毁它</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>数据类型为pthread_rwlockattr_t的某个属性对象一旦初始化，就通过调用不同的函数来启用或禁止特定属性。当前定义了的唯一属性是PTHREAD_PROCESS_SHARED。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> *valptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>value的值可以为PTHREAD_PROCESS_PRIVATE或PTHREAD_PROCESS_SHARED</p>
<h3 id="线程清理处理程序"><a href="#线程清理处理程序" class="headerlink" title="线程清理处理程序"></a>线程清理处理程序</h3><p>有时候，线程会在持有锁期间被动（被其他线程cancel）或主动终止（主动调用pthread_exit）。为了处理这种情况，线程可以安装或删除清理处理程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span></span>; <span class="comment">// 删除调用线程的取消清理栈中位于栈顶的函数。如果excute不为0，就调用该函数</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>与普通的互斥锁相比，当被保护数据的读访问比写访问更为频繁时，读写锁能够提供更高的并发度。</p>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信-共享内存</title>
    <url>/2020/02/05/2020-02-05-mmap/</url>
    <content><![CDATA[<p>共享内存区是IPC形式中<strong>最快</strong>的. 一旦这样的内存区映射到共享它的进程的地址<br>空间, 这些进程间数据的传递就不再涉及内核. 然而往该共享内存区存放信息或从<br>中取走信息的进程间通常需要某种形式的同步.</p>
<span id="more"></span>

<p><strong>再次强调</strong>: 默认情况下fork派生的子进程并不与其父进程共享内存区.</p>
<p>mmap函数把一个文件或一个Posix共享内存区对象映射到调用进程的地址空间. 使用该<br>函数的3个目的:</p>
<ol>
<li>使用普通文件以提供内存映射I&#x2F;O</li>
<li>使用特殊文件以提供匿名内存映射</li>
<li>使用shm_open以提供无亲缘关系进程间的Posix共享内存区</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line">返回: 成功返回被映射区的起始地址, 失败返回MAP_FAILED</span><br><span class="line"></span><br><span class="line">addr 可以指定描述符fd应被映射到的进程内空间的起始地址. 它通常被设为<span class="literal">NULL</span>, 这</span><br><span class="line">     样告诉内核自己去选择起始地址</span><br><span class="line"></span><br><span class="line">len 映射到调用进程地址空间中的字节数, 它从被映射文件开头起第offset个字节处</span><br><span class="line">    开始算. 通常被设置为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">prot 指定内存映射区的保护, 常见值是 PROT_READ | PROT_WRITE</span><br><span class="line">     prot        说明</span><br><span class="line">     PROT_READ   数据可读</span><br><span class="line">     PROT_WRITE  数据可写</span><br><span class="line">     PROT_EXEC   数据可执行</span><br><span class="line">     PROT_NONE   数据不可访问</span><br><span class="line"></span><br><span class="line">flags MAP_SHARED或MAP_PRIVATE这两个标志必须指定一个, 并有选择地 | MAP_FIXED. </span><br><span class="line">      MAP_PRIVATE 调用进程对被映射数据所做的修改只对本进程可见, 而不改变底层</span><br><span class="line">                  支撑对象</span><br><span class="line">      MAP_SHARED  调用进程对被映射数据所做的修改对于共享该对象的所有进程都可</span><br><span class="line">                  见, 而且确实改变了其底层支撑对象</span><br><span class="line">     </span><br><span class="line">      Flags         说明</span><br><span class="line">      MAP_PRIVATE   变动是私自的</span><br><span class="line">      MAP_SHARED    变动是共享的</span><br><span class="line">      MAP_FIXED     准确的解释addr参数</span><br><span class="line"></span><br><span class="line">      从移植性上考虑, MAP_FIXED不应被指定. 可移植性的代码应该把addr置为<span class="literal">NULL</span>,</span><br><span class="line">      不指定MAP_FIXED</span><br><span class="line"></span><br><span class="line">父子进程之间共享内存区的方法之一: 父进程在调用fork之前先指定MAP_SHARED调用mmap.</span><br><span class="line">Posix<span class="number">.1</span>保证父进程中的内存映射关系存留到子进程中.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">从某个进程的地址空间删除一个映射关系. munmap后再访问这些地址将会导致想调用进程</span><br><span class="line">产生一个SIGSEGV信号</span><br><span class="line"></span><br><span class="line">如果被映射区是使用MAP_PRIVATE标志映射的, 那么调用进程对它所做的变动都会被丢弃掉.</span><br><span class="line"></span><br><span class="line">addr mmap返回的地址</span><br><span class="line">len  映射区的大小</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">内核的虚拟内存算法保持内存映射文件(一般在硬盘上)与内存映射区(在内存中)的同步,</span><br><span class="line">前提是它是一个MAP_SHARED内存区. 如果我们修改了处于内存映射到某个文件的内存区中</span><br><span class="line">某个位置的内容, 那么内核将在稍后某个时刻相应的更新文件. 然而有时候希望确信硬盘</span><br><span class="line">上的文件内容与内存映射区中的内容一致, 这就需要调用msync来执行这种同步</span><br><span class="line"></span><br><span class="line">addr和len通常指代内存中的整个内存映射区, 不过也可以指定该内存区的一个子集.</span><br><span class="line">flags参数: MS_ASYNC和MS_SYNC必须指定一个, 但不能同时指定</span><br><span class="line">- MS_ASYNC  执行异步写, 一旦写操作由内核排入队列, 立即返回</span><br><span class="line">- MS_SYNC   执行同步写, ........................, 等到写操作完成后才返回</span><br><span class="line">- MS_INVALIDATE 使高速缓存的数据失效. 指定了该flag, 那么与其最终副本不一致的文</span><br><span class="line">            件数据的所有内存中副本都失效, 后续的引用将从文件中取得数据.</span><br><span class="line"></span><br><span class="line">Posix还定义了处理内存管理的<span class="number">4</span>个额外函数</span><br><span class="line">- mlockall会使调用进程的整个内存空间常驻内存. munlockall则撤销这种锁定</span><br><span class="line">- mlcok会是调用进程地址空间的某个指定范围常驻内存, 该函数的参数指定了这个范围的</span><br><span class="line">  起始地址以及从该地址算起的字节数. munlock则撤销某个指定内存区的锁定.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用mmap的好处:</p>
<p>使用内存映射文件所得到的奇妙特性是, 所有的I&#x2F;O都在内核的掩盖下完成, 我们只需编<br>写存取内存映射区中各个值的代码. 我们决不调用read, write, lseek, 把显示的文件<br>I&#x2F;O操作变换成存取内存单元, 这样可以简化我们的代码, 有时候还能改善性能</p>
<p>mmap的另一个用途是在无亲缘关系的进程间提供共享内存区(需指定MAP_SHARED标志).这<br>种情形下, 所映射文件的实际内容成了被共享内存区的初始内容, 而且这些进程对该共享<br>内存区所做的任何变动都复制回所映射的文件(以提供随文件系统的持续性).</p>
<ul>
<li>count01.c 父子进程给共享内存区的一个计数器加1, 使用有名信号量</li>
<li>count02.c 父子进程给共享内存区的一个计数器加1, 使用基于内存的信号量</li>
</ul>
<p>内存映射一个普通文件时, 内存映射区的大小(mmap的第二个参数)通常等于该文件的大小.<br>但是文件大小和内存映射区大小可以不同. 我们总是能够访问在当前文件大小以内又在内<br>存映射区以内的那些字节.</p>
<ul>
<li>SIGBUS  内存映射区大小 &gt; 文件大小, 访问了超出文件大小的位置但是未超出内存映射区</li>
<li>SIGSEGV 越界访问内存映射区</li>
</ul>
<h3 id="Posix共享内存区"><a href="#Posix共享内存区" class="headerlink" title="Posix共享内存区"></a>Posix共享内存区</h3><hr>
<p>两者无亲缘关系进程间共享内存区的方法</p>
<ol>
<li>内存映射文件. 由open函数打开, 由mmap函数把所得到的描述符映射到当前进程地址空<br>间中的一个文件</li>
<li>共享内存区对象. 由shm_open打开一个Posix.1 IPC名字, 所返回的描述符由mmap函数<br>映射到当前进程地址空间</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line">返回: 成功返回非负描述符, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">oflag  必须含有O_RDONLY或O_RDWR之一, 还可以有O_CREAT, O_EXCL. 如果 O_RDWR | O_TRUNC,</span><br><span class="line">       而且所需的共享内存区对象已经存在, 那么它将被截断为<span class="number">0</span>长度.</span><br><span class="line">mode   指定权限位, 在O_CREAT时必须指定mode, 未指定O_CREAT时可以mode设为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">shm_unlink删除一个共享内存区对象的名字. 跟所有其他unlink函数(删除文件系统中一个路径名</span><br><span class="line">的unlink, 删除一个Posix消息队列的mq_unlink, 以及删除一个Posix有名信号量的sem_unlink)</span><br><span class="line">一样, 删除一个名字不会影响对于底层支撑对象的现有引用, 知道对于该对象的引用全部关闭为</span><br><span class="line">止. 删除一个名字仅仅防止后续的open, mq_open或sem_open调用取得成功.</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">调用ftruncate来指定新创建的共享内存区对象的大小, 或者修改已存在的对象的大小.</span><br><span class="line"></span><br><span class="line">- 对于普通文件: 如果该文件大小大于length, 额外的数据就被丢弃掉, 如果该文件的大小小于</span><br><span class="line">  length, 那么该文件是否修改以及其大小是否增长是未定义的. </span><br><span class="line">  实际上对于一个普通文件, 把它的大小扩展到length字节的可移植办法是:先lseek到偏移为</span><br><span class="line">  length<span class="number">-1</span>处, 然后write <span class="number">1</span>个字节的数据</span><br><span class="line">- 对于共享内存区对象: 把该对象的大小设置成length字节.</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span>有<span class="number">12</span>个或以上的成员, 但是当fd指代一个共享内存区对象时, 只有<span class="number">4</span>个成员含有信息</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">mode_t</span> st_mode;  <span class="comment">// mode: S_I&#123;RW&#125;&#123;USR, GRP, OTH&#125;</span></span><br><span class="line">    <span class="type">uid_t</span>  st_uid;   <span class="comment">// user id of owner</span></span><br><span class="line">    <span class="type">gid_t</span>  st_gid;   <span class="comment">// group id of owner</span></span><br><span class="line">    <span class="type">off_t</span>  st_size;  <span class="comment">// size in bytes</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>shmcreate.c 创建一个具有指定大小的Posix共享内存区对象</li>
<li>shmunlink.c 删除一个共享内存区对象的名字</li>
<li>shmwrite.c  打开一个共享内存区对象, 填写一个数据模式</li>
<li>shmread.c   打开一个共享内存区对象, 验证其数据模式</li>
</ul>
<p>同一个共享内存区对象内存映射到不同进程的地址空间时, 起始地址可以不同.</p>
<ul>
<li>count03_server.c 创建并初始化共享内存区和信号量的程序</li>
<li>count03_client.c 给存放在共享内存区中的一个计数器加1, 测试的时候可以启动多个client来观察效果</li>
<li>cosumer.c 从共享内存区中取得并输出消息</li>
<li>producer.c 在共享内存区存放消息</li>
</ul>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信-管道</title>
    <url>/2020/02/07/2020-02-07-ipc-pipe/</url>
    <content><![CDATA[<h3 id="pipe匿名管道"><a href="#pipe匿名管道" class="headerlink" title="pipe匿名管道"></a>pipe匿名管道</h3><p>匿名管道由于没有名字, 因此只能由有亲缘关系的进程使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 出错返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">该函数返回两个文件描述符: fd[<span class="number">0</span>]和fd[<span class="number">1</span>], 前者打开来读, 后者打开来写.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>另一个关于管道的例子, 标准I&#x2F;O函数库提供了popen函数, 它创建一个管道并启动另一个进程, 该进程要么从该管道读出标准输入, 要么往该管道写入标准输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span></span>;</span><br><span class="line">返回: 成功返回文件指针，失败返回<span class="literal">NULL</span></span><br><span class="line">注意: popen不对标准错误输出做任何处理, 只有标准输出才被重定向到由它创建的管道</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">返回: 成功则为shell的终止状态, 失败为<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">command是一个shell命令行, popen在调用进程和所指定的命令之间创建一个管道</span><br><span class="line"></span><br><span class="line">- 如果type为r, 调用进程读入command的标准输出</span><br><span class="line">- 如果type为w, 调用进程写到command的标准输入</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>pipe01.c演示了父子进程间通过pipe实现半双工通信</li>
<li>pipe02.c演示了使用popen创建管道</li>
</ul>
<h3 id="FIFO-有名管道"><a href="#FIFO-有名管道" class="headerlink" title="FIFO 有名管道"></a>FIFO 有名管道</h3><p>每个FIFO有一个路径名与之关联, 从而允许无亲缘关系的进程访问同一个FIFO。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">mkfifo函数已经隐含指定了O_CREAT | O_EXCL, 也就是说, 它要么创建一个新的FIFO, 要么返回一个EEXIST错误(如果所指定名字的FIFO已经存在)。此处可参考示例中的正确创建FIFO的步骤</span><br><span class="line"></span><br><span class="line">- 创建出一个FIFO后, 它必须或者打开来读, 或者打开来写。不能打开来既读又写, 因为它是**半双工**的</span><br><span class="line">- 如果一个FIFO, 当前尚没有进程打开它来写, 那么此时打开该FIFO来读的进程将会阻塞</span><br><span class="line">- 对管道或FIFO的write总是往末尾添加数据, 对它们的read总是从开头返回数据。</span><br><span class="line">- 如果对管道或FIFO执行lseek, 会返回ESPIPE错误</span><br><span class="line">- 当对一个管道或FIFO的最终close发生时, 该管道或FIFO中的任何残留数据都被丢弃</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>fifo_read.c 中从文件data.txt中读取内容, 写入到FIFO中</li>
<li>fifo_write.c 中从FIFO中读取内容, 写入到datafromfifo.txt中</li>
<li>data.txt 是测试文件</li>
<li>datafromfifo.txt 是fifo_write.c运行后生成的文件</li>
</ul>
<h3 id="管道和FIFO的区别"><a href="#管道和FIFO的区别" class="headerlink" title="管道和FIFO的区别"></a>管道和FIFO的区别</h3><ul>
<li>创建并打开一个管道, 只需要调用pipe；创建并打开一个FIFO则需在调用mkdifo后再调用open</li>
<li>管道在所有进程最终都关闭它之后自动消失。FIFO的名字则只有通过调用unlink才从文件系统中删除</li>
<li>FIFO需要额外调用的好处: FIFO在文件系统中有一个名字, 该名字允许某个进程创建一个FIFO, 与它<strong>无亲缘关系</strong>的另一个进程来打开这个FIFO, 这对管道来说是不可能的(不考虑传递描述符的情况)</li>
</ul>
<h3 id="管道和FIFO的限制"><a href="#管道和FIFO的限制" class="headerlink" title="管道和FIFO的限制"></a>管道和FIFO的限制</h3><p>系统加于管道和FIFO的唯一限制为:</p>
<ul>
<li><p>OPEN_MAX 一个进程在任意时刻打开的最大描述符数</p>
</li>
<li><p>PIPE_BUF 可原子地写往一个管道或FIFO的最大数据量</p>
</li>
<li><p>get_sys_conf.c 获取当前系统的OPEN_MAX和PIPE_BUF值</p>
</li>
</ul>
<h3 id="将一个描述符设为非阻塞两种方式"><a href="#将一个描述符设为非阻塞两种方式" class="headerlink" title="将一个描述符设为非阻塞两种方式"></a>将一个描述符设为非阻塞两种方式</h3><ol>
<li>调用open的时候可指定O_NONBLOCK标志</li>
<li>如果一个描述符已打开, 那么可以调用fcntl以启用O_NONBLOCK标志。<blockquote>
<p>对于管道来说, 必须使用这种技术, 因为管道没有open调用, 在pipe中也无法指定O_NONBLOCK标志</p>
</blockquote>
</li>
</ol>
<p><strong>FIFO的真正优势</strong>表现在服务器可以是一个长期运行的进程（例如守护进程）, 而且与其客户可以无亲缘关系。<br>作为服务器的守护进程以某个众所周知的路径名创建一个FIFO, 并打开该FIFO来读。此后某个<br>时刻启动的客户打开该FIFO来写, 并将其命令或给守护进程的其他任何东西通过该FIFO发送出去。<br>使用FIFO很容易实现这种形式的单向通信(client-&gt;server)。如果守护进程需要向客户发送<br>回一些东西, 那就需要点技巧(例如客户需要通知守护进程要打开哪个FIFO可以给其发消息)</p>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程通信-消息队列</title>
    <url>/2020/02/08/2020-02-07-ipc-posix-msg-queue/</url>
    <content><![CDATA[<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><hr>
<ol>
<li>在某个进程往一个队列写入消息之前, 并不需要另外某个进程在该队列上等待消息的到达. 这个与管道和FIFO是相反的, 对后两者来说, 除非读出者已存在, 否则先有写入者是没有意义的.</li>
<li>消息队列具有随内核的持续性.一个进程可以往某个队列写入一些消息, 然后终止, 再让另外一个进程在以后某个时刻读出这些消息</li>
<li>队列属性</li>
</ol>
<span id="more"></span>

<p><strong>相关API</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="comment">/* mode_t mode, struct mq_attr *attr */</span>)</span></span>;</span><br><span class="line">返回：成功返回消息队列描述符(作为其余<span class="number">7</span>个消息队列函数的第一个参数), 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span></span>;</span><br><span class="line">返回：成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line">注意: 调用进程可以不再使用该描述符, 但其消息队列并不从系统中删除.</span><br><span class="line">      要从系统中删除消息队列, 必须调用<span class="function">mq_unlink</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line">返回：成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">每个消息队列有一个保存其当前打开着描述符数的引用计数器,</span><br><span class="line">当一个消息队列的引用计数仍大于<span class="number">0</span>时, 可以删除该队列的name, 但是该队列不会析构.</span><br><span class="line">最后一个mq_close后, 再调用mq_unlink, 才会从系统中删除该队列及其上的消息</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mq_attr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> mq_flags;    <span class="comment">// message queue flags: 0, O_NONBLOCK</span></span><br><span class="line">    <span class="type">long</span> mq_maxmsg;   <span class="comment">// max number of messages allowed on queue</span></span><br><span class="line">    <span class="type">long</span> mq_msgsize;  <span class="comment">// max size of a message (in bytes)</span></span><br><span class="line">    <span class="type">long</span> mq_curmsgs;  <span class="comment">// number of messages currently on queue 只能获取, 不能设置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> mq_attr *attr, <span class="keyword">struct</span> mq_attr *oattr)</span></span>;</span><br><span class="line">返回：成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">- mq_setattr 只能设置flags属性, 用于设置或清除阻塞标志, 其他<span class="number">3</span>个属性被忽略.</span><br><span class="line">- mq_maxmsg, mq_msgsize 只能在mq_open的时候设置, 这两个属性必须 同时指定.</span><br><span class="line">- mq_getattr 用于获取队列的属性</span><br><span class="line">- mq_receive 总是返回队列中最高优先级的最早消息</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> prio)</span></span>;</span><br><span class="line">返回：成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *ptr, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> *priop)</span></span>;</span><br><span class="line">返回：成功则返回消息中字节数, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">- mq_receive第二个参数ptr大小的限制, 要&gt;=attr.msgsize才行, 这意味着使用Posix消息</span><br><span class="line">  队列的大多数应用程序必须在打开某个队列后调用mq_getattr确定最大消息大小, 然后分配</span><br><span class="line">  一个或多个那样大小的读缓冲区</span><br><span class="line">- 每个消息都有一个优先级, 它是一个小于MQ_PRIO_MAX的无符号整数.如果应用不必使用优先级</span><br><span class="line">  不同的消息, 那就给mq_send指定值为<span class="number">0</span>的优先级</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">mq_notify</span>(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> sigevent *notification);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>mq_create.c 创建posix消息队列</li>
<li>mq_unlink.c 删除posix消息队列</li>
<li>mq_send.c 向posix消息队列发送消息</li>
<li>mq_receive.c 从posix消息队列收取消息</li>
</ul>
<h3 id="Posix消息队列限制"><a href="#Posix消息队列限制" class="headerlink" title="Posix消息队列限制"></a>Posix消息队列限制</h3><hr>
<ul>
<li>MQ_OPEN_MAX 一个进程能够同时拥有的打开着消息队列的最大数目(Posix要求它至少为8)</li>
<li>MQ_PRIO_MAX 任意消息的最大优先级+1(Posix要求它至少为32)</li>
<li>get_sys_conf.c 获取当前系统的MQ_OPEN_MAX和MQ_PRIO_MAX值</li>
</ul>
<h3 id="Posix消息队列的异步事件通知"><a href="#Posix消息队列的异步事件通知" class="headerlink" title="Posix消息队列的异步事件通知"></a>Posix消息队列的异步事件通知</h3><hr>
<p>Posix消息队列允许异步事件通知, 以告知何时有一个消息放置到了某个空消息队列中.有两种方式可供选择</p>
<ol>
<li>产生一个信号</li>
<li>创建一个线程来执行一个指定的函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sival_int;   <span class="comment">// integer value</span></span><br><span class="line">    <span class="type">void</span> *sival_ptr; <span class="comment">// pointer value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigevent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sigev_notify;         <span class="comment">// SIGEV_&#123;NONE, SIGNAL, THREAD&#125;</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">sigval</span> sigev_value; <span class="comment">// passed to signal handler or thread</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// following two if SIGEV_THREAD</span></span><br><span class="line">    <span class="built_in">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval);</span><br><span class="line">    <span class="type">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_notify</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> sigevent *notification)</span></span>;</span><br><span class="line">返回：成功返回<span class="number">0</span>, 失败返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">该函数为指定队列建立或删除异步事件通知</span><br><span class="line"></span><br><span class="line">该函数的若干使用规则：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如果notification参数非空, 那么当前进程希望在有一个消息到达所指定的先前为空的队列时得到通知.（我们说该进程被注册为接收该队列的通知）</span><br><span class="line"><span class="number">2.</span> 如果notification参数为<span class="literal">NULL</span>,  而且当前进程目前被注册为接收所指定队列的通知, 那么已存在的注册将被撤销</span><br><span class="line"><span class="number">3.</span> 任意时刻只有一个进程可以被注册接收某个给定队列的通知</span><br><span class="line"><span class="number">4.</span> 当有一个消息到达某个先前为空的队列, 而且已有一个进程被注册接受该队列的通知时, 只有在没有任何线程阻塞在该队列的mq_receive调用中的前提下, 通知才会发出.也就是说, 在mq_receive调用中的阻塞比任何通知的注册都优先</span><br><span class="line"><span class="number">5.</span> 当该通知被发送给它的注册进程时, 其注册即被撤销.该进程必须再次调用mq_notify以重新注册.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="产生一个信号"><a href="#产生一个信号" class="headerlink" title="产生一个信号"></a>产生一个信号</h4><hr>
<p><strong>异步信号安全函数</strong></p>
<table>
<thead>
<tr>
<th align="left">command list</th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">access</td>
<td align="left">fpathconf</td>
<td align="left">rename</td>
<td align="left">sysconf</td>
</tr>
<tr>
<td align="left">aio_return</td>
<td align="left">fstat</td>
<td align="left">rmdir</td>
<td align="left">tcdrain</td>
</tr>
<tr>
<td align="left">aio_suspend</td>
<td align="left">fsync</td>
<td align="left">sem_post</td>
<td align="left">tcflow</td>
</tr>
<tr>
<td align="left">alarm</td>
<td align="left">getegid</td>
<td align="left">setgid</td>
<td align="left">tcflush</td>
</tr>
<tr>
<td align="left">cfgetispeed</td>
<td align="left">geteuid</td>
<td align="left">setpgid</td>
<td align="left">tcgetattr</td>
</tr>
<tr>
<td align="left">cfgetospeed</td>
<td align="left">getgid</td>
<td align="left">setsid</td>
<td align="left">tcgetpgrp</td>
</tr>
<tr>
<td align="left">cfsetispeed</td>
<td align="left">getgroups</td>
<td align="left">setuid</td>
<td align="left">tcsendbreak</td>
</tr>
<tr>
<td align="left">cfsetospeed</td>
<td align="left">getpgrp</td>
<td align="left">sigaction</td>
<td align="left">tcsetattr</td>
</tr>
<tr>
<td align="left">chdir</td>
<td align="left">getpid</td>
<td align="left">sigaddset</td>
<td align="left">tcsetpgrp</td>
</tr>
<tr>
<td align="left">chmod</td>
<td align="left">getppid</td>
<td align="left">sigdelset</td>
<td align="left">time</td>
</tr>
<tr>
<td align="left">chown</td>
<td align="left">getuid</td>
<td align="left">sigemptyset</td>
<td align="left">timer_getoverrun</td>
</tr>
<tr>
<td align="left">clock_gettime</td>
<td align="left">kill</td>
<td align="left">sigfillset</td>
<td align="left">timer_gettime</td>
</tr>
<tr>
<td align="left">close</td>
<td align="left">link</td>
<td align="left">sigismember</td>
<td align="left">timer_settime</td>
</tr>
<tr>
<td align="left">creat</td>
<td align="left">lseek</td>
<td align="left">signal</td>
<td align="left">times</td>
</tr>
<tr>
<td align="left">dup</td>
<td align="left">mkdir</td>
<td align="left">sigpause</td>
<td align="left">umask</td>
</tr>
<tr>
<td align="left">dup2</td>
<td align="left">mkfifo</td>
<td align="left">sigpending</td>
<td align="left">uname</td>
</tr>
<tr>
<td align="left">execle</td>
<td align="left">open</td>
<td align="left">sigprocmask</td>
<td align="left">unlink</td>
</tr>
<tr>
<td align="left">execve</td>
<td align="left">pathconf</td>
<td align="left">sigqueue</td>
<td align="left">utime</td>
</tr>
<tr>
<td align="left">_exit</td>
<td align="left">pause</td>
<td align="left">sigset</td>
<td align="left">wait</td>
</tr>
<tr>
<td align="left">fcntl</td>
<td align="left">pipe</td>
<td align="left">sigsuspend</td>
<td align="left">waitpid</td>
</tr>
<tr>
<td align="left">fdatasync</td>
<td align="left">raise</td>
<td align="left">sleep</td>
<td align="left">write</td>
</tr>
<tr>
<td align="left">fork</td>
<td align="left">read</td>
<td align="left">stat</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 没有列在上表中的函数, 不可以在信号处理程序中调用. 注意所有标准I&#x2F;O函数和pthread_XXX函数都没有列在其中.</p>
<ul>
<li>mq_notify01.c 使用信号通知读Posix消息队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> *sig)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>, 失败返回Exxx错误码</span><br><span class="line"></span><br><span class="line">sigwait一直阻塞到set中指定的信号中有一个或多个待处理, 这时它返回其中一个信号, 存到sig中, 返回值为<span class="number">0.</span> 这个过程称为<span class="string">&quot;同步地等待一个异步事件&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>mq_notify02.c 伴随sigwait使用mq_notify, 使用sigwait代替信号处理程序的信号通知</li>
</ul>
<p>消息队列描述符(mqd_t变量)不是”普通”描述符, 它不能用在select或poll中, 然而我们可以采用”曲线救国”的思想, 伴随一个管道和mq_notify函数使用它们.</p>
<ul>
<li>mq_notify03.c 使用select的Posix消息队列</li>
</ul>
<h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><hr>
<p>异步事件通知的另一种方式是把sigev_notify设置成SIGEV_THREAD, 这会创建一个新的线程. 该线程调用由sigev_notify_function指定的函数, 所用的参数由sigev_value指定.新线程的线程属性由sigev_notify_attributes指定, 传NULL指针表示使用默认属性.</p>
<ul>
<li>mq_notify04.c 启动一个新线程的mq_notify</li>
</ul>
<h3 id="Posix实时信号"><a href="#Posix实时信号" class="headerlink" title="Posix实时信号"></a>Posix实时信号</h3><hr>
<p>信号可划分为两个大组</p>
<ol>
<li>其值在SIGRTMIN和SIGRTMAX(包括两者在内)的实时信号</li>
<li>所有其他信号: SIGALARM, SIGINT, SIGKILL, 等等</li>
</ol>
<p>只有在sigaction调用中指定了SA_SIGINFO, 并且是对SIGRTMIN-SIGRTMAX范围内的信号进行处理时, 实时行为才有保证</p>
<h4 id="实时行为隐含特征："><a href="#实时行为隐含特征：" class="headerlink" title="实时行为隐含特征："></a>实时行为隐含特征：</h4><ul>
<li>信号是排队的. 如果一个信号产生了3次, 它就递交3次.</li>
<li>当有多个SIGRTMIN-SIGRTMAX范围内的解阻塞信号排队时, <strong>值较小</strong>的信号先于值较大的信号递交.（demo signal_realtime.c 中对此进行了验证）</li>
<li>当某个非实时信号递交时, 传递给它的信号处理函数的唯一参数是该信号的值；实时信号则携带更多信息. 通过设置SA_SIGINFO标志安装的任意实时信号处理函数声明如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> signo, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> si_signo;          <span class="comment">// same value as *signo* argument</span></span><br><span class="line">    <span class="type">int</span> si_code;           <span class="comment">// SI_&#123;USER, QUEUE, TIMER, ASYNCIO, MEGEQ&#125;</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">sigval</span> si_value; <span class="comment">// integer or pointer value from sender</span></span><br><span class="line">&#125; <span class="type">siginfo_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一些新函数定义成使用实时信号工作. 例如sigqueue函数用于代替kill函数向某个进程发送一个信号, 该新函数允许发送者虽所发送信号传递一个sigval联合</li>
</ul>
<h4 id="实时信号由siginfo-t结构中的si-code来标识如何产生"><a href="#实时信号由siginfo-t结构中的si-code来标识如何产生" class="headerlink" title="实时信号由siginfo_t结构中的si_code来标识如何产生"></a>实时信号由siginfo_t结构中的si_code来标识如何产生</h4><table>
<thead>
<tr>
<th align="left">信号</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SI_ASYNCIO</td>
<td align="left">信号由某个异步I&#x2F;O请求的完成产生, 那些aio_XXX函数</td>
</tr>
<tr>
<td align="left">SI_MESGQ</td>
<td align="left">信号在有一个消息被放置到某个空消息队列时产生</td>
</tr>
<tr>
<td align="left">SI_QUEUE</td>
<td align="left">信号有sigqueue函数发出</td>
</tr>
<tr>
<td align="left">SI_TIMER</td>
<td align="left">信号由使用timer_settime函数设置的某个定时器的到时产生</td>
</tr>
<tr>
<td align="left">SI_USER</td>
<td align="left">信号由kill函数发出.</td>
</tr>
</tbody></table>
<p>如果信号由某个其他事件产生, si_code就会被设置成不同于上面所列的某个值.<br>siginfo_t结构的si_value成员只有在si_code为SI_ASYNCIO, SI_MESGQ,<br>SI_QUEUE, SI_TIMER时才有效.</p>
<ul>
<li>signal_realtime.c 演示实时信号的简单测试程序.由父进程连续触发9个信号, 信号值从大到小触发, 每个信号伴随一个int型参数.此示例证明了实时信号是FIFO的, 并且较小值的信号优先递交</li>
</ul>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程通信-互斥锁和条件变量</title>
    <url>/2020/02/07/2020-02-07-mutex-cond/</url>
    <content><![CDATA[<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁和条件变量总是可用来同步一个进程内的各个线程。但是如果一个互斥锁或条件变量是<br>存放在多个进程间共享的某个内存区内，那么它还可以被用来同步这几个进程。</p>
<p>互斥锁指代相互排斥，用于保护临界区，以保证任何时刻<strong>只有一个线程&#x2F;进程</strong>在执行<br>其中的代码。保护一个临界区的代码的通常轮廓大体如下：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lock_the_mutex</span>(...)</span><br><span class="line">操作临界区</span><br><span class="line"><span class="built_in">unlock_the_mutex</span>(...)</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁的初始化"><a href="#互斥锁的初始化" class="headerlink" title="互斥锁的初始化"></a>互斥锁的初始化</h3><ol>
<li>静态分配。 static pthread_mutex_t lock &#x3D; PTHREAD_MUTEX_INITIALIZER;</li>
<li>动态分配。 在运行之时通过调用pthread_mutex_init函数来初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span></span>;  <span class="comment">// block</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span></span>;  <span class="comment">// unblock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>，失败返回Exxx错误码</span><br><span class="line"></span><br><span class="line">如果尝试给一个已由另外某个线程锁住的互斥锁上锁，那么pthread_mutex_lock会阻塞到该</span><br><span class="line">互斥锁被解锁为止，pthread_mutex_trylock是对应的非阻塞函数，如果该互斥锁已锁住，</span><br><span class="line">它就返回一个EBUSY错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>互斥锁是协作性锁。<strong>由coder来保证</strong>操作临界区之前获取对应互斥锁。</p>
<blockquote>
<p>prodcons_mutex.c 使用互斥锁的producer-consumer示例</p>
</blockquote>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>互斥锁用于上锁，条件变量用于等待.</p>
<p>条件变量类型为：pthread_cond_t</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr, <span class="type">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>，失败返回Exxx错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个条件变量总是有一个互斥锁与之关联</p>
<p>pthread_cond_wait <strong>会原子地</strong>执行2个动作</p>
<ol>
<li>给互斥锁mptr解锁</li>
<li>把调用线程投入睡眠，直到另外某个线程就本条件变量调用pthread_cond_signal, pthread_cond_wait返回前重新给mptr上锁</li>
</ol>
<p><strong>给条件变量发送信号的代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;     </span><br><span class="line">    <span class="type">pthread_cond_t</span>  cond;     </span><br><span class="line">    <span class="comment">// vars</span></span><br><span class="line">&#125; var = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, ...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;var.mutex);</span><br><span class="line">设置条件为真</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;var.cond);</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;var.mutex);</span><br><span class="line"></span><br><span class="line">调用pthread_cond_signal的线程不必是与之关联的互斥锁的当前属主。但是如果需要可预见的</span><br><span class="line">调度行为，那么调用pthread_cond_signal的线程必须锁住该互斥锁</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>测试条件并进入睡眠以等待该条件变为真的代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;var.mutex);</span><br><span class="line"><span class="keyword">while</span> (条件为假)</span><br><span class="line">&#123;     </span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;var.cond, &amp;var.mutex);</span><br><span class="line">&#125;</span><br><span class="line">修改条件</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;var.mutex);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>prodcons_mutex_cond.c 使用条件变量的producer-consumer示例</p>
</blockquote>
<h3 id="条件变量的定时等待和广播"><a href="#条件变量的定时等待和广播" class="headerlink" title="条件变量的定时等待和广播"></a>条件变量的定时等待和广播</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr, <span class="type">pthread_mutex_t</span> *mptr, <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>，失败返回Exxx错误码</span><br><span class="line"></span><br><span class="line">pthread_cond_timewait 超时返回ETIMEOUT错误</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="type">time_t</span> tv_sec;  <span class="comment">// seconds     </span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">// nanosecondes</span></span><br><span class="line">&#125;;</span><br><span class="line">abstime是UTC时间，而不是时间差</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁和条件变量的属性"><a href="#互斥锁和条件变量的属性" class="headerlink" title="互斥锁和条件变量的属性"></a>互斥锁和条件变量的属性</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>，失败返回Exxx错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一旦某个互斥锁属性对象或者某个条件变量属性对象已被初始化，就通过调用不同函数启用或<br>禁止特定的特性。例如，指定互斥锁或条件变量在不同进程间共享，而不是只在单个进程内的<br>不同线程间共享</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *ptr, <span class="type">int</span> *valptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *ptr, <span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span> *ptr, <span class="type">int</span> *valptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span> *ptr, <span class="type">int</span> val)</span></span>;</span><br><span class="line">返回: 成功返回<span class="number">0</span>，失败返回Exxx错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个特性只在&lt;unistd.h&gt;中定义了**_POSIX_THREAD_PROCESS_SHARED**时才得以支持，下面给<br>出初始化一个互斥锁以便它能在进程间共享的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> *mptr;  <span class="comment">// 这个互斥锁要存放在**某块共享内存**中</span></span><br><span class="line"><span class="type">pthread_mutexattr_t</span> mattr;</span><br><span class="line"></span><br><span class="line">mptr = <span class="comment">// some value that points to shared </span></span><br><span class="line"><span class="built_in">memorypthread_mutexattr_init</span>(&amp;mattr);  <span class="comment">// 初始化属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _POSIX_THREAD_PROCESS_SHARED         </span></span><br><span class="line">    <span class="built_in">pthread_mutexattr_setpshared</span>(&amp;mattr, PTHREAD_PROCESS_SHARED);  <span class="comment">// 设置特定属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>     </span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> this implementation does not support _POSIX_THREAD_PROCESS_SHARED</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(mptr, &amp;mattr); <span class="comment">// 初始化锁</span></span><br></pre></td></tr></table></figure>

<h2 id="持有锁期间进程终止"><a href="#持有锁期间进程终止" class="headerlink" title="持有锁期间进程终止"></a>持有锁期间进程终止</h2><ul>
<li>没有办法让系统在进程终止时自动释放所持有的锁。</li>
<li>进程终止时，内核总是自动清理的唯一同步锁类型是：fcntl记录锁 </li>
<li>在使用System V信号量时，应用程序可以选择进程终止时内核是否自动清理某个信号量锁。 </li>
<li>线程可以注册一个在自己被另一线程取消时要执行的清理处理程序</li>
</ul>
<blockquote>
<p>文中代码托管在: <a href="https://github.com/carl-wang-cn/demo/tree/master/ipc">https://github.com/carl-wang-cn/demo/tree/master/ipc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>python的finally语句中使用return要慎重!!!</title>
    <url>/2020/02/13/2020-02-13-python-finally-hole/</url>
    <content><![CDATA[<p>前两天, 同事踩了一个坑, python代码的一个接口抛了异常, 但是返回值是0. 这里记录一下.</p>
<p>代码大概是这样的.</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">a, b</span>):</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = a / b</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oops!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(division(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ooops!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一下, 结果如下.</span></span><br><span class="line">&gt; python3 test.py</span><br><span class="line">oops!</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>是不是不符合你预期?</p>
<p>我们来改一行, 再看看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">a, b</span>):</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = a / b</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oops!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ops!&#x27;</span>) <span class="comment"># 这行改了哦, 不用return了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(division(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ooops!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一下, 结果如下.</span></span><br><span class="line">&gt; python3 test.py</span><br><span class="line">oops!</span><br><span class="line">ops!</span><br><span class="line">ooops!!</span><br></pre></td></tr></table></figure>
<p>现在的结果是不是符合预期了?</p>
<p>从这个采坑和测试过程来看, 在finally语句中一定要注意一下return的使用, 要慎重!!!</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>proto buffer MergeFrom的坑</title>
    <url>/2020/03/17/2020-03-17-donot-use-pb-mergefrom/</url>
    <content><![CDATA[<p>pb好用, 性能虽然比不上二进制, 不过也比json在大多数情况下还是好很多. 尤其是字段的向前向后兼容, 这一点应该也是大多数同学选用pb的原因. 然后终于<strong>掉进坑</strong>了, 严重得影响了一次线上服务.<br>整理测试程序的时候发现, python的官方指南压根就没提MergeFrom这个接口, 看起来是专门用来坑c++的兄弟的啊</p>
<span id="more"></span>

<p>下面给个例子来说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mergefrom_trap.proto</span></span><br><span class="line">package mergefrom_trap;</span><br><span class="line">message Person</span><br><span class="line">&#123;</span><br><span class="line">required string name = 1;</span><br><span class="line">required int32 age = 2;</span><br><span class="line">// optional int32 new1 = 3;</span><br><span class="line">// optional int32 new2 = 4[default = 0];</span><br><span class="line">&#125;</span><br><span class="line">message AddressBook</span><br><span class="line">&#123;</span><br><span class="line">required string host_name = 1;</span><br><span class="line">repeated Person person = 2;</span><br><span class="line">// optional int32 new3 = 3;</span><br><span class="line">// optional int32 new4 = 4[default = 0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-先用没有new1-4字段的proto-编译出c-的bin文件"><a href="#1-先用没有new1-4字段的proto-编译出c-的bin文件" class="headerlink" title="1. 先用没有new1-4字段的proto, 编译出c++的bin文件"></a>1. 先用没有new1-4字段的proto, 编译出c++的bin文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[carl pb_mergefrom_trap]$ protoc -I=./ --cpp_out=./ mergefrom_trap.proto</span><br><span class="line">[carl pb_mergefrom_trap]$ g++ read_new_write_old.cpp mergefrom_trap.pb.cc -lprotobuf -o read_new_write_old.bin</span><br></pre></td></tr></table></figure>

<h5 id="2-然后添家new1-4字段-生成-mergefrom-trap-pb2-py"><a href="#2-然后添家new1-4字段-生成-mergefrom-trap-pb2-py" class="headerlink" title="2. 然后添家new1-4字段, 生成 mergefrom_trap_pb2.py"></a>2. 然后添家new1-4字段, 生成 mergefrom_trap_pb2.py</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[carl pb_mergefrom_trap]$ protoc -I=./ --python_out=./ mergefrom_trap.proto</span><br></pre></td></tr></table></figure>

<h5 id="3-用write-new-py程序创建一个address-book对象并写入文件-输出结果如下"><a href="#3-用write-new-py程序创建一个address-book对象并写入文件-输出结果如下" class="headerlink" title="3. 用write_new.py程序创建一个address_book对象并写入文件, 输出结果如下:"></a>3. 用write_new.py程序创建一个address_book对象并写入文件, 输出结果如下:</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[carl pb_mergefrom_trap]$ python write_new.py addressbook</span><br><span class="line">address_book: host_name: <span class="string">&quot;carl&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 30</span><br><span class="line">new1: 1</span><br><span class="line">new2: 2</span><br><span class="line">&#125;</span><br><span class="line">new3: 3</span><br><span class="line">new4: 4</span><br></pre></td></tr></table></figure>

<h5 id="4-执行上面c-的bin文件"><a href="#4-执行上面c-的bin文件" class="headerlink" title="4. 执行上面c++的bin文件"></a>4. 执行上面c++的bin文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[carl pb_mergefrom_trap]$ ./read_new_write_old.bin addressbook</span><br><span class="line">book: host_name: <span class="string">&quot;carl&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 30</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_copyfrom_update&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_copyfrom_update&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_copyfrom_update&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_copyfrom_update&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_copyfrom_update&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">a big <span class="built_in">trap</span> is coming ....</span><br><span class="line">book: host_name: <span class="string">&quot;carl_copyfrom_update&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_update_mergefrom&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_update_mergefrom&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_update_mergefrom&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_update_mergefrom&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br><span class="line">book: host_name: <span class="string">&quot;carl_update_mergefrom&quot;</span></span><br><span class="line">person &#123;</span><br><span class="line">name: <span class="string">&quot;person1&quot;</span></span><br><span class="line">age: 100</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">3: 1</span><br><span class="line">4: 2</span><br><span class="line">&#125;</span><br><span class="line">3: 3</span><br><span class="line">4: 4</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由上测试结果可以看出, 一个使用了旧proto的c++程序, 在调用mergefrom的时候, 那2个unknown的字段不是覆盖回原来已有的字段上, 而是<strong>新增</strong>了. 连续调用几次, 这个是指数级增长的. 这会导致serialize出来的bin文件大小指数级增长, 然后会影响到进程, 在Parse和Serialize的时候, 函数调用会阻塞几十秒甚至几分钟, 网络流量也会剧增, 这对一个生产服务器可以说是致命的, 血淋淋的教训啊.<br>以上文件托管在<br><a href="https://github.com/carl-wang-cn/demo/tree/master/testcode/pb_mergefrom_trap">github&#x2F;demo&#x2F;tree&#x2F;master&#x2F;testcode&#x2F;pb_mergefrom_trap</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>记录一次因为redis aof rewrite重写导致的运维事故</title>
    <url>/2020/03/17/2020-03-17-redis-aof-disaster/</url>
    <content><![CDATA[<h2 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h2><p>redis master 所在物理机A, 物理内存16G, aof rewrite 被触发时, aof文件已达12G, redis的默认配置触发了后台的rewrite进程, 内存占用达到了50%, 已严重影响到redis的正常访问. 而此时距离美股交易开盘只剩1小时.</p>
<span id="more"></span>

<h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><h4 id="跟server组几名同事-carl-shilinchen-echo-jiezhao-zhiguocai-一起理清楚问题现状"><a href="#跟server组几名同事-carl-shilinchen-echo-jiezhao-zhiguocai-一起理清楚问题现状" class="headerlink" title="跟server组几名同事(carl, shilinchen, echo, jiezhao, zhiguocai)一起理清楚问题现状"></a>跟server组几名同事(carl, shilinchen, echo, jiezhao, zhiguocai)一起理清楚问题现状</h4><ol>
<li>redis slave的数据是完整的, 1小时内不会有写入请求</li>
<li>aof rewrite进程已运行2小时, 是否能在1小时内运行完毕不可控</li>
<li>aof rewrite进程, 即使在1小时内运行完, 不确认是否会马上触发第2次rewrite</li>
</ol>
<h4 id="整理方案如下"><a href="#整理方案如下" class="headerlink" title="整理方案如下:"></a>整理方案如下:</h4><ol>
<li>将物理机B的redis slave切换为master, 使其跟现有物理机A的redis脱离master-slave关系</li>
<li>对生产环境的hosts文件修改, 使hosts中配置的域名指向新的master</li>
<li>重启相关进程, 使其连接到新的redis master</li>
<li>测试白名单账号验证服务正常</li>
<li>stop原来物理机A上的旧master进行, 暂时保留现场不动</li>
<li>第2天, 交易收盘后, 清理redis中的历史数据</li>
<li>周末进一步处理<blockquote>
<ol>
<li>新准备好下一交易日的uinfo和margin相关数据</li>
<li>将物理机A的redis配置为物理机B新master的slave</li>
<li>重命名该redis配置路径的aof文件</li>
<li>重启该redis, 使该redis从0开始从物理机A的redis master进行数据同步</li>
<li>手动触发物理机B的redis master的aof rewrite, 此过程完成后, aof文件从10G变为1.5G</li>
</ol>
</blockquote>
</li>
<li>补齐定期删除历史数据的server逻辑</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>交易系统和风控系统经过重新设计, 进行了重构, redis已经是过去时了, 不过曾经踩过的这个坑希望能记录下来, 让我们时时警示一下.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>RSA-数字签名与加密</title>
    <url>/2020/12/27/RSA/</url>
    <content><![CDATA[<h3 id="1-公钥私钥（标准条目）"><a href="#1-公钥私钥（标准条目）" class="headerlink" title="1. 公钥私钥（标准条目）"></a>1. 公钥私钥（标准条目）</h3><ol>
<li>公钥和私钥成对出现</li>
<li>公开的密钥叫公钥，只有自己知道的叫私钥</li>
<li>用公钥加密的数据只有对应的私钥可以解密</li>
<li>用私钥加密的数据只有对应的公钥可以解密</li>
<li>如果可以用公钥解密，则必然是对应的私钥加的密</li>
<li>如果可以用私钥解密，则必然是对应的公钥加的密</li>
</ol>
<span id="more"></span>

<p>密码学中要使用Key，而在公钥密码学中，有两个Key，一个公钥PK(Public Key)，一个私钥SK(Secret Key)，其中公钥PK公开，任何人都可以查到，而私钥SK保密，理论上只应该有你一个人知道。这一点是与分组密码算法(DES,AES)不同的，因为在分组密码算法中，只有一个KEY，且是在通信双方共享的，并且需要保密。下面以公钥密码算法RSA为例，来讲一讲在公钥密码学，加密与签名时，key的选择问题。</p>
<p>首先要说一说通信，通信自然要涉及通信双方。密码学的大师给了通信双方两个好听的名字A(lice)，B(ob)。下面约定一下PK(A),PK(B)分别代表Alice和Bob的公钥，是完全公开的，任何人都可以查到；SK(A)为Alice的私钥，只有Alice自己知道，SK(B)为Bob的私钥，只有Bob一个人知道。下面从Bob的角度来讨论。</p>
<h3 id="2-加密"><a href="#2-加密" class="headerlink" title="2. 加密"></a>2. 加密</h3><p>加密，为什么要加密？因为通信的双方使用的是公开的信道，而信道上是可能有窃听者的，如果使用明文传输消息，即不加密，那么窃听者就可以知道消息的内容了，如果你传输的是什么XX消息的话，你就悲剧了。所以为防止消息被不应该知道的人知道，传输时要加密。</p>
<p>在公钥密码学中，一个消息M，在key1的控制下，经过密码算法，得到密文C，是为加密；而密文C，在另一个Key2的控制下，经过密码算法，可以得到对应的明文M，是为解密。其中一个是公钥PK，一个是私钥SK，这是与分组密码不同的。下面来说Bob要传输消息给Alice，该使用那个Key。这里使用枚举，这个办法很好用。总共用四个key。（你不会还想用其他人的key吧。。。）</p>
<ul>
<li>使用PK(B)吗（自己的公钥）？这个，来分析分析。使用PK(B)加密的消息，只能使用对于的SK(B)来解密，而SK(B)只有你自己知道，Alice不知道，窃听者也不知道。使用这个Key的效果最好，别的人都不能知道消息的内容，窃听者也拿它没办法，但是，通信的另一方Alice也不知道消息的内容了，这样的通信就没有意义了。所以，否定掉。</li>
<li>使用SK(B)吗（自己的私钥）？我们来看看，使用SK(B)加密的消息，要使用PK(B)来加密。而PK(B)是公开的，Alice知道，恩，Alice可以解密消息了，这个可以吧！这个真的可以吗？正是因为PK(B)是公开的，Alice知道，窃听者也知道，所以Alice能解密，窃听者也能解密，所以根本就没有保密性。和明文传输没多大的差别了。这个一个悲剧的选择。Pass掉。</li>
<li>使用SK(A)吗（对方的私钥）？SK(A)是Alice的私钥，只有Alice知道，Bob不知道，这个不行。假设Alice将私钥偷偷告诉了你，这样你就可以使用了吧。原理和结局同2中的分析。同样……</li>
<li>使用PK(A)吗（对方的公钥）？排除法告诉我们，只有这个可以选了，那就选它吧。原理什么的就不用讲了吧，大家也没兴趣的。不行，老夫子教导我们，知其然必知其所以然。我们要知道原理。好吧，讲一讲。使用PK(A)加密的消息，要使用SK(A)来解密，而SK(A)对方是知道的，所以消息是可以解密的；而又因为SK(A)只有Alice知道，别的人包括窃听者是不知道的，所以消息的保密性是可以保证的。</li>
</ul>
<p>大致过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A----------------------------------------------------------------&gt;B</span><br><span class="line">产生公钥和私钥---------------------------------------------------&gt;接收PK(A)</span><br><span class="line">用私钥解Y得到X&lt;----------------------------密文Y-----------------随机生成X，用PK(A)加密</span><br><span class="line">用X作为AES密钥进行通信&lt;------------------------------------------&gt;用X作为会话密钥</span><br></pre></td></tr></table></figure>

<p>仔细分析上面三步，可以发现会话是安全的。用公钥加密的数据只有对应的私钥可以解密。<br>假设有个拦截者，他拦截到了PK(A)，同时他也拦截到了Y，但是因为他没有私钥，所以无法解密Y，从而就保证了X只有A和B知道，也就保障了会话安全。<br>那么如果这个拦截者截到了PK(A)，然后他用PK(A)加密某些东西发给A，他想要冒充B，对A进行欺诈，这该怎么办？这时候就需要数字签名，证明对面就是B，不是被冒充的，也就是接下去要讲的。</p>
<h3 id="3-签名"><a href="#3-签名" class="headerlink" title="3. 签名"></a>3. 签名</h3><p>签名，现实生活中，我们可以使用自己的笔迹来签名的。而电子世界呢？签名，这个是公钥密码学提供的而分组密码是无法与他比的特性。签名，为什么要签名？举个例子，假如你发送一条消息给银行，从你的账号中转1亿出去（反正是举例子，说这么大的数额也没什么关系），银行执行了这条消息，转了账，事后，你跟银行说，你没有转过账，要让银行赔偿，如果银行拿不出证据，那银行就悲剧了、破产了，而银行是可以拿出证据的，证据就在那条消息中，因为你对它签名了，而签名在法律上是有效的证据的。好吧。那么，Bob要对消息签名，他该使用哪个key？枚举法再次闪亮登场……</p>
<ul>
<li>使用PK(A)吗（对方的公钥）？假设可以的话，由于PK(A)是公开的，那么任何都是可以伪造你的签名的，你的银行卡就爆了。。。</li>
<li>使用SK(A)吗（对方是私钥）？同样这个你是不知道的。就是对方告诉了你，还是有问题的，因为这个和你的另一个key不匹配，签名是不能验证的，这个问题同样出现在1中。所以，不妥。。。</li>
<li>使用PK(B)吗（自己的公钥）？同样有问题，第一，原理同1，由于是公开的，任何人都可以伪造，银行卡再次爆掉了；第二，原理同2，要验证，就需要使用你的另一个key，即你的私钥，而这个只有你自己知道，所以签名无法验证。这又是一个失败的例子。。。</li>
<li>私钥SK(B)吗（自己的私钥）？还是说说原理吧。签名要使用唯一能确认是你的东西来签名，譬如笔迹。因为SK(B)只有你自己知道，所以满足要求的；其次，使用SK(B)签名的东西，是可以用PK(B)验证的，因为它是公开的。所以也满足要求。</li>
</ul>
<p>大致过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A-------------------------------------------------------------&gt;B</span><br><span class="line">公钥PK(B)&lt;-----------------------------------------------------产生公钥和私钥</span><br><span class="line">用PK(B)解Y得到“我是B”&lt;---------------密文Y---------------------SK(B)加密&quot;我是B&quot;</span><br></pre></td></tr></table></figure>
<p>至此，A可以确认对方就是B，因为如果可以用公钥解密，则必然是对应的私钥加的密，只有B才拥有SK(B)。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>安全通信过程总结如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A---------------------------------------------------------------------&gt;B</span><br><span class="line">公钥PK(B)&lt;----------------------------PK(B)---------------------------产生公钥和私钥</span><br><span class="line">用PK(B)解Y1得到“我是B”&lt;----------------------密文Y1-------------------SK(B)加密&quot;我是B&quot;</span><br><span class="line">产生公钥和私钥-------------------------PK(A)--------------------------&gt;接收PK(A)</span><br><span class="line">用私钥解Y2得到X&lt;----------------------密文Y2--------------------------随机生成X，用PK(A)加密</span><br><span class="line">用X作为AES密钥进行通信&lt;-----------------------------------------------&gt;用X作为会话密钥</span><br></pre></td></tr></table></figure>

<p>上面这个过程是安全的。假设有个拦截者，他拦截到了PK(B)，他也拦截到了密文Y1，那么他也可以解密出“我是B”，同样A也解密得到“我是B”，但是拦截者并不能冒充B，因为A知道，只有真正的B才拥有SK(B)，才能加密得到密文Y1，从而完成认证，A可以放心的跟B进行下一步通信。紧接着，A将自己的公钥发送给B，B生成随机数X，用PK(A)进行加密得到密文Y2并发送，假设拦截者获得了PK(A)，也获得了密文Y2，但是拦截者却始终无法解密得到X，从而保证了X的安全传送。最后，A和B以X作为回话密钥进行通信，以AES加密方式通信。</p>
<p><strong>以上所有讨论都基于一个前提：那就是私钥一直都是安全的，都只有自己知道！</strong></p>
<pre><code>    上面的都是废话，下面来总结一下，接下来的这句才是重点.在公钥密码学中，加密使用对方的公钥，那么只有对方能解密，签名使用自己的私钥，用公钥来验证签名。
    到这里我们发现，数字签名是用私钥进行签名。这样的话，会话过程比较复杂。继续讨论上面的议题，有个拦截者，拦截了PK(A)，想要冒充B跟A进行对话，如果我们约定，A和B对话之前，先来一段口令，只有口令对了，那么A才能认为对面是B。也就是B必须按照和A约定好的协议进行通信，否则A就认为对面是冒充的。这个方法简单有效，关键在于口令协议无法保证安全，如果口令协议外泄，那么这个方法危险就很大。所以，加密和认证都是必要的。
</code></pre>
<h3 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5. 扩展"></a>5. 扩展</h3><ol>
<li>加密和解密发送方利用接收方的公钥对要发送的明文进行加密,接受方利用自己的私钥进行解密,其中公钥和私钥匙相对的,任何一个作为公钥,则另一个就为私钥.但是因为非对称加密技术的速度比较慢,所以,一般采用对称加密技术加密明文,然后用非对称加密技术加密对称密钥,即数字信封技术.</li>
<li>签名和验证发送方用特殊的hash算法，由明文中产生固定长度的摘要，然后利用自己的私钥对形成的摘要进行加密，这个过程就叫签名。接受方利用发送方的公钥解密被加密的摘要得到结果A，然后对明文也进行hash操作产生摘要B.最后,把A和B作比较。此方式既可以保证发送方的身份不可抵赖，又可以保证数据在传输过程中不会被篡改。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Wash Trading</title>
    <url>/2022/01/22/Wash-Trading/</url>
    <content><![CDATA[<p>Wash Trading</p>
<p>Wash Trading是交易者买卖证券向市场提供误导性信息。Wash Trading可以由交易者和经纪人相互勾结来进行，也可以是一个投资者自己同时充当证券买方和卖方来进行。根据美国法律，Wash Trading是非法的。美国国税局禁止纳税人从其应纳税收入金额中扣除因为Wash Trading造成的损失。</p>
<p>在1936年通过《商品交易法》后，联邦政府就禁止进行Wash Trading，该法律对《谷物期货法》进行了修订，并要求所有商品交易都必须在受监管的交易所进行。在1930年代被禁止之前，Wash Trading是股票操纵者很喜欢的一个手段，去假装表示对某只股票有很大兴趣，进而试图提高股价，然后高价位的时候做空来收割韭菜们。</p>
<p>商品期货交易委员会（CFTC）也禁止券商从Wash Trading中获利，即使券商声称不知道交易者的意图。因此，券商必须对客户进行尽职调查，以确保他们出于共同受益所有权的目的购买公司的股份。</p>
<p>美国国税局（IRS）也有严格的禁止Wash Trading的规定，并要求纳税人不能从应纳税金额中扣除Wash Trading产生的损失。美国国税局将Wash Trading定义为购买证券后30天内出售并造成损失的交易。</p>
<span id="more"></span>

<h3 id="Wash-Trading-和-高频交易"><a href="#Wash-Trading-和-高频交易" class="headerlink" title="Wash Trading 和 高频交易"></a>Wash Trading 和 高频交易</h3><p>随着高频交易现象日益普遍，Wash Trading在2013年再次回到大家的视线内。高频交易是使用超高速计算机和高速Internet连接每秒执行数万笔交易。</p>
<p>从2012年开始，当时的商品期货交易委员会专员 Bart Chilton 宣布，他打算调查违反Wash Trading法的高频交易行业，因为使用高频交易的公司很容易偷偷进行Wash Trading。</p>
<p>2013年，美国证券交易委员会（SEC）指控Wedbush Securities，未能“对客户使用的交易平台保持直接和排他的控制权”，致使其一些高频交易者进行了Wash Trading和其他被禁止的操纵市场的行为。</p>
<p>Wash Trading在加密货币交易中也起不少作用。根据区块链透明性研究所的研究，2018年加密货币交易所中，排名前25位的比特币交易对中约有80％是Wash Trading。</p>
<h3 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h3><ul>
<li>Wash Trading是一种非法交易，券商和交易者通过向市场提供误导性信息来串谋牟取暴利。</li>
<li>高频交易公司和加密货币交易所使用Wash Trading来操纵价格。</li>
<li>Wash Trading本质上是互相抵消且没有商业价值的交易。但是它们被用于各种交易情况。</li>
</ul>
<p>例如，LIBOR丑闻中，使用Wash Trading来偿还操纵日元的LIBOR提交面板的经纪人。根据英国金融当局的指控，瑞银交易员与一家经纪公司进行了9次Wash trading，产生了170,000英镑的费用，以奖励该公司在操纵伦敦银行同业拆借利率中的作用。</p>
<p>Wash Trading还可以用于产生股票的假交易量，以催高其价格。假设交易者XYZ和经纪公司合谋快速买卖股票ABC。其他交易者如果注意到这个股票的交易量变化，就可能会将资金投入ABC以从其价格变动中获利。 XYZ然后做空股票，从而从其价格下跌中获利。</p>
<p>英文原文： <a href="https://www.investopedia.com/terms/w/washtrading.asp">https://www.investopedia.com/terms/w/washtrading.asp</a></p>
]]></content>
      <categories>
        <category>金融知识分享</category>
      </categories>
  </entry>
  <entry>
    <title>When issued 预发行交易</title>
    <url>/2020/05/28/When-issued/</url>
    <content><![CDATA[<h3 id="What-Does-“When-Issued”-Mean"><a href="#What-Does-“When-Issued”-Mean" class="headerlink" title="What Does “When Issued” Mean?"></a>What Does “When Issued” Mean?</h3><p>When issued (WI) is a transaction that is made conditionally because a security has been authorized but not yet issued. Treasury securities, stock splits, and new issues of stocks and bonds are all traded on a When-issued basis. Prior to a new issue’s offering, underwriters solicit potential investors who may elect to book an order to purchase a portion of the new issue.</p>
<p>WI是有条件的交易，因为证券已被授权但尚未发行。短期国库券，股票拆合股以及股票和债券的新发行都是基于WI来进行交易。在发行新股（IPO）之前，承销商会招募潜在的投资者，他们可能会选择购买一点新发行的证券。</p>
<span id="more"></span>

<h3 id="Understanding-When-Issued"><a href="#Understanding-When-Issued" class="headerlink" title="Understanding When Issued"></a>Understanding When Issued</h3><p>When-issued orders are made conditionally because they may not be completed, particularly in the event the offering is canceled. Orders, when issued, are sometimes called orders “with ice” or orders “when distributed.” The term is short for “when, as and if issued.”</p>
<p>Securities trade on a When-issued basis when they have been announced but not yet issued. The transaction is settled only after the security has been issued. A When-issued market exists where When-issued instruments are traded. When-issued markets can provide an indication regarding the level of interest that a new issue may attract. When-issued transactions are dependent upon the actual security being issued and the exchange or National Association of Securities Dealers ruling that the transaction is settled.</p>
<p>When-issued订单之所有<strong>有条件</strong>是由于它们可能不会完成，特别是发行（例如IPO）被取消的情况下。When-issued订单有时也被称为“with ice”订单或“when distributed”订单。该术语是“when, as and if issued”的缩写。</p>
<p>宣布但是还未发行的证券，是要基于When-issued来交易的。这些交易只有在证券被发行后才会被结算。存在一个专门用来交易When-issued产品的所谓的When-issued市场，这个市场可以给一个信号，看一下这个新发行的证券在市场上对投资者有多大的吸引力。When-issued交易取决于实际发行的证券，以及决定这笔交易可结算的交易所或国际证券商协会（这句话英文好像很别扭）。</p>
<h3 id="Benefits-of-When-Issued"><a href="#Benefits-of-When-Issued" class="headerlink" title="Benefits of When Issued"></a>Benefits of When Issued</h3><p>When issued sheds light on the demand for securities and can, therefore, attract investors who would otherwise sit out bidding for the securities for fear of a volatile market. Thus, when issued can decrease volatility when the securities are actually issued because investors have confidence in the level of demand for the securities in question. When issued helps develop the market for a new security by attracting investors, and it also offers investors liquidity prior to the actual distribution of the securities in question, allowing them to monetize financial assets more readily.</p>
<p>When-issued阐明了对证券的需求，因此也能够吸引到那些因担心市场动荡而原本会竞购证券的投资者。因此，由于投资者对证券的需求量水平有信心（不担心IPO时股票卖不出去呗），When-issued可以减少证券真正发行时的波动性。When-issued通过吸引投资者来开拓信证券的市场，也可以在证券真正发行之前给投资者优先提供流动性，使他们更容易将金融资产货币化。</p>
<h3 id="Example-of-When-Issued"><a href="#Example-of-When-Issued" class="headerlink" title="Example of When Issued"></a>Example of When Issued</h3><p>An industrial conglomerate wants to spin off its chemicals division due to its drag on earnings and low margins. In order to effectuate the spinoff, the conglomerate plans to pay its shareholders a dividend in the form of stock of the new chemicals divisions company. After the record date, the date on which holders of the conglomerate’s stock are entitled to receive stock in the spinoff, the conglomerate’s shareholders can effectively begin trading the right to receive shares in the spinoff on a When-issued basis. Those shareholders who buy the rights but do not hold shares of the conglomerate on the distribution date, the date in which the actual shares in the spinoff are issued and begin trading, receive their shares in the spinoff, and the When-issued market ceases.</p>
<p>一家工业企业集团化学品部门因为拖累了集团的利润，因此集团决定剥离这个部门。为了完成剥离，该企业集团计划用新化学部门的股票向其股东支付股息。在登记日期（就是我找个小本本记一下你有权利分得这个股息了，我记小本本的这天，不是真正给你股票那天）之后，集团的股东就可以基于When-issued交易获得分拆股票的权利。那些买了这些权利，但是在实际发股票并开始股票交易那天，不实际持有集团股票的股东，会收到他们的股票，同时，When-issued市场停止交易。</p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
  </entry>
  <entry>
    <title>我被收了ADR费</title>
    <url>/2021/02/19/adr-vs-ads/</url>
    <content><![CDATA[<p><strong>今天发现因为持有JD被收了ADR费，但是JD不是美国上市的吗？跟TCEHY（腾讯ADR）有什么区别？</strong></p>
<p>ADR: American Depositary Receipts</p>
<p>ADS: American Depositary Shares</p>
<p>从以上ADR和ADS的英文全写其实大概就能理解二者的区别了。</p>
<span id="more"></span>

<p>ADR，大多数非美国公司的股票都是通过ADR在美股市场交易的，ADR指的是整个发行过程。</p>
<p>ADS，是以美元计价的非美国公司的实际股票，可在美国证券交易所购买，ADS指的是单独的股票。</p>
<p>ADR是由美国存托银行发行的，投资者买了ADR，就获得了获取该ADR代表的具体非美国股票的权利，但实际上，对投资者来说，交易ADR其实挺方便的。</p>
<p>ADR:ADS &#x3D; 1:n，n&gt;0，n可以小于1，也可以大于1。</p>
<p>不知道你们用过大闸蟹礼券没有，其实很类似，那张大闸蟹兑换券你可以卖给别人，可以从别人那买；每张券可能只能换1只大闸蟹，也可能可以换5只大闸蟹；对于单纯想通过买卖兑换券来获取价差收益的人来说，兑换券相对于实际的大闸蟹可能还更方便好用。</p>
<h2 id="JD跟TCEHY有啥区别呢？"><a href="#JD跟TCEHY有啥区别呢？" class="headerlink" title="JD跟TCEHY有啥区别呢？"></a>JD跟TCEHY有啥区别呢？</h2><p>JD是作为非美国公司在NASDAQ上市的。但是市场上交易的仍然是ADR。</p>
<p>TCEHY，因为腾讯是在香港上市的，为了让投资者可以在美国市场上交易腾讯，腾讯就需要找一家有资质的美国机构（通常是某国际投行），将他的部分股票托管给该机构在香港的分支机构，然后这个机构会通知美国总部，收到了来自腾讯的股票，然后美国的机构总部就拿出相对应数量的ADR在美股市场中流通了。并且只要投资者持有ADR，在每个月固定的某个时间只要你当时持有ADR，就需要向该机构缴纳一定的费用。</p>
<p>二者都是要被收ADR托管费的。</p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>ADR</tag>
      </tags>
  </entry>
  <entry>
    <title>一个小leader应该关注些什么</title>
    <url>/2022/05/26/better-leader/</url>
    <content><![CDATA[<p>就是单纯列一下我自己认为比较重要的几点</p>
<span id="more"></span>

<ul>
<li>明确团队todolist的轻重缓急，做好短期和中长期规划<ul>
<li>永远要让团队知道下一步要做什么，定期同步团队未来目标<ul>
<li>3-6个月的长期规划</li>
<li>每个月的短期规划</li>
</ul>
</li>
</ul>
</li>
<li>合理的分配工作（同事能成长，事能做成，识别出优秀的同事）<ul>
<li>要把人用好，而不是去改造。我们连自己都改变不了，凭什么去改变别人？</li>
<li>要看到他人的长处和优点</li>
<li>跟团队说清楚每一件事情的大背景。要讲清楚为什么要做，为什么要现在做，获取理解及认同，激发团队的动力，同时为每个任务选择能力匹配的授权对象</li>
</ul>
</li>
<li>建设优秀的团队文化<ul>
<li>信任，没有信任的团队注定一事无成</li>
<li>坦诚，平等沟通 – leader能接受异见，组员敢说</li>
<li>务实</li>
<li>自驱</li>
<li>维护团队荣誉，不做损害团队荣誉的事情</li>
<li>团队内没有竞争，是共进退，不要变成对手，团队成绩不好，谁都好不了，也不会有更好的机会</li>
</ul>
</li>
<li>维护团队的公平，按功劳分配，团队没有普惠</li>
<li>明确哪些该授权，哪些不该授权</li>
<li>制定务实的流程和规范，提高团队质量和效率</li>
<li>员工被冤枉，工作不合理，要敢于发声</li>
<li>带团队聚焦去解决问题，而不是应付领导</li>
<li>解决问题找根本原因，而不是表明原因</li>
<li>敢于去做一些有挑战的事情，不能总是做一些简单的事务性的事情</li>
<li>敢决策，敢负责</li>
<li>对过程负责，对结果也要负责</li>
<li>对公司整体负责，而不是只对自己团队负责</li>
<li>沟通辅导，培养新同事。</li>
<li>保持好团队的健康度<ul>
<li>淘汰机制</li>
<li>团队梯队</li>
<li>团队备份</li>
<li>团队的持续成长</li>
</ul>
</li>
<li>帮助跨团队协作沟通，尤其是协助同事去跟跨团队的leader沟通</li>
</ul>
]]></content>
      <categories>
        <category>team</category>
      </categories>
  </entry>
  <entry>
    <title>系统日志实践</title>
    <url>/2022/01/24/better-sys-log/</url>
    <content><![CDATA[<p>日志是每个程序员，尤其是后台服务器程序员每天都要接触的东西，但是如何把实现一个好的日志，是有很多道道在里面的。</p>
<h2 id="好的日志-vs-不好的日志"><a href="#好的日志-vs-不好的日志" class="headerlink" title="好的日志 vs 不好的日志"></a>好的日志 vs 不好的日志</h2><p>我们为什么要对日志这么一个看起来那么简单的事情专门进行总结呢？看看下面表格就知道了，一个系统，日志的好坏，基本上直接或间接地决定了我们这个系统的质量是什么鸟样。</p>
<table>
<thead>
<tr>
<th>好的日志</th>
<th>不好的日志</th>
</tr>
</thead>
<tbody><tr>
<td>可以帮助开发<br>了解线上系统的运行状态<br>快速准确定位线上问题<br>发现系统瓶颈<br>预警系统潜在风险<br>挖掘产品最大价值</td>
<td>让开发<br>对系统的运行状态一知半解，甚至一无所知<br>系统出现问题无法定位，或者需要花费巨大的时间和精力<br>无法发现系统瓶颈，不知优化从何做起<br>无法基于日志对系统运行过程中的错误和潜在风险进行监控和报警<br>对挖掘用户行为和提升产品价值毫无</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><p>这里只写一下我自己工作中涉及到的日志分类</p>
<h3 id="诊断日志"><a href="#诊断日志" class="headerlink" title="诊断日志"></a>诊断日志</h3><p>这个类型的日志，是我们大部分程序员同学接触最多的类型，通常我们日常口中说的日志都是指这个类型</p>
<ul>
<li>请求入口和出口</li>
<li>外部服务调用和返回的结果</li>
<li>程序异常： DB无法连接</li>
<li>程序启动、关闭、配置加载</li>
<li>抛出异常时，记录异常的详细信息</li>
<li>其他程序运行过程中的信息</li>
</ul>
<h3 id="审计日志"><a href="#审计日志" class="headerlink" title="审计日志"></a>审计日志</h3><p>这个在金融系统，以及一些其他受监管的行业中见的比较多，需要明确记录下一些监管机构要求的信息</p>
<ul>
<li>谁、什么时候、做了什么事情、事情的一些必要细节。</li>
</ul>
<h2 id="日志内容记录建议"><a href="#日志内容记录建议" class="headerlink" title="日志内容记录建议"></a>日志内容记录建议</h2><h3 id="推荐在日志中记录的内容"><a href="#推荐在日志中记录的内容" class="headerlink" title="推荐在日志中记录的内容"></a>推荐在日志中记录的内容</h3><ul>
<li>在系统启动或初始化时记录重要的系统初始化参数</li>
<li>记录系统运行过程中的所有的警告、错误，要有详细的错误信息，不能只记录一个“出错了”</li>
<li>在持久化数据修改时记录修改前和修改后的值</li>
<li>记录系统各主要模块之间的请求和响应</li>
<li>重要的状态变化</li>
<li>系统中一些长期执行的任务的执行进度</li>
</ul>
<h3 id="不推荐在日志中记录的内容"><a href="#不推荐在日志中记录的内容" class="headerlink" title="不推荐在日志中记录的内容"></a>不推荐在日志中记录的内容</h3><ul>
<li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li>
<li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li>
<li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>整个团队（包括运维人员）需要对日志级别有明确的规定，有明确的日志级别，每个级别的处理方式是怎样的。</li>
<li>绝不要打印没有用的日志，尤其是那种循环重复出现的, 防止无用日志淹没重要信息</li>
<li>日志信息要准确全面，并且要<strong>定期对日志内容优化更新</strong>，努力做到仅凭日志就可以定位问题<blockquote>
<p>将一个请求的整个处理流程和唯一的requestID关联起来<br>TODO 如何制定? server在收到请求的时候生成, 但是如何在传递下去呢?</p>
</blockquote>
</li>
<li>日志的优化是一件需要持续不断投入精力的事，需要不断从错误中学习。好的日志就像好的文章一样，绝不是一遍就可以写好的，而需要在实际的运维过程中，结合线上问题的定位，<strong>不断地进行优化</strong>。<br>最关键的一点是，团队要重视日志优化这件事情，不要让日志的质量持续降低（当项目变大时，项目的代码也存在一样的问题，越写越乱）。以下是一些推荐的日志优化实践：<ul>
<li>在定位问题的过程中完善日志，如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化；</li>
<li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li>
<li>定义好整个团队记录日志的规范，保证每个开发记录的日志格式统一；特别是DEBUG级别的日志，也不能由大家随意发挥<blockquote>
<p>例如 a&#x3D;0, a &#x3D; 0, a:0, 这3种不同的表达a的值的格式，在日志检索的时候，就会带来一些额外的工作量</p>
</blockquote>
</li>
<li>团队定期对记录的日志内容进行Review；</li>
<li>在查问题的过程来优化日志记录的方式；</li>
</ul>
</li>
<li>新上线服务器后一定要对日志进行观察，特别地，开发人员可以通过观察日志来确认新功能是否工作正常</li>
<li>对日志进行监控报警，比客户先发现系统问题</li>
<li>日志格式要统一规范(通过封装函数实现)</li>
<li>要把日志的大小，如何切分，如何删除等作为规范建立起来</li>
<li>要有日志定时删除机制(历史日志收集起来集中管理)</li>
<li>日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</li>
<li>要明确不同日志的用途，对日志内容进行分类</li>
<li>慢操作监控(某一步操作比正常情况超时过多), 可以对此情况提升日志级别.<blockquote>
<p>这个是否可以做到根据服务状态动态变化？</p>
</blockquote>
</li>
<li>通过日志中的关键字来确定系统的运行状态</li>
<li>要有一个web页面来对日志进行管理和展示，避免登录到服务器上查看日志。对一个大规模的分布式集群，如果没有一个统一的地方查看日志，那绝对是噩梦！！！<blockquote>
<p>这个远端的web日志系统，一定要稳定可靠，日志不能丢失，导致开发同学定位问题浪费太多无谓的时间</p>
</blockquote>
</li>
</ul>
<h2 id="日志级别的选择"><a href="#日志级别的选择" class="headerlink" title="日志级别的选择"></a>日志级别的选择</h2><table>
<thead>
<tr>
<th>级别</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>FATAL</td>
<td>系统级错误, 导致服务某种程度不可用, 需要立即处理. 服务基本已挂</td>
</tr>
<tr>
<td>ERROR</td>
<td>系统级错误(用户输入错误的不算), 影响用户访问, 需立即处理, 服务还活着, 但无法提供正常服务</td>
</tr>
<tr>
<td>WARN</td>
<td>系统可能有问题, 也可能没有, 例如某些资源的使用超过阈值, 不需要立刻处理, 但是需要关注跟进</td>
</tr>
<tr>
<td>INFO</td>
<td>记录系统的正常运行状态, 不宜过多</td>
</tr>
<tr>
<td>DEBUG</td>
<td>精确记录系统的每一步运行状态, 通过该种日志, 可以查看某一个操作每一步的执行过程. 可以保证在不重现错误的情况下, 可以通过DEBUG级别的日志对问题进行诊断. 需要规范日志格式</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/27363484">https://zhuanlan.zhihu.com/p/27363484</a><br><a href="https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels">https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>对确定性，你怎么理解？</title>
    <url>/2023/02/14/certainty/</url>
    <content><![CDATA[<h1 id="对确定性，你怎么理解？"><a href="#对确定性，你怎么理解？" class="headerlink" title="对确定性，你怎么理解？"></a>对确定性，你怎么理解？</h1><p>如果你100%确定未来1周某股票会拉升50%，那么你会毫不犹豫加满杠杆，把能借到的钱全都借来，满仓等涨发财。但是如果这个确定性只有75%呢，你会怎么做？恐怕不加杠杆，只是把手头的现金全部买入都会犹豫半天吧。</p>
<span id="more"></span>

<p>如果社会的某个政策会维持10年不变，或者这个政策在10年内会有不断调整甚至掉头，假设你是个企业家，<strong>针对这两种不确定性，你会分别怎么做</strong>？你会押上身家性命去在这个行业做一家企业吗？（先不说创业是九死一生的事情）如果你是个VC，针对这两种确定性，你又会怎么去做投资？你会去重金投资这个赛道吗？</p>
<p>然而，我们当今的社会，我们所处的行业，我们要遵守的行业规条，我们面对的营商环境甚至生活环境，<strong>统统都不是100%确定不变的</strong>。所有的东西，都是活在概率论这个逻辑的下面，这也是澳门菠菜行业赖以生存的底层规律。我们唯一可以100%确定的，就是不确定性的存在，我们必须学着去<strong>在各种不确定中去寻找一些概率高的确定性</strong>，再去做出一些应对的行为。</p>
<p>那我们又能把哪些事情当成是确定性来对待呢？</p>
<p>在服务器领域，那么服务器是<strong>一定会</strong>有概率发生断电，坏硬盘，断网等各种稀奇古怪的故障的，今天不发生，明天不发生，过几天总是会发生的，这就是不确定性中的确定性，它<strong>确定会发生，不确定的只是发生的时间</strong>。那么针对这类事情，我们就可以根据故障成本做一些提前的预案设计。</p>
<p>厨房家电使用上，有多少人经历过忘关火烧干锅的情况，我不信有任何人是故意干这事的，一定是因为种种原因忘了还开着火了。那么怎么解决呢，用有定时控制的厨具（先不要考虑这类厨具也有概率出故障），这样你就算忘了，它也会自己关。家电厂家帮我们想好了各种危险场景，防干烧功能基本是标配了。作为一名IT从业者，定时这种功能，我也更倾向于机械旋钮的，因为我相信所有的程序都会有bug的，不要信程序员说的“我写的代码没bug”，他都是瞎扯。</p>
<p>我们再往大了说，我们国人对于买房这件事，贷款30年，这是对未来30年内，家庭收入的稳定性和增长性的确定性的前提下才敢做的决定，我们得确认在未来30年，每个月都有钱还给银行。如果对未来的确定性丢失了，没有信心自己的收入会一直稳定甚至增长，那么我认为没几个人敢真的去给自己背上几十年的贷款的，起码我不敢，你敢吗？</p>
<p>3年大yi，太多的出行需求被压抑，不论是旅游还是公务，不敢出去的原因，我仔细思考过，于我来讲就是2点，一点是那个xx码在不同的地方不互认，没有一个全国统一的标准给出来；第二点就是下面的执行层各种加码高层的政策，以及早上晚上的政策规定可能会变化，让到达出行目的地可能发生的事情充满了不确定性。如果这两点能解决，根本就不存在什么不敢出去。只要有确定性的要求和处理方式，都是可以提前准备好的，就像大家去深圳的各个政府机关办事一样，网上提前查出来要准备的材料，带齐了，按照预订的时间到达，办理时间和结果基本都是可预期的，这就是确定性，也是深圳速度和效率的体现。</p>
<p>当下时间，你的信心恢复了吗？你思考清楚了你即将面对的确定性和不确定性了吗？</p>
]]></content>
      <categories>
        <category>胡思乱想</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab示例</title>
    <url>/2021/01/08/crontab-examples/</url>
    <content><![CDATA[<p>crontab -e 编辑该用户的crontab， 不存在时新建<br>crontab -l 列出该用户的crontab<br>crontab -r 删除该用户的crontab<br>crontab -u<uid> 指定要设定crontab的用户名称</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">30 08 10 06 *     /path/to/script      <span class="comment"># 在6月10日上午8：30运行该脚本。 *表示一周的任何一天</span></span><br><span class="line">00 11,16 * * *    /path/to/script      <span class="comment"># 每天于11:00 16:00 各执行一次。</span></span><br><span class="line">00 09-18 * * *    /path/to/script      <span class="comment"># 每天9-18点的整点 各执行一次。</span></span><br><span class="line">00 09-18 * * 1-5  /path/to/script      <span class="comment"># 只在周一到周五的9-18点的整点各执行一次</span></span><br><span class="line">* * * * *         /path/to/script      <span class="comment"># 每分钟执行一次</span></span><br><span class="line">*/5 * * * *       /path/to/script      <span class="comment"># 每5分钟执行一次</span></span><br><span class="line">0-10/2 * * * *    /path/to/script      <span class="comment"># 在前10分钟的每2分钟</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>四巫日</title>
    <url>/2021/12/17/four-witching-days/</url>
    <content><![CDATA[<p>什么是美国金融市场“四巫日”</p>
<p>“四巫日”是美股每季度一次的金融衍生品到期日，分别发生在每年三、六、九、十二月的第三个星期五。</p>
<span id="more"></span>

<p>当日，股指期货、股指期权、个股期货与个股期权同时到期。 当日最后一个交易小时为四巫小时（Quadruple Witching Hour），即纽约时间下午三至四点。在到期时段内，交易量急剧增加，市场波动幅度加剧。</p>
<p>在“四巫日”的最后交易时段内，投资者急于平仓，导致交易量大幅增加。因此，“四巫日”通常伴随股票和衍生品价格的大幅波动。</p>
<p>“四巫日”当天，股票、股指的期货和期权大量交易，有时，投资者平掉的仓位可以和新建仓位抵消，金融产品不会出现过度供给或过度需求。有时，投资者采取不同的投资策略，在市场上共同起作用，制造相应的股票买卖需求，从而从波动中获利。</p>
<p>“四巫日”对股市的影响在当天开盘和收盘的时段最为明显，这也是通常期货和期权到期的时段。投资者在该时段内买卖股票，以履行期货期权持有人的义务。但对于长期投资者而言，“四巫日”的影响微乎其微。</p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>一些优秀的文字</title>
    <url>/2022/06/28/good-words-01-md/</url>
    <content><![CDATA[<p>阅读的时候，记录了一些对自己触动很大，希望还能时长翻看的文字，也会随手记下几句闪过脑子的文字。</p>
<span id="more"></span>

<ul>
<li>不要比拼清高，而要让自己生活得幸福。当你能自由地游走于世俗的现实与内心卓尔不群的原则之间时，你也就实现了个人修炼的圆满，成为了一个从内心里幸福的人。</li>
<li>我们不要成为清高之人，也不要成为世俗之人，我们只要成为普通的正常人，一个外圆内方之人。</li>
<li>处处与世俗为敌，并不会让世俗得以改变。尊重世俗，也不意味着失去尊严，失去自我。</li>
<li>一个人的实力未必表现为在名利山上攀登, 真有实力的人还能支配自己的人生走向, 适时地退出竞赛, 省下时间来做自己喜欢做的事情, 享受生命的乐趣</li>
<li>人生下半场，比超负荷赚钱更重要的是心脏有力的跳动；比熬夜玩乐更珍贵的是眼睛清楚看到世界的美好；比生活富裕更幸福的是身体的完好无损</li>
<li>不嫉妒，不抱怨，不过度消费；面对什么困难，都保持乐观的心态，交靠谱的人，做本分的事……都是些简单的道理，也都是些老掉牙的道理。做到了，一生受益。</li>
<li>“老理儿，靠谱。”所有那些传统美德，让人一生受用。</li>
<li>我们不妨去追求最好–最好的生活, 最好的职业, 最好的婚姻, 最好的友谊等等. 但是, 能否得到最好, 取决于许多因素, 不是光靠努力就能成功的. 如果我们尽了力, 结果得到的不是最好, 而是次好, 次次好, 我们也应该坦然地接受. 人生原本就是有缺憾的, 在人生中需要妥协. 不肯妥协, 和自己过不去, 其实是一种痴愚, 是对人生的无知</li>
<li>世上有一些东西, 是你自己支配不了的, 比如运气和机会, 舆论和毁誉, 那就不去管它们, 顺其自然吧</li>
<li>世上有一些东西, 是你自己可以支配的, 比如兴趣和志向, 处世和做人, 那就在这些方面好好地努力, 至于努力的结果是什么, 也顺其自然吧</li>
<li>改变不了的事，就别太纠结。牢骚满腹、怨天怨地是人生大忌。</li>
<li>一个人成熟的标志是自我认识, 认清自己的天赋方向, 外在的虚荣心和野心被内在的目标取代</li>
<li>要有平常心, 看人看己都能除去名利的伪饰</li>
<li>古人讲，一命二运三风水四积德五读书。 这不是迷信。 读书改变命运，是一般人一眼可以看穿的现象；然而积德是帮我们越走越宽，逐步改变生活的，那就需要有推理能力和洞察力才可以明白了；至于风水已经不是我们人这个层面可以轻松看明白的东西了；至于运，甚至命，我们只能祈祷了，这是现在人类想理解都理解不了的。</li>
<li>时至今日，你是否明白，“做自己”的门槛其实很高。踏上社会后，还能保持初心、任性的“做自己”，本就是一件非常奢侈的事情。因为那大体意味着，你不必为了利益而去维持无聊的人际关系、不必为了生存而去做自己不喜欢的工作、不必为了看起来不孤独而去参加那些貌合神离的聚会。而成年人的生活，通常都与“做自己”完全背道而驰，他们无时无刻不得不把自己束缚在某种“身份”之下，戴着面具和镣铐，扮演好社会赋予你的角色。甚至在社会的洗刷下，慢慢地都不知道“自己”是谁了。</li>
<li>你无法控制生命里会发生什么，但你可以控制面对困境时你的情绪和行动，残酷的世界可以拿走你很多东西，唯独一样东西它永远拿不走，就是选择的自由    –《活出生命的意义》</li>
<li>我们大多数人都急于求成, 过分关注眼前利益. 其实很多眼前的得失, 把时间放长远一点看, 可能你所得出的结论都会截然相反. 如果10年前我能懂得这个道理, 或许10年的坚持, 可以让我现在在某一方面做得格外突出了. 现在的我， 把锻炼身体看成是我自己优先级最高的事情， 保持健康，才能有更多的时间去做更多自己想做的事情。</li>
<li>从什么时候开始，你的手机天气app里多了一个家乡的城市？但是我们的父母每天都在看我们所在城市的天气预报</li>
<li>切莫在冲动之下，说出很多一些过分或过激的话，因为言语的力量是巨大的，杀伤力有时难以预估。举一个有些极端的例子。假如你和铁哥们儿吵架了，对方一气之下，打了你两拳，你很有可能过两天就忘记了。但是如果对方说了几句伤你心的话，这种伤心则有可能会持续很久很久，甚至你们可能会因此而绝交。</li>
<li>走正道，路越走越宽</li>
<li>少吃，多动，早睡，静心</li>
<li>任何事情只要加上“天天”俩字，就厉害了。</li>
</ul>
]]></content>
      <categories>
        <category>文字</category>
      </categories>
  </entry>
  <entry>
    <title>hard-to-borrow list 股市卖空--难借股票列表</title>
    <url>/2020/05/15/hard-to-borrow-sell-short/</url>
    <content><![CDATA[<h3 id="What-Is-a-Hard-To-Borrow-List"><a href="#What-Is-a-Hard-To-Borrow-List" class="headerlink" title="What Is a Hard-To-Borrow List?"></a>What Is a Hard-To-Borrow List?</h3><p>A hard-to-borrow list is an inventory record used by brokerages to indicate what stocks are difficult to borrow for short sale transactions. A brokerage firm’s hard-to-borrow list provides an up-to-date catalog of stocks that cannot easily be borrowed for use as a short sale.</p>
<span id="more"></span>

<blockquote>
<p>KEY TAKEAWAYS</p>
<ul>
<li>Short sellers rely on brokers to have stock shares available to borrow.</li>
<li>If the broker has very few shares of a stock available, then that stock is placed on the hard-to-borrow list.</li>
<li>Stocks on the hard-to-borrow list may not be allowed to short.</li>
</ul>
</blockquote>
<p>hard-to-borrow list 首先就是券商要维护更新的一个股票列表， 然后看字面意思， 就是比较难借到，当然还有其他原因会导致某些股票出现在这个list上。我们举个例子，如果A股票90%的持仓都在公司创始股东手里，如果你是创始股东，肯定不希望把股票借给别人，让别人去卖空砸盘吧，这就导致了这个股票是hard-to-borrow的，其他导致某只股票出现在这个list上的原因，请继续往下读。</p>
<blockquote>
<p>几个关键点</p>
<ul>
<li>卖空者依靠券商借入股票.</li>
<li>如果券商只有很少股票可以外借，那么该股票将被置于hard-to-borrow list中。</li>
<li>HTB list上的股票除了卖空利息会很高，还有可能不允许卖空。</li>
</ul>
</blockquote>
<h3 id="Understanding-the-Hard-To-Borrow-List"><a href="#Understanding-the-Hard-To-Borrow-List" class="headerlink" title="Understanding the Hard-To-Borrow List"></a>Understanding the Hard-To-Borrow List</h3><p>Short selling of stocks is built on the notion that an individual trader or investor, wanting to profit from a decrease of that stock’s price, is able to borrow shares of that stock from the broker. Brokerages have a variety of ways to provide access to shares that can be sold short, but regardless of their methods, the result is a finite number of shares available for shorting. Once the number of shares available has come close to running out, the broker will publish a notation of some kind on their platform. This alerts account holders that if they attempt to sell that security short, their trade order may be refused.</p>
<p>In this way a security may be on the hard-to-borrow list because it is in short supply, but it may also be because of its high volatility or other reasons. To enter a short sale, a brokerage client must first borrow the shares from his or her broker. To provide the shares, the broker can use its own inventory or borrow from the margin account of another client or another brokerage firm.</p>
<p>Investors who enter short sale transactions attempt to capture profits in a declining market. For example, an investor may think that shares in Apple are likely to drop in price. The investor can short sell the stock and, if the price falls as he or she anticipates, repurchase it back for a profit. If the stock rises, however, the investor loses money.</p>
<p>股票卖空，是指个人交易者或者投资者，从券商借股票卖出，股票价格下跌时，他们获利。券商有很多方法可以提供可供借出卖空的股票，但是，数量总是<strong>有限</strong>的。一旦数量快用完了，那么券商要在平台上发个某种形式的提醒，提醒自己的客户，如果你试图卖空这些数量即将用完的股票，交易有被拒绝的可能。</p>
<p>证券可能会因为难以供应而出现在hard-to-borrow list上，但也可能是由于其高波动性或其他原因。要进行卖空，客户必须首先从其交易券商那里借到股票。为了提供股票，券商可以从自有库存，从其客户的<strong>margin账户</strong>中，或者从另一个券商借来可以提供给你用来卖空的股票。</p>
<p>进行卖空交易的投资者试图在下降的市场中获利。例如，投资者认为苹果股票的价格可能会下跌。投资者可以卖空股票，如果价格如预期那样下跌，再低价买回来就可以获利。但是，如果股票上涨，投资者就会亏损，而且这个亏损是无上限的，理论上股价涨上天，投资者就亏成煞笔。</p>
<h3 id="Hard-to-Borrow-List-and-Regulation"><a href="#Hard-to-Borrow-List-and-Regulation" class="headerlink" title="Hard-to-Borrow List and Regulation"></a>Hard-to-Borrow List and Regulation</h3><p>Brokerage firms update their hard-to-borrow lists daily. A broker must be able to provide or locate the shares to loan to their client before executing the client’s short sale transaction. Regulation SHO, which was implemented Jan. 3, 2005, has a “locate” condition that requires brokers to have a reasonable belief that the equity to be shorted can be borrowed and delivered to the short seller. The regulation is intended to prevent naked short selling, a practice where the investor places a short sale without holding the shares. (To learn more, see: The Truth About Naked Short Selling.)</p>
<p>券商每天都会更新其Hart-To-Borrow List。在执行客户的卖空交易之前，券商必须能够provide或locate(就是你当前没有，但是你要知道哪里有）要借给客户的股票。 2005年1月3日实施的SHO监管条例，明确了一个“locate”条件，要求券商有合理的理由确信被卖空的equity（不限于股票啦）可以借到并交付给卖空者。该监管条例旨在防止裸卖空，指投资者在不持有股票或者不确认可以借到股票的情况下卖空。</p>
<h3 id="Hard-to-Borrow-List-vs-Easy-to-Borrow-List"><a href="#Hard-to-Borrow-List-vs-Easy-to-Borrow-List" class="headerlink" title="Hard-to-Borrow List vs. Easy-to-Borrow List"></a>Hard-to-Borrow List vs. Easy-to-Borrow List</h3><p>The hard-to-borrow list is the opposite of the easy-to-borrow list, which is an inventory record of securities that are available for short sale transactions. In general, an investor can assume that securities not included on the hard-to-borrow list will be available for short selling. While a brokerage firm’s hard-to-borrow list is typically an internal list (and one that is not available to clients), the firm’s clients usually have access to the easy-to-borrow list.</p>
<p>Brokerage clients may have to pay hard-to-borrow fees on certain short sales. Typically, the cost of borrowing stocks on the difficult-to-borrow list is higher than for stocks that are on the easy-to-borrow list. Large brokerage firms usually have a securities lending desk that helps source stocks that are difficult to borrow. A brokerage’s securities lending desk also lends securities to other firms.</p>
<p>Easy-to-Borrow list，是指一份可卖空的证券记录表，Hard-to-Borrow list与ETB相反，一般来讲，投资者可以认为不在HTB列表上的证券都可以卖空。但是，通常券商的HTB列表是一个内部的数据（也就是客户不可见的），而ETB对客户通常是可见的。</p>
<p>投资者可能需要为“难借”买单。通常，借HTB的股票比借ETB的股票的花费要更高。通常大的券商会有一个专门的证券借贷柜台，帮忙借那些难借的证券，也提供出借证券给别的券商的服务。</p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
  </entry>
  <entry>
    <title>我的MySQL速查手册</title>
    <url>/2020/12/27/mysql-manual/</url>
    <content><![CDATA[<h5 id="查看已存在的数据库"><a href="#查看已存在的数据库" class="headerlink" title="查看已存在的数据库"></a>查看已存在的数据库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; show databases;</span><br><span class="line">+-------------------------+</span><br><span class="line">| Database                |</span><br><span class="line">+-------------------------+</span><br><span class="line">| carltest                |</span><br><span class="line">| <span class="built_in">test</span>                    |</span><br><span class="line">| test2                   |</span><br><span class="line">| test3                   |</span><br><span class="line">| test_insert             |</span><br><span class="line">+-------------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; show databases like <span class="string">&#x27;carl%&#x27;</span>;</span><br><span class="line">+------------------+</span><br><span class="line">| Database (carl%) |</span><br><span class="line">+------------------+</span><br><span class="line">| carltest         |</span><br><span class="line">+------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="查询默认存储引擎"><a href="#查询默认存储引擎" class="headerlink" title="查询默认存储引擎"></a>查询默认存储引擎</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like <span class="string">&#x27;storage_engine&#x27;</span>;</span><br><span class="line">+----------------+--------+</span><br><span class="line">| Variable_name  | Value  |</span><br><span class="line">+----------------+--------+</span><br><span class="line">| storage_engine | InnoDB |</span><br><span class="line">+----------------+--------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure>

<h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name</span><br><span class="line">    [create_specification] ...</span><br><span class="line"></span><br><span class="line">create_specification:</span><br><span class="line">    [DEFAULT] CHARACTER SET [=] charset_name</span><br><span class="line">  | [DEFAULT] COLLATE [=] collation_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个utf8编码的database</span></span><br><span class="line">MariaDB [(none)]&gt; create database carltest</span><br><span class="line">    -&gt; default character <span class="built_in">set</span> utf8</span><br><span class="line">    -&gt; default collate utf8_general_ci;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases like <span class="string">&#x27;carl%&#x27;</span>;</span><br><span class="line">+------------------+</span><br><span class="line">| Database (carl%) |</span><br><span class="line">+------------------+</span><br><span class="line">| carltest         |</span><br><span class="line">+------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure>

<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show databases like <span class="string">&#x27;carl%&#x27;</span>;</span><br><span class="line">+------------------+</span><br><span class="line">| Database (carl%) |</span><br><span class="line">+------------------+</span><br><span class="line">| carltest         |</span><br><span class="line">+------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; drop database carltest;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases like <span class="string">&#x27;carl%&#x27;</span>;</span><br><span class="line">Empty <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure>

<h5 id="设置表的主键"><a href="#设置表的主键" class="headerlink" title="设置表的主键"></a>设置表的主键</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单字段主键, 可以直接指定, 如下示例</span></span><br><span class="line">&gt; create table <span class="keyword">if</span> not exists test1(<span class="built_in">id</span> int primary key,</span><br><span class="line">&gt;                                  name varchar(20),</span><br><span class="line">&gt;                                  sex boolean</span><br><span class="line">&gt;                                  );</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多字段主键</span></span><br><span class="line">&gt; create table <span class="keyword">if</span> not exists test1(stu_id int,</span><br><span class="line">&gt;                                  couse_id int,</span><br><span class="line">&gt;                                  grade <span class="built_in">float</span>,</span><br><span class="line">&gt;                                  primary key(stu_id, course_id),</span><br><span class="line">&gt;                                  );</span><br></pre></td></tr></table></figure>


<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; create table <span class="keyword">if</span> not exists user(userid int(10) unique primary key auto_increment,</span><br><span class="line">    -&gt; username varchar(20) not null,</span><br><span class="line">    -&gt; passwd varchar(20) not null,</span><br><span class="line">    -&gt; info text,</span><br><span class="line">    -&gt; unique index index_uid(userid desc),</span><br><span class="line">    -&gt; index index_user(username, passwd),</span><br><span class="line">    -&gt; fulltext index index_info(info)</span><br><span class="line">    -&gt; ) engine=myisam;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.17 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; show create table user \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: user</span><br><span class="line">Create Table: CREATE TABLE `user` (</span><br><span class="line">  `userid` int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(20) NOT NULL,</span><br><span class="line">  `passwd` varchar(20) NOT NULL,</span><br><span class="line">  `info` text,</span><br><span class="line">  PRIMARY KEY (`userid`),</span><br><span class="line">  UNIQUE KEY `index_uid` (`userid`),</span><br><span class="line">  KEY `index_user` (`username`,`passwd`),</span><br><span class="line">  FULLTEXT KEY `index_info` (`info`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单列索引</span></span><br><span class="line">MariaDB [carltest]&gt; create index index_name on information(name(10));</span><br><span class="line">Query OK, 0 rows affected (0.31 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多列索引</span></span><br><span class="line">MariaDB [carltest]&gt; create index index_bir on information(birthday, address);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用alter语句创建索引</span></span><br><span class="line">MariaDB [carltest]&gt; alter table information add index index_id(<span class="built_in">id</span> asc);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; show create table information \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: information</span><br><span class="line">Create Table: CREATE TABLE `information` (</span><br><span class="line">  `<span class="built_in">id</span>` int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  `sex` varchar(4) NOT NULL,</span><br><span class="line">  `birthday` <span class="built_in">date</span> DEFAULT NULL,</span><br><span class="line">  `address` varchar(50) DEFAULT NULL,</span><br><span class="line">  `tel` varchar(20) DEFAULT NULL,</span><br><span class="line">  `pic` blob,</span><br><span class="line">  PRIMARY KEY (`<span class="built_in">id</span>`),</span><br><span class="line">  KEY `index_name` (`name`(10)),</span><br><span class="line">  KEY `index_bir` (`birthday`,`address`),</span><br><span class="line">  KEY `index_id` (`<span class="built_in">id</span>`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除索引</span></span><br><span class="line">MariaDB [carltest]&gt; drop index index_user on user;</span><br><span class="line">Query OK, 0 rows affected (0.44 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; show create table user \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: user</span><br><span class="line">Create Table: CREATE TABLE `user` (</span><br><span class="line">  `userid` int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(20) NOT NULL,</span><br><span class="line">  `passwd` varchar(20) NOT NULL,</span><br><span class="line">  `info` text,</span><br><span class="line">  PRIMARY KEY (`userid`),</span><br><span class="line">  UNIQUE KEY `index_uid` (`userid`),</span><br><span class="line">  FULLTEXT KEY `index_info` (`info`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h5 id="基本查询语句"><a href="#基本查询语句" class="headerlink" title="基本查询语句"></a>基本查询语句</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT 属性列表</span><br><span class="line">       FROM 表名</span><br><span class="line">       [WHERE XXXX]</span><br><span class="line">       [GROUP BY 属性名1, 属性名2 [, 属性名i ...] [HAVING 条件表达式]]</span><br><span class="line">       [ORDER BY 属性名3 [ASC | DESC]]</span><br><span class="line">       [LIMIT 初始位置, 记录数]</span><br></pre></td></tr></table></figure>

<h5 id="先准备点数据-要不然下面的戏没法唱了"><a href="#先准备点数据-要不然下面的戏没法唱了" class="headerlink" title="先准备点数据, 要不然下面的戏没法唱了."></a>先准备点数据, 要不然下面的戏没法唱了.</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from score;</span><br><span class="line">+----+--------+-----------+-------+</span><br><span class="line">| <span class="built_in">id</span> | stu_id | c_name    | grade |</span><br><span class="line">+----+--------+-----------+-------+</span><br><span class="line">|  1 |    901 | 计算机    |    98 |</span><br><span class="line">|  2 |    901 | 英语      |    80 |</span><br><span class="line">|  3 |    902 | 计算机    |    65 |</span><br><span class="line">|  4 |    902 | 中文      |    88 |</span><br><span class="line">|  5 |    903 | 中文      |    95 |</span><br><span class="line">|  6 |    904 | 计算机    |    70 |</span><br><span class="line">|  7 |    904 | 英语      |    92 |</span><br><span class="line">|  8 |    905 | 英语      |    94 |</span><br><span class="line">|  9 |    906 | 计算机    |    90 |</span><br><span class="line">| 10 |    906 | 英语      |    85 |</span><br><span class="line">+----+--------+-----------+-------+</span><br><span class="line">10 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from student;</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| <span class="built_in">id</span>  | name      | sex  | birth | department   | address            |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| 901 | 张老大    | 男   |  1985 | 计算机系     | 北京市海淀区       |</span><br><span class="line">| 902 | 张老二    | 男   |  1986 | 中文系       | 北京市昌平区       |</span><br><span class="line">| 903 | 张三      | 女   |  1990 | 中文系       | 湖南省永州市       |</span><br><span class="line">| 904 | 李四      | 男   |  1990 | 英语系       | 辽宁省阜新市       |</span><br><span class="line">| 905 | 王五      | 女   |  1991 | 英语系       | 福建省厦门市       |</span><br><span class="line">| 906 | 王六      | 男   |  1988 | 计算机系     | 湖南省衡阳市       |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="LIMIT限定"><a href="#LIMIT限定" class="headerlink" title="LIMIT限定"></a>LIMIT限定</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; SELECT * FROM student LIMIT 1, 3;</span><br><span class="line">+-----+-----------+------+-------+------------+--------------------+</span><br><span class="line">| <span class="built_in">id</span>  | name      | sex  | birth | department | address            |</span><br><span class="line">+-----+-----------+------+-------+------------+--------------------+</span><br><span class="line">| 902 | 张老二    | 男   |  1986 | 中文系     | 北京市昌平区       |</span><br><span class="line">| 903 | 张三      | 女   |  1990 | 中文系     | 湖南省永州市       |</span><br><span class="line">| 904 | 李四      | 男   |  1990 | 英语系     | 辽宁省阜新市       |</span><br><span class="line">+-----+-----------+------+-------+------------+--------------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="IN关键字"><a href="#IN关键字" class="headerlink" title="IN关键字"></a>IN关键字</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; SELECT * FROM student WHERE department IN (<span class="string">&#x27;计算机系&#x27;</span>, <span class="string">&#x27;英语系&#x27;</span>);</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| <span class="built_in">id</span>  | name      | sex  | birth | department   | address            |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| 901 | 张老大    | 男   |  1985 | 计算机系     | 北京市海淀区       |</span><br><span class="line">| 904 | 李四      | 男   |  1990 | 英语系       | 辽宁省阜新市       |</span><br><span class="line">| 905 | 王五      | 女   |  1991 | 英语系       | 福建省厦门市       |</span><br><span class="line">| 906 | 王六      | 男   |  1988 | 计算机系     | 湖南省衡阳市       |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="GROUP-BY关键字"><a href="#GROUP-BY关键字" class="headerlink" title="GROUP BY关键字"></a>GROUP BY关键字</h5><p>GROUP BY关键字通常与集合函数一起使用. 集合函数包括COUNT(), SUM(), AVG(), MAX()和MIN()等.</p>
<p>如果GROUP BY不与上述函数一起使用, 那么查询结果就是字段取值的分组情况. 字段中取值相同的记录为一组,<br>但只显示该组的<strong>第一条</strong>记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; SELECT department, COUNT(<span class="built_in">id</span>) as sum_of_department FROM student GROUP BY department;</span><br><span class="line">+--------------+-------------------+</span><br><span class="line">| department   | sum_of_department |</span><br><span class="line">+--------------+-------------------+</span><br><span class="line">| 中文系       |                 2 |</span><br><span class="line">| 英语系       |                 2 |</span><br><span class="line">| 计算机系     |                 2 |</span><br><span class="line">+--------------+-------------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先按照c_name字段对score表中的记录进行分组. 然后使用MAX()函数计算每组的最大值</span></span><br><span class="line">MariaDB [carltest]&gt; SELECT c_name, MAX(grade) FROM score GROUP BY c_name;</span><br><span class="line">+-----------+------------+</span><br><span class="line">| c_name    | MAX(grade) |</span><br><span class="line">+-----------+------------+</span><br><span class="line">| 中文      |         95 |</span><br><span class="line">| 英语      |         94 |</span><br><span class="line">| 计算机    |         98 |</span><br><span class="line">+-----------+------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>GROUP BY 后面多个属性的时候, 先按照属性1分组, 如果属性1相同, 再按照属性2分组</p>
<h5 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; SELECT c_name, grade FROM score WHERE stu_id=(SELECT <span class="built_in">id</span> FROM student WHERE name=<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">+-----------+-------+</span><br><span class="line">| c_name    | grade |</span><br><span class="line">+-----------+-------+</span><br><span class="line">| 计算机    |    70 |</span><br><span class="line">| 英语      |    92 |</span><br><span class="line">+-----------+-------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.03 sec)</span><br></pre></td></tr></table></figure>


<h5 id="UNION-UNION-ALL用法"><a href="#UNION-UNION-ALL用法" class="headerlink" title="UNION, UNION ALL用法"></a>UNION, UNION ALL用法</h5><p>使用UNION关键字时, 数据库系统会将所有的查询结果合并到一起, <strong>然后去掉相同的记录</strong>. 而UNION ALL关键字则只是简单的合并到一起.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; SELECT <span class="built_in">id</span> FROM student UNION SELECT stu_id FROM score;</span><br><span class="line">+-----+</span><br><span class="line">| <span class="built_in">id</span>  |</span><br><span class="line">+-----+</span><br><span class="line">| 901 |</span><br><span class="line">| 902 |</span><br><span class="line">| 903 |</span><br><span class="line">| 904 |</span><br><span class="line">| 905 |</span><br><span class="line">| 906 |</span><br><span class="line">+-----+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; SELECT <span class="built_in">id</span> FROM student UNION ALL SELECT stu_id FROM score;</span><br><span class="line">+-----+</span><br><span class="line">| <span class="built_in">id</span>  |</span><br><span class="line">+-----+</span><br><span class="line">| 901 |</span><br><span class="line">| 902 |</span><br><span class="line">| 903 |</span><br><span class="line">| 904 |</span><br><span class="line">| 905 |</span><br><span class="line">| 906 |</span><br><span class="line">| 901 |</span><br><span class="line">| 901 |</span><br><span class="line">| 902 |</span><br><span class="line">| 902 |</span><br><span class="line">| 903 |</span><br><span class="line">| 904 |</span><br><span class="line">| 904 |</span><br><span class="line">| 905 |</span><br><span class="line">| 906 |</span><br><span class="line">| 906 |</span><br><span class="line">+-----+</span><br><span class="line">16 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ANY关键字"><a href="#ANY关键字" class="headerlink" title="ANY关键字"></a>ANY关键字</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; SELECT * FROM student WHERE <span class="built_in">id</span>=ANY (SELECT stu_id FROM score WHERE stu_id <span class="keyword">in</span> (SELECT stu_id FROM score WHERE c_name=<span class="string">&#x27;计算机&#x27;</span>) AND c_name=<span class="string">&#x27;英语&#x27;</span>);</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| <span class="built_in">id</span>  | name      | sex  | birth | department   | address            |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| 901 | 张老大    | 男   |  1985 | 计算机系     | 北京市海淀区       |</span><br><span class="line">| 904 | 李四      | 男   |  1990 | 英语系       | 辽宁省阜新市       |</span><br><span class="line">| 906 | 王六      | 男   |  1988 | 计算机系     | 湖南省衡阳市       |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.04 sec)</span><br></pre></td></tr></table></figure>

<h5 id="正则表达式匹配查询"><a href="#正则表达式匹配查询" class="headerlink" title="正则表达式匹配查询"></a>正则表达式匹配查询</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SELECT * FROM table_name <span class="built_in">where</span> xx REGEXP <span class="string">&#x27;匹配方式&#x27;</span>;</span><br><span class="line"></span><br><span class="line">模式字符      含义</span><br><span class="line"></span><br><span class="line">^             匹配字符串开始的部分</span><br><span class="line">$             匹配字符串结束的部分</span><br><span class="line">.             代表字符串中的任意一个字符, 包括回车和换行</span><br><span class="line">[字符集合]    匹配<span class="string">&quot;字符集合&quot;</span>中的任何一个字符</span><br><span class="line">[^字符集合]   匹配除了<span class="string">&quot;字符集合&quot;</span>以外的任何一个字符</span><br><span class="line">S1|S2|S3      匹配S1, S2和S3中的任意一个字符串</span><br><span class="line">*             代表多个该符号之前的字符, 包括0和1个</span><br><span class="line">+             代表多个该符号之前的字符, 包括1个</span><br><span class="line">字符串&#123;N&#125;     字符串出现N次</span><br><span class="line">字符串&#123;M,N&#125;   字符串出现至少M次, 最多N次</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; SELECT student.id name, sex, birth, department address, c_name, grade FROM student, score WHERE (name LIKE <span class="string">&#x27;张%&#x27;</span> OR name LIKE <span class="string">&#x27;王%&#x27;</span>) AND student.id=score.stu_id;</span><br><span class="line">+------+------+-------+--------------+-----------+-------+</span><br><span class="line">| name | sex  | birth | address      | c_name    | grade |</span><br><span class="line">+------+------+-------+--------------+-----------+-------+</span><br><span class="line">|  901 | 男   |  1985 | 计算机系     | 计算机    |    98 |</span><br><span class="line">|  901 | 男   |  1985 | 计算机系     | 英语      |    80 |</span><br><span class="line">|  902 | 男   |  1986 | 中文系       | 计算机    |    65 |</span><br><span class="line">|  902 | 男   |  1986 | 中文系       | 中文      |    88 |</span><br><span class="line">|  903 | 女   |  1990 | 中文系       | 中文      |    95 |</span><br><span class="line">|  905 | 女   |  1991 | 英语系       | 英语      |    94 |</span><br><span class="line">|  906 | 男   |  1988 | 计算机系     | 计算机    |    90 |</span><br><span class="line">|  906 | 男   |  1988 | 计算机系     | 英语      |    85 |</span><br><span class="line">+------+------+-------+--------------+-----------+-------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 先从student表中删除id为902和903两行, 方便下面区分</span></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from student;</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| <span class="built_in">id</span>  | name      | sex  | birth | department   | address            |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">| 901 | 张老大    | 男   |  1985 | 计算机系     | 北京市海淀区       |</span><br><span class="line">| 904 | 李四      | 男   |  1990 | 英语系       | 辽宁省阜新市       |</span><br><span class="line">| 905 | 王五      | 女   |  1991 | 英语系       | 福建省厦门市       |</span><br><span class="line">| 906 | 王六      | 男   |  1988 | 计算机系     | 湖南省衡阳市       |</span><br><span class="line">+-----+-----------+------+-------+--------------+--------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from score;</span><br><span class="line">+----+--------+-----------+-------+</span><br><span class="line">| <span class="built_in">id</span> | stu_id | c_name    | grade |</span><br><span class="line">+----+--------+-----------+-------+</span><br><span class="line">|  1 |    901 | 计算机    |    98 |</span><br><span class="line">|  2 |    901 | 英语      |    80 |</span><br><span class="line">|  3 |    902 | 计算机    |    65 |</span><br><span class="line">|  4 |    902 | 中文      |    88 |</span><br><span class="line">|  5 |    903 | 中文      |    95 |</span><br><span class="line">|  6 |    904 | 计算机    |    70 |</span><br><span class="line">|  7 |    904 | 英语      |    92 |</span><br><span class="line">|  8 |    905 | 英语      |    94 |</span><br><span class="line">|  9 |    906 | 计算机    |    90 |</span><br><span class="line">| 10 |    906 | 英语      |    85 |</span><br><span class="line">+----+--------+-----------+-------+</span><br><span class="line">10 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内连接查询</span></span><br><span class="line">MariaDB [carltest]&gt; SELECT student.id name, sex, birth, department, address, c_name grade FROM student, score WHERE student.id=score.stu_id;</span><br><span class="line">+------+------+-------+--------------+--------------------+-----------+</span><br><span class="line">| name | sex  | birth | department   | address            | grade     |</span><br><span class="line">+------+------+-------+--------------+--------------------+-----------+</span><br><span class="line">|  901 | 男   |  1985 | 计算机系     | 北京市海淀区       | 计算机    |</span><br><span class="line">|  901 | 男   |  1985 | 计算机系     | 北京市海淀区       | 英语      |</span><br><span class="line">|  904 | 男   |  1990 | 英语系       | 辽宁省阜新市       | 计算机    |</span><br><span class="line">|  904 | 男   |  1990 | 英语系       | 辽宁省阜新市       | 英语      |</span><br><span class="line">|  905 | 女   |  1991 | 英语系       | 福建省厦门市       | 英语      |</span><br><span class="line">|  906 | 男   |  1988 | 计算机系     | 湖南省衡阳市       | 计算机    |</span><br><span class="line">|  906 | 男   |  1988 | 计算机系     | 湖南省衡阳市       | 英语      |</span><br><span class="line">+------+------+-------+--------------+--------------------+-----------+</span><br><span class="line">7 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给student和score起个别名</span></span><br><span class="line">MariaDB [carltest]&gt; SELECT s1.id name, sex, birth, department, address, c_name grade FROM student s1, score s2 WHERE s1.id=s2.stu_id;</span><br><span class="line">+------+------+-------+--------------+--------------------+-----------+</span><br><span class="line">| name | sex  | birth | department   | address            | grade     |</span><br><span class="line">+------+------+-------+--------------+--------------------+-----------+</span><br><span class="line">|  901 | 男   |  1985 | 计算机系     | 北京市海淀区       | 计算机    |</span><br><span class="line">|  901 | 男   |  1985 | 计算机系     | 北京市海淀区       | 英语      |</span><br><span class="line">|  904 | 男   |  1990 | 英语系       | 辽宁省阜新市       | 计算机    |</span><br><span class="line">|  904 | 男   |  1990 | 英语系       | 辽宁省阜新市       | 英语      |</span><br><span class="line">|  905 | 女   |  1991 | 英语系       | 福建省厦门市       | 英语      |</span><br><span class="line">|  906 | 男   |  1988 | 计算机系     | 湖南省衡阳市       | 计算机    |</span><br><span class="line">|  906 | 男   |  1988 | 计算机系     | 湖南省衡阳市       | 英语      |</span><br><span class="line">+------+------+-------+--------------+--------------------+-----------+</span><br><span class="line">7 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外连接查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LEFT JOIN, 返回student所有的数据</span></span><br><span class="line">MariaDB [carltest]&gt; SELECT student.id, c_name FROM student LEFT JOIN  score on student.id=score.stu_id;</span><br><span class="line">+-----+-----------+</span><br><span class="line">| <span class="built_in">id</span>  | c_name    |</span><br><span class="line">+-----+-----------+</span><br><span class="line">| 901 | 计算机    |</span><br><span class="line">| 901 | 英语      |</span><br><span class="line">| 904 | 计算机    |</span><br><span class="line">| 904 | 英语      |</span><br><span class="line">| 905 | 英语      |</span><br><span class="line">| 906 | 计算机    |</span><br><span class="line">| 906 | 英语      |</span><br><span class="line">+-----+-----------+</span><br><span class="line">7 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RIGHT JOIN, 返回score所有的数据</span></span><br><span class="line">MariaDB [carltest]&gt; SELECT student.id, c_name FROM student RIGHT JOIN  score on student.id=score.stu_id;</span><br><span class="line">+------+-----------+</span><br><span class="line">| <span class="built_in">id</span>   | c_name    |</span><br><span class="line">+------+-----------+</span><br><span class="line">|  901 | 计算机    |</span><br><span class="line">|  901 | 英语      |</span><br><span class="line">| NULL | 计算机    |</span><br><span class="line">| NULL | 中文      |</span><br><span class="line">| NULL | 中文      |</span><br><span class="line">|  904 | 计算机    |</span><br><span class="line">|  904 | 英语      |</span><br><span class="line">|  905 | 英语      |</span><br><span class="line">|  906 | 计算机    |</span><br><span class="line">|  906 | 英语      |</span><br><span class="line">+------+-----------+</span><br><span class="line">10 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="插入-更新-删除数据"><a href="#插入-更新-删除数据" class="headerlink" title="插入, 更新, 删除数据"></a>插入, 更新, 删除数据</h2><h5 id="先建一张表-接下来用来操作"><a href="#先建一张表-接下来用来操作" class="headerlink" title="先建一张表, 接下来用来操作"></a>先建一张表, 接下来用来操作</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; CREATE TABLE food (<span class="built_in">id</span> INT(10) NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    -&gt;                    name VARCHAR(20) NOT NULL,</span><br><span class="line">    -&gt;                    company VARCHAR(30) NOT NULL,</span><br><span class="line">    -&gt;                    price FLOAT,</span><br><span class="line">    -&gt;                    produce_time YEAR,</span><br><span class="line">    -&gt;                    validity_time INT(4),</span><br><span class="line">    -&gt;                    address VARCHAR(50));</span><br><span class="line">Query OK, 0 rows affected (0.31 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; desc food;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| <span class="built_in">id</span>            | int(10)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| company       | varchar(30) | NO   |     | NULL    |                |</span><br><span class="line">| price         | <span class="built_in">float</span>       | YES  |     | NULL    |                |</span><br><span class="line">| produce_time  | year(4)     | YES  |     | NULL    |                |</span><br><span class="line">| validity_time | int(4)      | YES  |     | NULL    |                |</span><br><span class="line">| address       | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">7 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.09 sec)</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h5 id="INSERT语句中不指定具体的字段名"><a href="#INSERT语句中不指定具体的字段名" class="headerlink" title="INSERT语句中不指定具体的字段名"></a>INSERT语句中不指定具体的字段名</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INSERT INTO tbl VALUES (值1, 值2, ..., 值n)</span></span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; INSERT INTO food VALUES (1, <span class="string">&#x27;AA饼干&#x27;</span>, <span class="string">&#x27;AA饼干厂&#x27;</span>, 2.5, <span class="string">&#x27;2008&#x27;</span>, 3, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">|  1 | AA饼干   | AA饼干厂    |   2.5 |         2008 |             3 | 北京    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="插入指定列"><a href="#插入指定列" class="headerlink" title="插入指定列"></a>插入指定列</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INSERT INTO tbl (属性1, 属性2, ..., 属性m)</span></span><br><span class="line"><span class="comment">#         VALUES (值1, 值2, ..., 值m)</span></span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; INSERT INTO food (<span class="built_in">id</span>, name, company, price, produce_time, validity_time, address) VALUES (2, <span class="string">&#x27;CC牛奶&#x27;</span>, <span class="string">&#x27;CC牛奶厂&#x27;</span>, 3.5, <span class="string">&#x27;2009&#x27;</span>, 1, <span class="string">&#x27;河北&#x27;</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">|  1 | AA饼干   | AA饼干厂    |   2.5 |         2008 |             3 | 北京    |</span><br><span class="line">|  2 | CC牛奶   | CC牛奶厂    |   3.5 |         2009 |             1 | 河北    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="同时插入多行数据"><a href="#同时插入多行数据" class="headerlink" title="同时插入多行数据"></a>同时插入多行数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INSERT INTO tbl [(属性列表)]</span></span><br><span class="line"><span class="comment">#         VALUES (取值列表1), (取值列表2), ..., (取值列表n);</span></span><br><span class="line"></span><br><span class="line">INSERT INTO food VALUES (NULL, <span class="string">&#x27;EE果冻&#x27;</span>, <span class="string">&#x27;EE果冻厂&#x27;</span>, 1.5, <span class="string">&#x27;2007&#x27;</span>, 2, <span class="string">&#x27;北京&#x27;</span>),</span><br><span class="line">                        (NULL, <span class="string">&#x27;FF咖啡&#x27;</span>, <span class="string">&#x27;FF咖啡厂&#x27;</span>, 20, <span class="string">&#x27;2002&#x27;</span>, 5, <span class="string">&#x27;天津&#x27;</span>),</span><br><span class="line">                        (NULL, <span class="string">&#x27;GG奶糖&#x27;</span>, <span class="string">&#x27;GG奶糖厂&#x27;</span>, 14, <span class="string">&#x27;2003&#x27;</span>, 3, <span class="string">&#x27;广东&#x27;</span>);</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; INSERT INTO food VALUES (NULL, <span class="string">&#x27;EE果冻&#x27;</span>, <span class="string">&#x27;EE果冻厂&#x27;</span>, 1.5, <span class="string">&#x27;2007&#x27;</span>, 2, <span class="string">&#x27;北京&#x27;</span>),</span><br><span class="line">    -&gt;                         (NULL, <span class="string">&#x27;FF咖啡&#x27;</span>, <span class="string">&#x27;FF咖啡厂&#x27;</span>, 20, <span class="string">&#x27;2002&#x27;</span>, 5, <span class="string">&#x27;天津&#x27;</span>),</span><br><span class="line">    -&gt;                         (NULL, <span class="string">&#x27;GG奶糖&#x27;</span>, <span class="string">&#x27;GG奶糖厂&#x27;</span>, 14, <span class="string">&#x27;2003&#x27;</span>, 3, <span class="string">&#x27;广东&#x27;</span>);</span><br><span class="line">Query OK, 3 rows affected (0.01 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">|  1 | AA饼干   | AA饼干厂    |   2.5 |         2008 |             3 | 北京    |</span><br><span class="line">|  2 | CC牛奶   | CC牛奶厂    |   3.5 |         2009 |             1 | 河北    |</span><br><span class="line">|  3 | EE果冻   | EE果冻厂    |   1.5 |         2007 |             2 | 北京    |</span><br><span class="line">|  4 | FF咖啡   | FF咖啡厂    |    20 |         2002 |             5 | 天津    |</span><br><span class="line">|  5 | GG奶糖   | GG奶糖厂    |    14 |         2003 |             3 | 广东    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="将查询结果插入到表中"><a href="#将查询结果插入到表中" class="headerlink" title="将查询结果插入到表中"></a>将查询结果插入到表中</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INSERT INTO tbl1 (属性列表1)</span></span><br><span class="line"><span class="comment">#        SELECT 属性列表2 FROM tbl2 WHERE 条件表达式;</span></span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; desc food1;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| <span class="built_in">id</span>            | int(10)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| company       | varchar(30) | NO   |     | NULL    |                |</span><br><span class="line">| price         | <span class="built_in">float</span>       | YES  |     | NULL    |                |</span><br><span class="line">| produce_time  | year(4)     | YES  |     | NULL    |                |</span><br><span class="line">| validity_time | int(4)      | YES  |     | NULL    |                |</span><br><span class="line">| address       | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">7 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.12 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; INSERT INTO food1 SELECT * FROM  food;</span><br><span class="line">Query OK, 5 rows affected (0.01 sec)</span><br><span class="line">Records: 5  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food1;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">|  1 | AA饼干   | AA饼干厂    |   2.5 |         2008 |             3 | 北京    |</span><br><span class="line">|  2 | CC牛奶   | CC牛奶厂    |   3.5 |         2009 |             1 | 河北    |</span><br><span class="line">|  3 | EE果冻   | EE果冻厂    |   1.5 |         2007 |             2 | 北京    |</span><br><span class="line">|  4 | FF咖啡   | FF咖啡厂    |    20 |         2002 |             5 | 天津    |</span><br><span class="line">|  5 | GG奶糖   | GG奶糖厂    |    14 |         2003 |             3 | 广东    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UPDATE tbl SET 属性1=值1, 属性2=值2, ..., 属性n=值n WHERE 条件表达式</span></span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food <span class="built_in">where</span> name=<span class="string">&#x27;CC牛奶&#x27;</span>;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">|  2 | CC牛奶   | CC牛奶厂    |   3.5 |         2009 |             1 | 河北    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; update food <span class="built_in">set</span> address=<span class="string">&#x27;内蒙古&#x27;</span>, price=3.2 <span class="built_in">where</span> name=<span class="string">&#x27;CC牛奶&#x27;</span>;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food <span class="built_in">where</span> name=<span class="string">&#x27;CC牛奶&#x27;</span>;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+-----------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address   |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+-----------+</span><br><span class="line">|  2 | CC牛奶   | CC牛奶厂    |   3.2 |         2009 |             1 | 内蒙古    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+-----------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DELETE FROM tbl [WHERE 条件表达式]</span></span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food <span class="built_in">where</span> address=<span class="string">&#x27;北京&#x27;</span>;</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">| <span class="built_in">id</span> | name     | company     | price | produce_time | validity_time | address |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">|  1 | AA饼干   | AA饼干厂    |   2.5 |         2008 |             3 | 北京    |</span><br><span class="line">|  3 | EE果冻   | EE果冻厂    |   1.5 |         2007 |             2 | 北京    |</span><br><span class="line">+----+----------+-------------+-------+--------------+---------------+---------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; delete from food <span class="built_in">where</span> address=<span class="string">&#x27;北京&#x27;</span>;</span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; <span class="keyword">select</span> * from food <span class="built_in">where</span> address=<span class="string">&#x27;北京&#x27;</span>;</span><br><span class="line">Empty <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="表结构修改"><a href="#表结构修改" class="headerlink" title="表结构修改"></a>表结构修改</h2><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_book rename to bbb;</span><br></pre></td></tr></table></figure>

<h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table 表名 add column 列名 varchar(30);</span><br></pre></td></tr></table></figure>

<h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 新数据类型 新类型长度 新默认值 新注释;</span><br><span class="line"></span><br><span class="line">alter table 表名 change 旧字段名 新字段名 新数据类型;</span><br></pre></td></tr></table></figure>

<h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop column 列名;</span><br></pre></td></tr></table></figure>

<h3 id="修改unique-key"><a href="#修改unique-key" class="headerlink" title="修改unique key"></a>修改unique key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table table_name drop index `uk_name`;</span><br><span class="line">alter table table_name add unique key `new_uk_name` (`col1`,`col2`);</span><br></pre></td></tr></table></figure>

<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>MySQL中权限分配是按照user表, db表, tables_priv表和columns_priv表的顺序进行分配的. 数据库系统中, 先判断user表中的值为Y.<br>如果user表中的值为Y, 就不需要检查后面的表. 如果user表的为N, 则依次检查db表, tables_priv表和columns_priv表</p>
<h3 id="mysql-user表"><a href="#mysql-user表" class="headerlink" title="mysql.user表"></a>mysql.user表</h3><h5 id="权限列中有很多权限字段需要特别注意"><a href="#权限列中有很多权限字段需要特别注意" class="headerlink" title="权限列中有很多权限字段需要特别注意:"></a>权限列中有很多权限字段需要特别注意:</h5><table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Grant_priv</td>
<td>表示是否拥有GRANT权限</td>
</tr>
<tr>
<td>Shutdown_priv</td>
<td>表示是否拥有停止MySQL的权限</td>
</tr>
<tr>
<td>Super_priv</td>
<td>表示是否拥有超级权限</td>
</tr>
<tr>
<td>Execute_priv</td>
<td>表示是否有EXECUTE权限, 该权限可以执行存储过程和函数</td>
</tr>
</tbody></table>
<h5 id="user表的资源控制列"><a href="#user表的资源控制列" class="headerlink" title="user表的资源控制列"></a>user表的资源控制列</h5><table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max_questions</td>
<td>每小时可以允许执行多少次查询</td>
</tr>
<tr>
<td>max_updates</td>
<td>每小时可以允许执行多少次更新</td>
</tr>
<tr>
<td>max_connections</td>
<td>每小时可以建立多少连接</td>
</tr>
<tr>
<td>max_user_connections</td>
<td>每个用户可以同时具有的连接数.</td>
</tr>
</tbody></table>
<p>以上每个字段默认值为0, 表示没有限制</p>
<h3 id="用户账号相关"><a href="#用户账号相关" class="headerlink" title="用户账号相关"></a>用户账号相关</h3><h5 id="新建普通用户"><a href="#新建普通用户" class="headerlink" title="新建普通用户"></a>新建普通用户</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CREATE USER user [IDENTIFIED BY [PASSWORD] &#x27;passwd&#x27;] [, user [IDENTIFIED BY [PASSWORD] &#x27;passwd&#x27;]] ...</span></span><br><span class="line"><span class="comment"># GRANT priv_type ON databse.table TO user [IDENTIFIED BY [PASSWORD] &#x27;passwd&#x27;] [, user [IDENTIFIED BY [PASSWORD] &#x27;passwd&#x27;]] ...</span></span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; create user <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;test1_password&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.27 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; GRANT SELECT ON carltest.* TO <span class="string">&#x27;test3&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;test3&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure>

<h5 id="删除普通用户"><a href="#删除普通用户" class="headerlink" title="删除普通用户"></a>删除普通用户</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DROP USER user [, user] ...</span></span><br><span class="line"><span class="comment"># DELETE FROM mysql.user WHERE Host=&#x27;localhost&#x27; AND User=&#x27;username&#x27;;</span></span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; DROP USER <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; DELETE FROM mysql.user WHERE Host=<span class="string">&#x27;localhost&#x27;</span> AND User=<span class="string">&#x27;test3&#x27;</span>;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure>

<h5 id="root用户修改root用户的密码"><a href="#root用户修改root用户的密码" class="headerlink" title="root用户修改root用户的密码"></a>root用户修改root用户的密码</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysqladmin -u $username -p password &quot;new_password&quot;;</span></span><br><span class="line"><span class="comment"># update mysql.user set Password=PASSWORD(&#x27;new_password&#x27;) where User=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;</span></span><br><span class="line"><span class="comment"># SET PASSWORD=PASSWORD(&#x27;new_password&#x27;);</span></span><br></pre></td></tr></table></figure>

<h5 id="root用户修改普通用户密码"><a href="#root用户修改普通用户密码" class="headerlink" title="root用户修改普通用户密码"></a>root用户修改普通用户密码</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=PASSWORD(&#x27;new_password&#x27;);</span></span><br><span class="line"><span class="comment"># UPDATE mysql.user SET Password=PASSWORD(&#x27;mytest2&#x27;) WHERE User=&#x27;test3&#x27; AND Host=&#x27;localhost&#x27;;</span></span><br><span class="line"><span class="comment"># GRANT priv_type ON database.table TO user [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;];</span></span><br><span class="line">&gt; GRANT SELECT ON *.* TO <span class="string">&#x27;test3&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;mytest3&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="普通用户修改密码"><a href="#普通用户修改密码" class="headerlink" title="普通用户修改密码"></a>普通用户修改密码</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SET PASSWORD=PASSWORD(&#x27;new_password&#x27;);</span></span><br></pre></td></tr></table></figure>

<h3 id="MySQL的各种权限"><a href="#MySQL的各种权限" class="headerlink" title="MySQL的各种权限"></a>MySQL的各种权限</h3><table>
<thead>
<tr>
<th>权限名称</th>
<th>对应user表中的列</th>
<th>权限的范围</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE</td>
<td>Create_priv</td>
<td>数据库, 表或索引</td>
</tr>
<tr>
<td>DROP</td>
<td>Drop_priv</td>
<td>数据库, 表</td>
</tr>
<tr>
<td>GRANT OPTION</td>
<td>Grant_priv</td>
<td>数据库, 表, 存储过程, 函数</td>
</tr>
<tr>
<td>REFERENCES</td>
<td>References_priv</td>
<td>数据库, 表</td>
</tr>
<tr>
<td>ALTER</td>
<td>Alter_priv</td>
<td>修改表</td>
</tr>
<tr>
<td>DELETE</td>
<td>Delete_priv</td>
<td>删除表</td>
</tr>
<tr>
<td>INDEX</td>
<td>Index_priv</td>
<td>用索引查询表</td>
</tr>
<tr>
<td>INSERT</td>
<td>Insert_priv</td>
<td>插入表</td>
</tr>
<tr>
<td>SELECT</td>
<td>Select_priv</td>
<td>查询表</td>
</tr>
<tr>
<td>UPDATE</td>
<td>Update_priv</td>
<td>更新表</td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>Create_view_priv</td>
<td>创建视图</td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>Show_view_priv</td>
<td>查看视图</td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>Alter_routine_priv</td>
<td>修改存储过程或存储函数</td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>Create_routine_priv</td>
<td>创建存储过程或存储函数</td>
</tr>
<tr>
<td>EXECUTE</td>
<td>Execute_priv</td>
<td>执行存储过程或存储函数</td>
</tr>
<tr>
<td>FILE</td>
<td>File_priv</td>
<td>加载服务器主机上的文件</td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>Create_tmp_table_priv</td>
<td>创建临时表</td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>Lock_tables_priv</td>
<td>锁定表</td>
</tr>
<tr>
<td>CREATE USER</td>
<td>Create_user_priv</td>
<td>创建用户</td>
</tr>
<tr>
<td>PROCESS</td>
<td>Process_priv</td>
<td>服务器管理</td>
</tr>
<tr>
<td>RELOAD</td>
<td>Reload_priv</td>
<td>重新加载权限表</td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>Repl_client_priv</td>
<td>服务器管理</td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>Repl_slave_priv</td>
<td>服务器管理</td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>Show_db_priv</td>
<td>查看数据库</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>Shutdown_priv</td>
<td>关闭服务器</td>
</tr>
<tr>
<td>SUPER</td>
<td>Super_priv</td>
<td>超级权限</td>
</tr>
</tbody></table>
<h3 id="授权与收回权限"><a href="#授权与收回权限" class="headerlink" title="授权与收回权限"></a>授权与收回权限</h3><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GRANT priv_type [(column_list)] ON database.table TO user [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;]</span></span><br><span class="line"><span class="comment">#     [, user [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;]] ... [WITH with_option [with_option] ...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with_option有几个权限值可选</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># - GRANT OPTION: 被授权的用户可以将这些权限赋予给别的用户</span></span><br><span class="line"><span class="comment"># - MAX_QUERIES_PER_HOUR count: 设置每小时可以允许执行count次查询</span></span><br><span class="line"><span class="comment"># - MAX_UPDATES_PER_HOUR count: 设置每小时可以允许执行count次更新</span></span><br><span class="line"><span class="comment"># - MAX_CONNECTIONS_PER_HOUR count: 设置每小时可以建立count连接</span></span><br><span class="line"><span class="comment"># - MAX_USER_CONNECTIONS count: 设置单个用户可以同时具有的count个连接数</span></span><br><span class="line"></span><br><span class="line">&gt; GRANT SELECT, UPDATE ON *.* TO <span class="string">&#x27;test5&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;test5&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<h5 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REVOKE priv_type [(column_list)] ... ON database.table FROM user [, user] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收回全部权限</span></span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...</span><br></pre></td></tr></table></figure>

<h5 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM mysql.user <span class="built_in">where</span> User=<span class="string">&#x27;xxxx&#x27;</span> and Host=<span class="string">&#x27;yyyy&#x27;</span>;</span><br><span class="line">&gt; SHOW GRANTS FOR <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数据备份与还原"><a href="#数据备份与还原" class="headerlink" title="数据备份与还原"></a>数据备份与还原</h2><h3 id="使用mysqldump命令备份"><a href="#使用mysqldump命令备份" class="headerlink" title="使用mysqldump命令备份"></a>使用mysqldump命令备份</h3><h5 id="备份一个数据库"><a href="#备份一个数据库" class="headerlink" title="备份一个数据库"></a>备份一个数据库</h5><p><code>mysqldump -u username -p dbname table1 table2 ... &gt; backup_name.sql</code></p>
<blockquote>
<p>不指定table1, table2时, 表示备份整个db</p>
</blockquote>
<h5 id="备份多个数据库"><a href="#备份多个数据库" class="headerlink" title="备份多个数据库"></a>备份多个数据库</h5><p><code>mysqldump -u username -p --databases dbname1 dbname2 ... &gt; backup_name.sql</code></p>
<h5 id="备份所有数据库"><a href="#备份所有数据库" class="headerlink" title="备份所有数据库"></a>备份所有数据库</h5><p><code>mysqldump -u username -p --all-databases &gt; backup_name.sql</code></p>
<h3 id="直接复制整个数据库目录"><a href="#直接复制整个数据库目录" class="headerlink" title="直接复制整个数据库目录"></a>直接复制整个数据库目录</h3><ul>
<li>这种方法最简单, 最快速, 但是使用这种方法最好将服务器先停止, 以保证在复制期间数据不发生变化.</li>
<li>这种方法对InnoDB存储引擎的表不适用, 只适用于MyISAM表</li>
<li>还原时最好是相同版本的MySQL数据库, 否则可能存在文件类型不同的情况</li>
</ul>
<h3 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h3><h5 id="使用mysql命令还原"><a href="#使用mysql命令还原" class="headerlink" title="使用mysql命令还原"></a>使用mysql命令还原</h5><p><code>mysql -u root -p [dbname] &lt; backup_name.sql</code></p>
<blockquote>
<ol>
<li>指定dbname, 表示还原该数据库下的表</li>
<li>不指定dbname, 表示还原sql中的所有数据库</li>
</ol>
</blockquote>
<h5 id="直接复制整个数据库目录-1"><a href="#直接复制整个数据库目录-1" class="headerlink" title="直接复制整个数据库目录"></a>直接复制整个数据库目录</h5><p>使用这个方式进行还原, 有上述使用该种方式备份时的种种限制, 请慎用</p>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h hostname1 -u root --password=password1 --all-databases | mysql -h hostname2 -u root --password=password2</span><br></pre></td></tr></table></figure>

<h3 id="表的导入导出"><a href="#表的导入导出" class="headerlink" title="表的导入导出"></a>表的导入导出</h3><h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SELECT [列名] FROM table [WHERE 语句] INTO OUTFILE &#x27;目标文件&#x27; [OPTION]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># OPTION常用选项值</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># - FIELDS TERMINATED BY &#x27;字符串&#x27;: 设置字符串为字段的分隔符, 默认是&#x27;\t&#x27;</span></span><br><span class="line"><span class="comment"># - FIELDS ENCLOSED BY &#x27;字符&#x27;: 设置字符来括上字段的值, 默认不使用任何符号</span></span><br><span class="line"><span class="comment"># - FIELDS OPTIONALLY ENCLOSED BY &#x27;字符&#x27;: 设置字符来括上CHAR, VARCHAR和TEXT等字符型字段, 默认不使用任何符号</span></span><br><span class="line"><span class="comment"># - LINES STARTING BY &#x27;字符串&#x27;: 设置每行开头的字符, 默认情况不使用任何字符</span></span><br><span class="line"><span class="comment"># - FIELDS ESCAPED BY &#x27;字符&#x27;: 设置转移字符, 默认为&#x27;\&#x27;</span></span><br><span class="line"><span class="comment"># - LINES TERMINATED BY &#x27;字符串&#x27;: 设置每行的结束符, 默认值是&#x27;\n&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SELECT * FROM test.student INTO OUTFILE &#x27;/tmp/test.txt&#x27;</span></span><br><span class="line"><span class="comment">#     FIELDS TERMINATED BY &#x27;\,&#x27; OPTIONALLY ENCLOSED BY &#x27;\&quot;&#x27; LINES STARTING BY &#x27;\&gt;&#x27;</span></span><br><span class="line"><span class="comment">#     TERMINATED BY &#x27;\r\n&#x27;;</span></span><br></pre></td></tr></table></figure>

<h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LOAD DATA [LOCAL] INFILE file INTO TABLE table [OPTION];</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># OPTION常用选项值</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># - 导出小节所列选项值</span></span><br><span class="line"><span class="comment"># - IGNORE n LINES: 忽略文件的前n行记录;</span></span><br><span class="line"><span class="comment"># - (字段列表): 根据字段列表中的字段和顺序来加载记录</span></span><br><span class="line"><span class="comment"># - SET column=expr: 将制定的列column进行相应地转换后再加载, 使用expr表达式来进行转换</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LODA DATA INFILE &#x27;/tmp/test.txt&#x27; INTO TABLE test.student FIELDS TERMINATED BY &#x27;,&#x27; OPTIONALLY ENCLOSED BY &quot;&#x27;&quot;;</span></span><br></pre></td></tr></table></figure>

<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>除了bin log, 其余日志都是文本文件</p>
<p>默认情况只启用错误日志err log, 其他3类日志都需要数据库管理员进行设置</p>
<blockquote>
<p>如果MySQL数据库系统意外停止服务, 可以通过错误日志查看出现错误的原因. 并且, 可以通过bin log文件来查看用户执行了哪些操作<br>, 对数据库文件做了哪些修改. 然后, 可以根据bin log中的记录来修复数据库</p>
<p>但是, 启动log功能会降低MySQL数据库的执行速度. 例如, 一个查询操作比较频繁的MySQL中, 记录通用查询日志和慢查询日志要花费<br>很多的时间. 并且, log文件会占用大量的硬盘空间. 对于用户量非常大, 操作非常频繁的数据库, 日志文件需要的存储空间甚至比数<br>据库文件需要的存储空间还要大.</p>
</blockquote>
<h3 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h3><p>也叫update log, 主要用于记录数据库的变化情况. 通过bin log可以查询MySQL数据库进行了哪些改变.</p>
<h5 id="启动和设置bin-log"><a href="#启动和设置bin-log" class="headerlink" title="启动和设置bin log"></a>启动和设置bin log</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">log-bin [=DIR \ [filename]]</span><br><span class="line"></span><br><span class="line">DIR: 指定bin <span class="built_in">log</span>的存储路径</span><br><span class="line">filename: 指定bin <span class="built_in">log</span>的文件名, 其形式为filename.number, 例如filename.000001, filename.000002等. 每次重启MySQL服务, 都会</span><br><span class="line">生成一个新的bin <span class="built_in">log</span>文件. 这些bin <span class="built_in">log</span>文件的<span class="string">&#x27;number&#x27;</span>会不断递增. 除了生成上述文件外, 还会生成一个名为filename.index的文件.</span><br><span class="line">这个文件中存储所有bin <span class="built_in">log</span>文件的清单.</span><br><span class="line"></span><br><span class="line">如果没有指定DIR, filename, bin <span class="built_in">log</span>将默认存储在数据库的数据目录下, 默认的文件名为hostname-bin.number, 其中hostname为主机</span><br><span class="line">名.</span><br></pre></td></tr></table></figure>

<p>bin log与数据库的数据文件最好不要放在同一块硬盘上. 即使数据文件所在的硬盘被破坏, 也可以使用另一块硬盘上的bin log来回复数<br>据文件. 两块硬盘同时坏了的可能性要小得多. 这样可以保证数据库中数据的安全.</p>
<h5 id="查看bin-log"><a href="#查看bin-log" class="headerlink" title="查看bin log"></a>查看bin log</h5><p><code>mysqlbinlog filename.number</code></p>
<h5 id="使用bin-log来还原数据库"><a href="#使用bin-log来还原数据库" class="headerlink" title="使用bin log来还原数据库"></a>使用bin log来还原数据库</h5><p><code>mysqlbinlog filename.number | mysql -u root -p</code></p>
<p>注意, 编号(number)小的文件开始还原</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mylog.00001 | mysql -u root -p</span><br><span class="line">mysqlbinlog mylog.00002 | mysql -u root -p</span><br><span class="line">mysqlbinlog mylog.00003 | mysql -u root -p</span><br><span class="line">mysqlbinlog mylog.00004 | mysql -u root -p</span><br></pre></td></tr></table></figure>

<h5 id="暂停和重启bin-log功能"><a href="#暂停和重启bin-log功能" class="headerlink" title="暂停和重启bin log功能"></a>暂停和重启bin log功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET SQL_LOG_BIN=0; <span class="comment"># 暂停</span></span><br><span class="line">SET SQL_LOG_BIN=1; <span class="comment"># 重新启用</span></span><br></pre></td></tr></table></figure>

<h3 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h3><p>err log是默认开启的, 并且无法被禁止. 默认存储路径为数据库的数据文件夹. 文件名通常为hostname.err.</p>
<p>存储路径可以通过 <code>log-error</code>选项来设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">log-error=DIR [/ filename]</span><br></pre></td></tr></table></figure>

<h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>通用查询日志是用来记录用户的所有操作, 包括启动和关闭MySQL服务, 更新语句和查询语句等.</p>
<p>默认文件名为hostname.log, 默认存储路径为数据库的数据文件夹.</p>
<p>默认情况下, 通用查询日志功能是关闭的. 可以通过下面方式设置开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span> [=DIR \ [filename]]</span><br></pre></td></tr></table></figure>

<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志是用来记录执行时间超过指定时间的查询语句. 通过慢查询日志, 可以查找出哪些查询语句的执行效率很低, 以便进行优化.</p>
<p>默认该日志是关闭的. 默认存储路径为数据库的数据文件夹, 默认文件名为hostname-slow.log</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">log-slow-queries [=DIR \ [filename]]</span><br><span class="line">long_query_time=n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行时间超过n秒的语句会被记录下来, n不设置的话, 默认是10s</span></span><br></pre></td></tr></table></figure>

<h2 id="性能优化的有关概念"><a href="#性能优化的有关概念" class="headerlink" title="性能优化的有关概念"></a>性能优化的有关概念</h2><h3 id="优化简介"><a href="#优化简介" class="headerlink" title="优化简介"></a>优化简介</h3><p>db管理员可以使用<code>SHOW STATUS</code>语句查询MySQL的性能.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SHOW STATUS LIKE <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"></span><br><span class="line">value是以下几个常用统计参数</span><br><span class="line"></span><br><span class="line">- Connections: 连接MySQL服务器的次数</span><br><span class="line">- Uptime: MySQL服务器的上线时间</span><br><span class="line">- Slow_queries: 慢查询的次数</span><br><span class="line">- Com_select: 查询操作的次数</span><br><span class="line">- Com_insert: 插入操作的次数</span><br><span class="line">- Com_update: 更新操作的次数</span><br><span class="line">- Com_delete: 删除操作的次数</span><br></pre></td></tr></table></figure>

<h3 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h3><h4 id="分析查询语句"><a href="#分析查询语句" class="headerlink" title="分析查询语句"></a>分析查询语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; EXPLAIN|DESCRIBE SELECT * FROM student \G;</span><br><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra:</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.24 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; desc <span class="keyword">select</span> * from student \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra:</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure>

<ul>
<li>id: 表示select语句的编号</li>
<li>select_type: 表示select语句的类型. SIMPLE表示简单查询, 其中不包括子查询和连接查询; PRIMARY表示主查询, 或者是最外层的<br>        查询语句; UNION表示连接查询的第二个或后面的查询语句</li>
<li>table: 表示查询的表</li>
<li>type: 表示表的连接类型<blockquote>
<ul>
<li>system: 表示表中只有一条记录</li>
<li>const: 表示表中有多条记录, 但是只从表中查询一条记录</li>
<li>ALL: 表示对表进行了完整的扫描;</li>
<li>eq_ref: 表示多表连接时, 后面的表使用了UNIQUE或PRIMARY KEY</li>
<li>ref: 表示多表查询时, 后面的表使用了普通索引;</li>
<li>unique_subquery: 表示子查询中使用了UNIQUE或PRIMARY KEY</li>
<li>index_subquery: 表示子查询中使用了普通索引</li>
<li>range: 表示查询语句中给出了查询范围</li>
<li>index: 表示对表中的索引进行了完整的扫描</li>
</ul>
</blockquote>
</li>
<li>possible_keys: 表示查询中可能使用的索引</li>
<li>key: 表示查询使用到的索引</li>
<li>key_len: 表示索引字段的长度</li>
<li>ref: 表示使用哪个列或常数与索引一起来查询记录</li>
<li>rows: 表示查询的行数</li>
<li>Extra: 表示查询过程的附件信息</li>
</ul>
<h4 id="使用索引查询"><a href="#使用索引查询" class="headerlink" title="使用索引查询"></a>使用索引查询</h4><h5 id="注意下面添加索引前后-两次插叙-rows的结果-一个为4-一个为1"><a href="#注意下面添加索引前后-两次插叙-rows的结果-一个为4-一个为1" class="headerlink" title="注意下面添加索引前后, 两次插叙 rows的结果, 一个为4, 一个为1."></a>注意下面添加索引前后, 两次插叙 <code>rows</code>的结果, 一个为4, 一个为1.</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> name=<span class="string">&quot;李四&quot;</span> \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using <span class="built_in">where</span></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; create index index_name on student(name);</span><br><span class="line">Query OK, 0 rows affected (0.44 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> name=<span class="string">&quot;李四&quot;</span> \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ref</span><br><span class="line">possible_keys: index_name</span><br><span class="line">          key: index_name</span><br><span class="line">      key_len: 62</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure>

<h5 id="LIKE关键字的使用方式-如果匹配字符串的第一个字符为’-’-索引不会被使用-否则-索引会被使用"><a href="#LIKE关键字的使用方式-如果匹配字符串的第一个字符为’-’-索引不会被使用-否则-索引会被使用" class="headerlink" title="LIKE关键字的使用方式. 如果匹配字符串的第一个字符为’%’, 索引不会被使用, 否则, 索引会被使用"></a>LIKE关键字的使用方式. 如果匹配字符串的第一个字符为’%’, 索引不会被使用, 否则, 索引会被使用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> name like <span class="string">&quot;%四&quot;</span> \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using <span class="built_in">where</span></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> name like <span class="string">&quot;李%&quot;</span> \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: range</span><br><span class="line">possible_keys: index_name</span><br><span class="line">          key: index_name</span><br><span class="line">      key_len: 62</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.06 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure>

<h5 id="多列索引的用法-只有查询条件中使用了这些字段中第一个字段时-索引才会被使用"><a href="#多列索引的用法-只有查询条件中使用了这些字段中第一个字段时-索引才会被使用" class="headerlink" title="多列索引的用法. 只有查询条件中使用了这些字段中第一个字段时, 索引才会被使用."></a>多列索引的用法. 只有查询条件中使用了这些字段中第一个字段时, 索引才会被使用.</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; create index index_birth_department on student(birth, department);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> birth=1991 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ref</span><br><span class="line">possible_keys: index_birth_department</span><br><span class="line">          key: index_birth_department</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra:</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> department=<span class="string">&quot;英语系&quot;</span> \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using <span class="built_in">where</span></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure>

<h5 id="OR关键字索引用法-OR前后两个条件的列都是索引时-查询将使用索引-只要有一列不是索引-那么查询就不会使用索引"><a href="#OR关键字索引用法-OR前后两个条件的列都是索引时-查询将使用索引-只要有一列不是索引-那么查询就不会使用索引" class="headerlink" title="OR关键字索引用法. OR前后两个条件的列都是索引时, 查询将使用索引. 只要有一列不是索引, 那么查询就不会使用索引"></a>OR关键字索引用法. OR前后两个条件的列都是索引时, 查询将使用索引. 只要有一列不是索引, 那么查询就不会使用索引</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> name=<span class="string">&#x27;王六&#x27;</span> or sex=<span class="string">&#x27;女&#x27;</span> \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: index_name</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using <span class="built_in">where</span></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line"><span class="comment"># id列是索引</span></span><br><span class="line">MariaDB [carltest]&gt; explain <span class="keyword">select</span> * from student <span class="built_in">where</span> name=<span class="string">&#x27;王六&#x27;</span> or <span class="built_in">id</span>=901 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: student</span><br><span class="line">         <span class="built_in">type</span>: ALL</span><br><span class="line">possible_keys: PRIMARY,index_name</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using <span class="built_in">where</span></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure>

<h5 id="MySQL参数优化"><a href="#MySQL参数优化" class="headerlink" title="MySQL参数优化"></a>MySQL参数优化</h5><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key_buffer_size</td>
<td>索引缓存的大小, 该值越大, 使用索引查询速度越快</td>
</tr>
<tr>
<td>table_cache</td>
<td>表示同时打开的表的个数. 该值越大, 能同时打开的表的个数越多. 但不是越大越好, 因为同时打开的表太多会影响操作系统的性能</td>
</tr>
<tr>
<td>query_cache_size</td>
<td>查询缓存区大小.</td>
</tr>
<tr>
<td>query_cache_type</td>
<td>查询缓冲区的开启状态. 0-关闭, 1-开启, 2-按要求使用</td>
</tr>
<tr>
<td>max_connections</td>
<td>数据库的最大连接数. 也不是越大越好, 太多连接会浪费内存资源</td>
</tr>
<tr>
<td>sort_buffer_size</td>
<td>排序缓冲区大小. 该值越大, 排序速度越快</td>
</tr>
<tr>
<td>innodb_buffer_pool_size</td>
<td>InnoDB类型的表和索引的最大缓存. 该值越大, 查询速度越快. 但是太大了也会影响系统性能</td>
</tr>
<tr>
<td>innodb_flush_log_at_trx_commit</td>
<td>0-每隔1s将数据写入log, 并将log写入磁盘; 1-每次提交事务时写log写磁盘; 2-每次提交事务时写log, 每隔1s将log写入磁盘, 默认值为1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>ssh终端证书方式登录远程linux系统</title>
    <url>/2020/12/28/ssh-without-passwd/</url>
    <content><![CDATA[<h3 id="为什么选择证书登陆？"><a href="#为什么选择证书登陆？" class="headerlink" title="为什么选择证书登陆？"></a>为什么选择证书登陆？</h3><p>Mac下原生及主流的ssh终端工具大多不具备保存ssh登陆密码的功能, 通过证书登陆的方式，就可以实现原生终端工具Terminal或第三方明星终端iTerm免密码登录远程系统，并且比单纯的密码验证登陆方式提高了安全性。</p>
<span id="more"></span>

<h3 id="配置过程（以下操作都在终端命令行下运行）"><a href="#配置过程（以下操作都在终端命令行下运行）" class="headerlink" title="配置过程（以下操作都在终端命令行下运行）"></a>配置过程（以下操作都在终端命令行下运行）</h3><ol>
<li><p>进入系统的ssh证书目录 cd ~&#x2F;.ssh&#x2F;</p>
</li>
<li><p>建立证书文件 ssh-keygen -t rsa 提示输入，直接回车即可。</p>
</li>
<li><p>输入 ls 命令查看当前目录会发现新生成的一对秘钥文件分别是：</p>
<p> 公钥：id_rsa.pub</p>
<p> 私钥：id_rsa</p>
</li>
<li><p>登陆到远程服务器，进入.ssh目录 cd ~&#x2F;.ssh</p>
<p> 将上面生成的公钥文件的内容copy进 authorized_keys 文件中</p>
</li>
<li><p>在Mac终端下执行登陆命令 ssh username@server</p>
<p> 即可免密码登录到远程服务器</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>绩效考核聊2块钱</title>
    <url>/2022/08/23/talk-kpi/</url>
    <content><![CDATA[<p>以下都是我个人的真实想法，不一定对，但我现在认为是对的。我努力朝着这个方向做，但是阻力不少。可能是有一些我认知达不到导致的见识浅薄，但是目前还没有人说服我哪里认知不对！希望有人能指出我以下写的不对的地方，让我少走点弯路，让团队少付出一些代价来获得更多的成长。</p>
<p>我们定绩效的目的是啥？</p>
<p>第一，肯定为了达成公司的整体目标，然后把员工的目标和公司的目标对齐；<br>第二，是通过绩效管理来实现目标，完成业绩，而不是为了逼走员工。</p>
<span id="more"></span>

<h2 id="那绩效目标如何定好，以及绩效考核如何做好，就有很多需要考虑的点"><a href="#那绩效目标如何定好，以及绩效考核如何做好，就有很多需要考虑的点" class="headerlink" title="那绩效目标如何定好，以及绩效考核如何做好，就有很多需要考虑的点"></a>那绩效目标如何定好，以及绩效考核如何做好，就有很多需要考虑的点</h2><ul>
<li>目标和结果是否合理？</li>
<li>激励有没有做到位？<ul>
<li>有没有向奋斗者倾斜？</li>
<li>有没有让雷锋吃亏？</li>
<li>抑或是吃的大锅饭，大家干得好、干得差都是一个样子？</li>
</ul>
</li>
</ul>
<h3 id="那绩效考核怎么才算做得好呢？"><a href="#那绩效考核怎么才算做得好呢？" class="headerlink" title="那绩效考核怎么才算做得好呢？"></a>那绩效考核怎么才算做得好呢？</h3><p>我认为就很简单一句话，<strong>让优秀的同事得到正向激励，让差劲的同事得到负向激励甚至淘汰，最终让团队不断地正向循环，更加优秀。</strong></p>
<p>我们围绕绩效考核做的所有的事情，都应该是促使团队不断地迭代到更优秀的状态，最起码也应该不向更差的方向迭代，维持好当下的水准。有任何影响团队士气，导致团队退步的行为，都应该是需要反思的！团队如果氛围不好，战斗力长期低下，那么有问题的一定是leader，绝不可能是团队。反过来，团队战斗力高企，各种攻城略地，并不一定是leader的功劳，例如创业初期的富途，是叶子哥把大家凝聚到一起，大家都相信这个事情能成，那个阶段的团队，leader有没有可能都没那么重要，大家都会斗志昂扬。</p>
<h3 id="团队在不同的阶段，想要变得更好，需要鼓励的行为是不同"><a href="#团队在不同的阶段，想要变得更好，需要鼓励的行为是不同" class="headerlink" title="团队在不同的阶段，想要变得更好，需要鼓励的行为是不同"></a>团队在不同的阶段，想要变得更好，需要鼓励的行为是不同</h3><p>这个可能是最不容易被大家理解的，也是很容易因为这个原因导致有很多优秀的同事觉得自己做得很好却只拿到了普通考核。</p>
<p>例如，一些难点攻坚，搞定了就迈过一个大台阶继续高速前进，搞不定就卡着，这个时候就需要鼓励那种能够沉下心研究钻研的行为；团队新人较多，需要老同事积极传导团队文化，帮助新同事更快融入团队，那么这个时候团队鼓励的就是传道的精神；团队同事多个大项目并行，人力不足，那这个时候更需要关注的就是能否闭环带好一个项目。</p>
<blockquote>
<p>这几个例子可能不太恰当，希望朋友们能领会到我想表达的意思</p>
</blockquote>
<p>到这里为止，我相信大家应该基本还是有共识的，那么接下来可能就是一些可能有争议的话题了。</p>
<p>考核也许是管理的一种手段或方法，曾经有位上级说，管理是无情&#x2F;残酷的。对于这个观点，我目前的认知还是不能认同，我们可以说无情在某些时候或场景下能达到管理的目的，有一些管理行为可能看起来是残酷的，但不能说管理是无情的。有情有义，尊重人性，才是这个社会长期向前发展的基调。</p>
<p>还有位上级说，我们无法做到绝对的公平，但是我们尽量做到程序公平，有一个很好的办法就是要有比例，每个团队有比例，比例的意思是：假设10个人，1个优秀，4个良好，1-2个差评（该比例举例用，不要对号到自己团队的实际情况）。乍一听，好像没啥问题啊，但是我认为经不起推敲。</p>
<p>假设A团队是个很优秀的团队，B团队是个很一般的团队或者因为某些原因没有发挥出已有能量的团队，单看一段时间的成果和表现，如果AB团队对比，A的末位齐平B的中位的，如果还要求A和B都保持上面说的比例，是不是很不公平？古人都说，不患贫患不均，如果按照这种逻辑考核AB两个团队，那么A接下来会有2种演进方向，一种是继续努力，然后优秀的人离职去找愿意肯定自己的地方；一种是适当摆烂，以前用120%的精力做事，现在用80%，省下来的40%用来提高自己或者娱乐，间接后果也是，被人挖走或者主动离开。B团队也会觉得好像不发挥权力或者糊弄一下，也不会有啥后果，那就继续磨下去，到时效率低下，进而影响到其他团队。</p>
<p>以上AB团队，改成2个人，在一个组里，就会很自然的绩效有所区分。那么为什么AB作为2个团队放在一个中心，做法就是另一番情况了呢？</p>
<p><strong>又有人说了，公司发展好，同事们不会舍得离开的</strong>。对，这种说法没毛病，谁都希望跟着公司一起发展，早日实现财务自由，这叫看长期利益，可以适当牺牲短期利益。但是如果短期连考核都做不到公平公正，那么长期利益有何可期盼的呢，为什么会觉得长期会得到公平的对待呢，甚至为什么会觉得这样的团队会成就一家伟大的公司呢？<br>诚如优秀的公司和团队不缺对人才的吸引力，优秀的人也从来不缺好的offer。经历过招聘的leader都有这种体验，你面试了100个人，发了10个offer，接受offer的人可能只有5个，还有3个会报到前放鸽子。通常拿了我们offer的人，手上不会缺其他公司的offer，这种现象从大学毕业开始找工作开始就一直存在。大家都会拿多几个offer做下对比，对比下薪酬，公司文化，公司前景，所在行业景气度，甚至00后们已经开始在脉脉等app上反向背调公司了。</p>
<p><strong>还有人说，现在大环境不好，同事们不敢轻易动的</strong>。说这种话的leader，我觉得你应该就地打报告立刻马上辞职。leader是带着团队成事的，不是让你驯兽的。另外，我们也要照照自己，自己是否有资格去评价别人。我们可以评价别人的前提是，对方要认可自己，我们不一定各方面都比对方做得好，但起码得有一个方面让对方认可甚至佩服。换位思考下，一个你自己不认可的人说你这做得不对，那做得不对，你内心肯定想的是“你踏马煞笔吧，你也配指点老子？” 国羽第一人林丹曾说“只有陶菲克有资格评价我”，陶菲克是印尼羽毛球国手，2004年雅典奥运会羽毛球男单冠军，号称“天下第一反手”，是林丹的羽坛王朝前的世界巅峰，举这个例子也只是为了说明前面那句，我们想评价别人，并且希望对方能听得进去，那么起码得先赢得对方的认可，而不是靠组织给我们的行政职位。</p>
<p>也许有人说，反正员工也不知道我们咋考核的。我只能说你是个煞笔，以为别人都是傻子，眼睛都是看不见的？谁做的好谁做的差，哪个团队给力高效，哪个团队整天到处打太极玩办公室政治，大家都看的清清楚楚的。</p>
<p><strong>还有人说，我跟团队面谈的时候，他接受了啊，没有异议啊</strong>。你还是个煞笔，那是人家懒得跟你讲，不说出来的问题难道就认为没问题吗？相反，这才是最大的问题，因为你的团队成员已经不信任你了，不愿意跟你说真话了，内心不知已跑过多少只草泥马了吧。我还很庆幸我的团队的同事还算愿意跟我去吐槽一些工作中的问题，如果哪一天大家不愿意跟我说了，那我真的觉得我作为一个小leader是失败的。</p>
<p>通过”程序公平“尽可能做到公平，这个思路肯定是没问题的，程序起码避免一些个人感情上的偏好，也会有一些很明确的规则，会尽可能的做到公平，但是我们也需要多思考如何让这个程序不断地优化，真的变成一个”公平的程序“呢？</p>
<p>最后，在想明白整个思路后，那最重要的是什么呢？言行要一致，不能说的非常好听，对事不对人，公平，促进团队往更好的方向发展，然后做出的事情都是往相反的方向激励团队，让好的人寒心，让差的人没有任何惩罚。</p>
<p>希望大家能多给我提一些建议，避免我走进死胡同，谢谢<br>​</p>
]]></content>
      <categories>
        <category>team</category>
      </categories>
  </entry>
  <entry>
    <title>tcpdump-netstat</title>
    <url>/2021/08/16/tcpdump-netstat/</url>
    <content><![CDATA[<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>底层基于libpcap，一个可移植的网络传输层C&#x2F;C++库</p>
<p>tcpdump 不加任何参数，默认监听一个默认网卡（eth0网卡），抓取经过该端口的所有的数据包 ^C停止，会显示抓了多少个包</p>
<ul>
<li>c 10 限制只抓10个包</li>
<li>w filename 输出到文件，tcpdump保存的数据包文件格式，是被大部分主流抓包软件所兼容的</li>
<li>r filename 读取之前保存到文件的数据包</li>
<li>D 显示系统当前的网卡列表</li>
<li>i eth0 指定只抓取eth0网卡的流量</li>
<li>v -vv 显示抓到的流量的详细信息，v越多越详细</li>
<li>n 源地址和目的地址用ip显示，不反解为域名</li>
</ul>
<span id="more"></span>

<p>tcpdump tcp&#x2F;udp&#x2F;icmp 指定抓取某种类型的流量</p>
<p>icmp 例如ping</p>
<p>tcpdump port 80 指定抓取某个端口的流量（80是http的流量）</p>
<p>tcpdump portrange 1-1024 抓取某个范围端口的流量</p>
<p>tcpdump src&#x2F;dst port 80 指定源&#x2F;目标端口为80的流量</p>
<p>tcpdump src&#x2F;dst host hostname 只抓取源&#x2F;目标地址的流量</p>
<p>tcpdump host <a href="http://www.baidu.com/">www.baidu.com</a> 指定抓取来自或去到某个host（可以是域名或IP）的流量</p>
<p>tcpdump greater 1000 只抓取大于1000bytes的流量</p>
<p>tcpdump less 10  只抓取小于10bytes的流量</p>
<ul>
<li>A 以ASCII码形式显示数据包的内容</li>
<li>X 以16进制和ASCII码形式来显示数据包内容</li>
</ul>
<p>支持与 或 非</p>
<p>tcpdump tcp and src [host] 192.168.1.1 and src port 1000 抓取源地址为192.168.1.1:1000的tcp包</p>
<p>tcpdump src 192.168.1.1 or src 192.168.1.2  抓取源地址为192.168.1.1或192.168.1.2的数据包</p>
<p>tcpdump not port 80 抓取非80端口的流量</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><ul>
<li>p port</li>
<li>a all</li>
<li>t tcp</li>
<li>u udp</li>
<li>l listenning</li>
<li>n 不进行域名解析</li>
<li>c connection status real-time</li>
</ul>
]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title>团队梯度</title>
    <url>/2023/12/11/team-gradient/</url>
    <content><![CDATA[<p>曾经有一段时间，我希望团队每一个同事都出类拔萃，都是骨干。但是，在经历了一些事情，反复进行过一些思考后，我发现，这个希望是很美好的，但是要实现，是一个非常难的事情。每个人对自己的要求，对自己情绪的把控，对自己心态的调节，对自己提升的要求，很多方面，其实都是不同的，也许每个月在每段工作经历中都是有不同的个人诉求的，成就感也是来自于不同的点。从团队角度来看，可能有些个人的诉求点也刚好是当下团队比较看重的，有些反而是团队当下不那么看重的。都很优秀，只是从团队当下的诉求来评判，发生了共振的，显然就会获得更高的成就感，往残酷了说，团队就产生了梯度。</p>
<p>有一些情况，会导致一个前期很优秀的同事突然摆烂了，例如新同事入职后，都会有一段学习期，在学习的过程中，能学到东西，也是一种收获，这个时候可能即使钱给的不是特别多，大家一样很有干劲。然后，慢慢地，觉得每天做的事情自己都能搞的定，每天做的平平淡淡，缺少了挑战和激情，钱又没跟着起来，可能就会开始觉得不爽，会出去面试看机会，发现意向offer给的更多了，就更加会觉得自己待下去不爽了，进而慢慢地工作态度就开始出现变化，慢慢地在团队里面从上变成中了，变成低的通常比例不会太高，因为通常优秀的人对自己的要求还是有的，不会容许发生败坏自己职业操守的事情（当然你碰上个煞笔leader要给你打个低绩效来激励你就另当别论了）。</p>
<p>很多时候，心态都需要自己去调整。无论是找自己认可的前辈去请教，还是找自己的leader沟通，或者去网上找别人的分享，或者在某次大汗淋漓的运动时突然想到一个以前没思考或关注过的点，每个人都有各种不同的方法去做调整，但都是要自己去调整，你的朋友，前辈，leader，能给的只是少量的建议，思维和认知的提升，还是主要要靠自己的。留下or离开，都是每个人职业生涯中的一个个很重要的选择，需要认真思考，三思而后行。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>认知</tag>
        <tag>团队</tag>
      </tags>
  </entry>
  <entry>
    <title>懂，但是如何做？</title>
    <url>/2022/09/08/thinkvsdo/</url>
    <content><![CDATA[<p>很多道理，懂的人很多，但是能否在行动上对齐，每个人的水平可就差得远了去了。</p>
<p>有权力的时候，可以更少阻力去尝试一些事情，成了当然效用巨大，但是失败了，成本也巨大，有的人就经常为了一些尝试一些理论，不计成本，或者他认为这个成本是别人帮他承担，甚至造成了一些伤害后，脚底抹油，这种行为最让人看不起。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>胡思乱想</category>
      </categories>
  </entry>
  <entry>
    <title>一个leader要少对团队说“你这样是不对的”</title>
    <url>/2022/08/20/what-a-leader/</url>
    <content><![CDATA[<p>有的leader，经常听团队汇报问题的时候，刚听了两句就打断说“你这样是不对的”，甚至连听完全部的耐心都没有。</p>
<span id="more"></span>

<p>我认为，没有什么事情是有绝对的对错的，只要不是有严格明确的标准答案的东西，当下的社会，都不要随便就去说别人不对。大家只是认知水平不一致，做出的事情或者决策是有差异的，使用的方式方法是不同的，并没有谁对谁错，可以探讨，一起去做得更好，但真的要少说别人不对，尤其是leader对团队同事更不能说。</p>
<p>团队的不同同事可能对一些工作上的信息面没有leader充分，基于他已掌握的信息面，他没有什么错误，甚至对一些资深的同事，其做出的判断，即使在信息面不如leader的情况下，也很可能其判断是更合适当下形势的。作为一个leader，千万不要因为自己有个title，就真的觉得自己认知比其他人高了，title带来的是责任，没有什么其他的东西，没有让你认知更吊，也没有带来什么所谓的权力。也不要以为自己在外面上了个什么MBA或者参加了什么沙龙，就觉得自己老牛逼了，你可能真的可惜生在互联网时代了，浪费了互联网的大好资源。现在大部分的课，包括付费课，只要想找，90%以上在网上都找得到，说不定你的团队的同事早就在网上看过了不知多少类似的东西了，甚至更说不定其已经对比过多个类似的课程后，自己思考形成了自己的认知，并不断修正升级。不要去怀疑这种事情，因为职位低，工作之余剩下的精力肯定更多，就更有时间去学习和探索。</p>
<p>如果一个leader整天说下属不对，那这个leader很有问题；如果一个下属被leader说不对的时候，从不反驳，全盘接收，那这个下属基本要么是不会自我思考，要么就是阳奉阴违，都可以被判定为不堪重用。当然，也不能为了反驳而反驳，leader说一句，下属有三句在那等着，那死的会更惨，哎，太难了！</p>
<p>此文勉励自己，希望能跟团队一起把工作做得更好，在未来的某一天提起一起做事的时候是不是互相吐槽周围都是些shaX。</p>
]]></content>
      <categories>
        <category>team</category>
      </categories>
  </entry>
  <entry>
    <title>信任在团队中的重要性</title>
    <url>/2023/04/07/why-u-need-believeness/</url>
    <content><![CDATA[<p>我跟团队的每一个人都说过一句话，“没有信任基础的团队注定一事无成”，为什么要这么强调“信任”的重要性？</p>
<p>信任需要维护，且极容易失去</p>
<p>信用非常强大却非常脆弱，需要花很大的成本维护，如果不愿意花这个成本，只想着用朝令夕改来赚短线，那会死得非常快</p>
<p>没有手机支付的时候，早餐摊顾客自己找零。有了手机支付后，顾客自己扫码支付。</p>
<p>所有套路，都是一时的术，不可持续，诚实守信才是道</p>
<span id="more"></span>

<p>A和B两个团队，在工作上，需要长期协作，那么从这个团队刚开始接触开始，发展轨迹因为一些日常小事的发生，会走向截然不同的2种轨迹</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>异地多活架构设计-概论</title>
    <url>/2021/06/03/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>近期工作中要做一些系统的质量工作，那么多活肯定是一个避不开的事情，借此机会，系统梳理下异地多活的架构设计，为接下来的服务质量做一些准备。</p>
<h2 id="0-预设"><a href="#0-预设" class="headerlink" title="0 预设"></a>0 预设</h2><p>本文预设读到的同学是对服务器开发领域有一定的认知的，对一些比较基础的认知类的东西，不会去做太多的科普。</p>
<h2 id="1-几个概念解释"><a href="#1-几个概念解释" class="headerlink" title="1 几个概念解释"></a>1 几个概念解释</h2><ul>
<li><p>冷备：备份全量数据，<strong>平时不支撑业务需求，即不接受服务通信请求</strong>，只有在主机房出现故障的时候才会切换到备用机房，通常切换完成后提供的也是<strong>有损服务</strong>。</p>
<blockquote>
<p>冷备的方案主要有下面几点问题:</p>
<ol>
<li>成本高，平常不跑业务，干晾着。</li>
<li>因为平时不接收流量，真的出问题了，你敢把流量切过去吗？ 我反正还是有点怂的。</li>
<li>接2，即使你敢切，切换到冷备系统，也不一定能成功把业务接管过来，说不定根本就跑不起来。</li>
<li>接3，运气再好一点，冷备系统有能力接管，在接收流量后能马上正常提供服务。可能整个切换动作花费的时间也会比较长。</li>
</ol>
</blockquote>
</li>
<li><p>活：是相对于冷备而言的，在日常的业务中要有流量，做业务支撑。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="2-为什么要做多活架构"><a href="#2-为什么要做多活架构" class="headerlink" title="2 为什么要做多活架构"></a>2 为什么要做多活架构</h2><p>服务是怎么一步步从单实例到异地多机房多活的呢？ 以下单纯从研发角度，不考虑跨国业务，也先不考虑数据同步的问题，简单推演以下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:服务部署好了，你可以发个请求试试</span><br><span class="line">B:biubiubiu，一切正常，不错。after a moment，啊，请求超时了。</span><br><span class="line">A:我查一下，啊，服务挂了，就部署了1个实例。**等我再部署几个一起收请求**，不全挂就行了。</span><br><span class="line">B:biubiubiu，一切正常，不错。after a moment，啊，请求又超时了。</span><br><span class="line">A:我查一下，卧槽，机器硬盘坏了，**我找多几台机器（同一个机房），每个机器都部署几个服务实例**，机器不全挂就行了。</span><br><span class="line">B:biubiubiu，一切正常，不错。after a moment，啊，请求又超时了。</span><br><span class="line">A:好羞愧啊，我去查一下，啊，机房停电了，我去**另一个机房**也部署下服务吧，总不能2个机房一起挂吧。</span><br><span class="line">B:biubiubiu，一切正常，不错。after a moment，啊，请求又超时了。</span><br><span class="line">A:卧槽，这几天珠三角下雨把**深圳和广州2个机房（距离太近）**都淹了，我在北京机房也部署个服务去。这样请求耗时一点，但是起码不会珠三角跟北京一起出问题吧。</span><br><span class="line">B:biubiubiu，一切正常，不错。after a moment，啊，请求又超时了。</span><br><span class="line">A:艹，深圳和广州的机房空调坏了，北京机房停电了，md认命吧，我们去买个彩票吧。</span><br><span class="line">B:原来后台做个数据的增删改查这么麻烦，还是我app挪按钮好一点。</span><br></pre></td></tr></table></figure>

<p>现在基本都清楚为啥要做异地多活了吧。那么异地多活，除了解决以上问题，还能解决其他哪些问题呢？</p>
<ul>
<li>业务一致性、灾难恢复的诉求，不把鸡蛋放在一个篮子里， 避免由于一个集群或机房的不稳定导致业务出现问题。</li>
<li>在系统扩展、容灾恢复、更新发布时做到数据无损，且服务持续可用</li>
<li>有些业务应用可能是面向分布在全球的终端用户，那么为了减少服务之间的访问延时，这些业务应用服务就需要被部署在全球相应的地域； 与此同时，有些特定业务，由于它的特殊性，需要满足本地数据合规要求，也需要将这一些应用服务部署在对应的地域中。例如前段时间tiktok美国版的纠纷，就是川大统领要求美国人的数据必须放在美国。</li>
</ul>
<p>那么异地多活架构是不是就是万金油呢？没啥缺点吗？有的！</p>
<ul>
<li>只是极力减少服务不可用的概率，并无法完全杜绝。</li>
<li>异地多活，架构设计上要考虑很多东西，<strong>系统复杂度指数级增加</strong>，需要平衡好系统设计复杂度跟服务可用率之间的取舍。<ul>
<li>跨机房调用，服务延时问题</li>
<li>用户数据多机房同步问题</li>
<li>用户数据拆分到多机房的策略问题</li>
<li>还有各种乱七八糟其他问题</li>
</ul>
</li>
</ul>
<h2 id="3-常见多机房架构设计"><a href="#3-常见多机房架构设计" class="headerlink" title="3 常见多机房架构设计"></a>3 常见多机房架构设计</h2><h3 id="3-1-阶段1：同城双机房-服务间调用和数据访问会有跨机房流量"><a href="#3-1-阶段1：同城双机房-服务间调用和数据访问会有跨机房流量" class="headerlink" title="3.1 阶段1：同城双机房: 服务间调用和数据访问会有跨机房流量"></a>3.1 阶段1：同城双机房: 服务间调用和数据访问会有跨机房流量</h3><p>设计要点</p>
<ul>
<li>关键在于<strong>搭建高速网络</strong>将两个机房连接起来，达到近似一个本地机房的效果。架构设计上可以将两个机房当作本地1个机房来设计<blockquote>
<p>同城异区或邻近城市的两个机房距离一般就是几十千米，网络传输速度几乎和同一个机房相同，降低了系统设计的复杂度、成本。</p>
</blockquote>
</li>
<li>服务在2个机房部署热备，数据库主备也部署到不同的机房。只是<strong>解决了机房容量不足的问题</strong></li>
<li>会存在跨机房调用（包括跨机房rpc调用和跨机房db访问）<ol>
<li>服务无状态，每一次RPC调用都有50%的概率跨机房。</li>
<li>数据库主库只能位于一个机房，所以50%的数据库访问也是跨机房的。</li>
</ol>
</li>
</ul>
<p>同城跨机房专线访问的耗时在数毫秒级，图中用暗黄色线表示。如果微服务架构下的服务众多，每次完整的调用链有个几十次rpc调用，那么这部分的延迟加起来也很可观了。</p>
<p><img src="https://image-bed-1257857175.cos.ap-guangzhou.myqcloud.com/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/one-city-multi-dc-01.svg" alt="服务间调用和数据访问有跨机房"></p>
<p>注意，这个多机房是在同城的（同一个城市，或者临近的两个城市），地理位置很近。</p>
<p>综合考虑系统设计复杂度，机房成本，故障发生概率，<strong>同城多机房架构是应对多机房级别故障最优架构</strong>。</p>
<h3 id="3-2-阶段2：只有数据访问会跨机房"><a href="#3-2-阶段2：只有数据访问会跨机房" class="headerlink" title="3.2 阶段2：只有数据访问会跨机房"></a>3.2 阶段2：只有数据访问会跨机房</h3><p>依靠不同服务注册中心，将应用层逻辑隔离开。请求按照预设的负载均衡规则进入其中一个机房，接下来所有的请求调用都在这个机房内处理完。但是，由于数据库主库只在其中一边，所以这个阶段仍然没解决一半数据访问跨机房的问题。</p>
<p><img src="https://image-bed-1257857175.cos.ap-guangzhou.myqcloud.com/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/one-city-multi-dc-02.svg" alt="只有数据访问跨机房"></p>
<h3 id="3-3-阶段3：两地三中心"><a href="#3-3-阶段3：两地三中心" class="headerlink" title="3.3 阶段3：两地三中心"></a>3.3 阶段3：两地三中心</h3><p>在金融系统中广泛应用的容灾部署模式，性价比较高。</p>
<p>这是当前看最主流的灾备方案，数据中心1和数据中心2在<strong>同城</strong>作为生产级的机房，当用户访问的时候随机访问到数据中心A或B。之所以随便访问，因为A和B会<strong>同步</strong>做数据复制，所以两边的数据是完全一样的。但是因为是同步复制的，所以只能在同城去做两个数据中心，否则太远的话同步复制的延时会太长。</p>
<ul>
<li>两个生产级的数据中心1和2，必须在同一个城市，或者在距离很近的另外一个城市，但是距离是有要求的.</li>
<li>异地灾备机房距离数据库主节点距离过远，数据访问耗时过长</li>
<li>异地灾备节点数据不是实时一致的（因为远），在同城的主备机房可用的情况下，都不会选择让异地备机房直接提供服务。</li>
</ul>
<p>其实这个异地机房就是最前面说的冷备，那么那些冷备机房的问题，它都有。</p>
<ul>
<li>当数据中心1和2出问题的时候，不敢流量切往异地的备份数据中心，敢切但用不起来，能用起来但切换时间久。</li>
<li>异地备份中心因为不对外提供服务，所以整个资源会处于浪费状态，属于浪费了，成本比较高。</li>
<li>在两地三中心中，数据是单点写，单点的压力会比较高。</li>
</ul>
<p><img src="https://image-bed-1257857175.cos.ap-guangzhou.myqcloud.com/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/one-city-multi-dc-03.svg" alt="常说的两地三中心架构"></p>
<p>从以上来看，阶段1的方案是性价比最高的，阶段2次之，阶段3里的异地冷备，平时就是浪费，不差钱就搞一个，最主流的方案。</p>
<h2 id="4-异地多活架构设计"><a href="#4-异地多活架构设计" class="headerlink" title="4 异地多活架构设计"></a>4 异地多活架构设计</h2><p>异地多活一般是指在不同城市建立独立的数据中心，此处的异地，要跟现有的机房位置<strong>相隔足够远</strong>，例如北京和上海。在其中一个城市或邻近城市出现极端灾难的时候，另一个距离很远的城市的机房仍然可用，从而实现服务的高可用。</p>
<h3 id="4-1-设计要点"><a href="#4-1-设计要点" class="headerlink" title="4.1 设计要点"></a>4.1 设计要点</h3><p>异地多活架构有一些天生的<strong>缺陷</strong></p>
<ul>
<li>网络环境复杂，延迟不确定，大致 50ms -&gt; 1s</li>
<li>距离远，搭建专用网络通道复杂度和成本高</li>
<li>因为距离远，肯定会出现数据不一致，需要保证数据短时间不一致时能够提供服务</li>
<li>要求数据高度一致的服务做异地多活要做单元化设计(会另外写一篇来讲单元化设计)</li>
</ul>
<p>异地多活模式适用于<strong>对数据一致性要求不高</strong>的场景，例如</p>
<ul>
<li>用户登录，数据不一致时重新登录即可。</li>
<li>新闻网站，A用户看到的内容跟B用户看到的内容有一些延迟，没啥问题，尤其是现在看新闻基本都是千人千面基于算法推荐的，就更不容易产生用户体验的下降问题。</li>
<li>微博网站，即使丢失一点微博或评论数据也影响不大。</li>
</ul>
<p>异地多活架构的实践，关键<strong>在于数据不一致的情况下，业务不受影响或者影响很小</strong>，这从逻辑的角度上来说其实是矛盾的。对数据一致性要求高的场景，异地多活也可以做，但是设计就要复杂一点，架构设计的主要目的就是为了解决这个矛盾。</p>
<h3 id="4-2-常见设计误区"><a href="#4-2-常见设计误区" class="headerlink" title="4.2 常见设计误区"></a>4.2 常见设计误区</h3><ul>
<li><strong>每个业务</strong>都想要异地多活</li>
<li>想要做到 <strong>100%</strong> 可用，从99.99%到100%，要付出的代价很大很大的哦。<blockquote>
<p>我们要忍受这一小部分用户或者业务上的损失，否则本来想为了保证最后的0.01%的可用性，做个完美方案，结果却发现99.99%也保不住了。</p>
</blockquote>
</li>
<li>只使用存储系统自己的同步方案（例如使用MySQL的时候，只使用MySQL自身提供的主从同步），没有其他并行的数据同步方案。</li>
<li>数据想要做到<strong>实时一致性</strong>（有的时候，最终一致性也是很好的方案。毕竟实时一致性跟最终一致性的复杂度也是不可同日而语的）。</li>
</ul>
<p>以上这些误区，都是因为想把系统做到<strong>完美</strong>，但是<strong>所有的设计其实都是有一定的取舍</strong>，有舍才有得，我们要的是最大性价比的方案，在系统设计复杂度和系统可用性两方面找到一个平衡。当然，这个平衡点，不同的业务会有很大区别，例如（微博和支付业务）。同一个业务，随着业务的发展，平衡点也可能需要不断地去调整。</p>
<h3 id="4-3-异地多活架构设计要解决的问题"><a href="#4-3-异地多活架构设计要解决的问题" class="headerlink" title="4.3 异地多活架构设计要解决的问题"></a>4.3 异地多活架构设计要解决的问题</h3><ul>
<li>跨机房接口调用慢导致的延时。(其实所有的问题，就是因为距离远，但是异地的初衷就是要距离远的)<blockquote>
<p>根据业务做单元化，如交易单元，同一个业务的整个流程，尽量避免跨机房，这样来避免延时问题。（单元化另写一篇讲）</p>
</blockquote>
</li>
<li>数据同步慢导致的数据实时一致性问题。</li>
<li>单元化之后导致的数据写入路由一致性问题。</li>
<li>不同单元之间的数据同步问题。</li>
</ul>
<h3 id="4-4-正确的设计思路"><a href="#4-4-正确的设计思路" class="headerlink" title="4.4 正确的设计思路"></a>4.4 正确的设计思路</h3><ul>
<li><strong>只保证核心业务</strong>的异地多活</li>
<li>核心数据做到<strong>最终一致性</strong>，<strong>不必须</strong>实时一致性，Best Effort即可，有以下一些方法<ul>
<li>可以减少数据同步量，只同步核心数据</li>
<li>搭建高速网络</li>
</ul>
</li>
<li><strong>避免只使用存储系统的同步功能</strong>，可以将多种手段配合存储系统的同步来使用，甚至可以不采用存储系统的同步方案，改用自己的同步方案(不同方式，尽可能走不同的网络通道)<ul>
<li>消息队列方式</li>
<li>二次读取方式</li>
<li>回源读取方式</li>
<li>重新生成数据方式</li>
</ul>
</li>
<li><strong>只保证绝大部分用户</strong>的异地多活</li>
<li>很多业务的异地多活，是需要从业务的设计上去考虑</li>
</ul>
<h3 id="4-5-异地多活架构的锦上添花–地域感知的负载均衡"><a href="#4-5-异地多活架构的锦上添花–地域感知的负载均衡" class="headerlink" title="4.5 异地多活架构的锦上添花–地域感知的负载均衡"></a>4.5 异地多活架构的锦上添花–地域感知的负载均衡</h3><h4 id="4-5-1-为什么要有地域感知负载均衡"><a href="#4-5-1-为什么要有地域感知负载均衡" class="headerlink" title="4.5.1 为什么要有地域感知负载均衡"></a>4.5.1 为什么要有地域感知负载均衡</h4><ul>
<li>在跨地域部署的多集群中，各地域可能会部署<strong>本地区定制化</strong>的服务，这些场景要求服务间的访问不能随机路由，需要优先（或只能）访问本地域服务。比如<ul>
<li>不同地区的服务会有不同的显示语言或定制功能</li>
<li>某些服务只在特定区域开放</li>
</ul>
</li>
<li>用作容灾。在多地域架构中， 往往会有一个主集群， 拥有较为充足的服务资源， 而容灾地域的资源仅保证服务基本可用。因此我们要求正常情况下，请求能由主集群提供服务，流量不要地域间随机路由。</li>
<li>除了以上场景，若2个异地对等集群，提供服务和持有资源完全相同， 我们也应该<strong>尽量满足本地域内闭环服务</strong>， 因为跨地域的服务访问往往会有较大的延迟，用户体验差，且可能会让容错性较差的系统出现服务雪崩的风险。</li>
</ul>
<h4 id="4-5-2-地域负载均衡默认使用的地域优先策略"><a href="#4-5-2-地域负载均衡默认使用的地域优先策略" class="headerlink" title="4.5.2 地域负载均衡默认使用的地域优先策略"></a>4.5.2 地域负载均衡默认使用的地域优先策略</h4><ul>
<li>最高优先级：相同地域且相同区域</li>
<li>第二优先级：相同地域但不同区域</li>
<li>最低优先级：不同地域</li>
</ul>
<h2 id="5-通常的异地多活演进"><a href="#5-通常的异地多活演进" class="headerlink" title="5 通常的异地多活演进"></a>5 通常的异地多活演进</h2><h3 id="5-1-演进过程"><a href="#5-1-演进过程" class="headerlink" title="5.1 演进过程"></a>5.1 演进过程</h3><ol>
<li>同城的双活。</li>
<li>异地只读及冷备(类似两地三中心)</li>
<li>异地多活。在异地多活之前，最重要是同城的“双活”，双活上打了一个引号，原因在于同城双活的情况下，其实整个模式是应用层是双活的，两边的业务都有，用户访问过去都会处理请求。但是存储层都是主备的，主在A机房，备在B机房，不会同时用，可以说是伪双活，不是真正意义上的双活。</li>
</ol>
<h3 id="5-2-经验总结"><a href="#5-2-经验总结" class="headerlink" title="5.2 经验总结"></a>5.2 经验总结</h3><ul>
<li>服务调用延时问题<blockquote>
<p>让操作全部在同一中心内完成，使用单元化设计<br>比如用户请求路由到某个数据中心后，在淘宝上浏览商品，搜索、下单、添加购物车等操作，还包括写数据库，都在其进入的那个数据中心中完成，而不需要跨数据中心</p>
</blockquote>
</li>
<li>数据同步的延时问题<blockquote>
<p>核心业务的数据，要做到全国范围1s内完成骨干网数据同步<br>这个也主要靠单元化设计来解决，把用户操作封闭在一个单元内完成，那个用户被sharding到的单元<br>自研数据同步中间件，补充数据库自有的数据同步途径。</p>
</blockquote>
</li>
<li>部署规模<blockquote>
<p>还是单元化设计，将关系紧密的一组业务单元化<br>流量很大的单元，通常流量会爆发性增长，这类单元，做异地部署，流量小的，就没有必要了。<br>例如，对淘宝来说，只异地部署跟买家交易相关的核心业务单元，让买家整个购物过程顺畅完成，卖家对一些体验的容忍度会比买家高很多。每家公司需要根据自己业务的关注点，做出合适的选择。<br>另外，在数据层自身支持跨机房服务之前，不建议部署超过两个的机房。因为异地两个机房，异地容灾的目的已经达成，且服务器规模足够大各种配套的设施也会比较健全，运维成本也相对可控。当扩展到三个点之后，新机房基础设施磨合、运维决策的成本等都会大幅增加</p>
</blockquote>
</li>
<li>路由一致性<blockquote>
<p>这是单元化设计后出现的问题。除了将关系紧密的一组业务单元化，还有另一个维度做单元化，就是根据用户做sharding，将不同的用户分流到不同的单元。<br>买家相关的数据在写的时候，一定是要写在他所属的那个单元里。要保障这个用户从进来一直到访问服务，访问数据库，全链路的路由规则都是完全一致的。如果说某个用户本来应该进A数据中心，但是却因为路由错误，进入了B数据中心，那看到的数据可能就是错的了。造成的结果，可能是用户看到的购买列表是空的，买的东西不见了，已付款的交易变成未付款，这都是不能接受的。</p>
</blockquote>
</li>
<li>数据一致性<blockquote>
<p>在任何时间点，必须确保单行的数据在一个地方写，绝对不能在多个地方写。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
        <tag>异地多活</tag>
      </tags>
  </entry>
</search>
